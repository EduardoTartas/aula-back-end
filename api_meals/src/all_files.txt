
===== ./app.js =====


===== # =====


===== separador =====


===== legível =====

// src/app.js

import express from "express";
import routes from "./routes/index.js";
import cors from "cors";
import helmet from "helmet";
import compression from "compression";
import DbConect from './config/DbConnect.js';
import errorHandler from './utils/helpers/errorHandler.js';
import logger from './utils/logger.js';
import CommonResponse from './utils/helpers/CommonResponse.js';
import fileUpload from 'express-fileupload';

const app = express();

// Configura o middleware express-fileupload
app.use(fileUpload({
    createParentPath: true, // Cria diretórios automaticamente se não existirem
    limits: { fileSize: 5 * 1024 * 1024 }, // Limita o tamanho do arquivo a 5MB (ajuste conforme necessário)
    abortOnLimit: true, // Aborta a requisição se o limite for excedido
    responseOnLimit: 'Tamanho do arquivo excede o limite permitido.' // Mensagem de resposta quando o limite é excedido
}));


// Conectando ao banco de dados
await DbConect.conectar();

// Middlewares de segurança
app.use(helmet());

// Habilitando CORS
app.use(cors());

// Habilitando a compressão de respostas
app.use(compression());

// Habilitando o uso de json pelo express
app.use(express.json());

// Habilitando o uso de urlencoded pelo express
app.use(express.urlencoded({ extended: true }));

// Passando para o arquivo de rotas o app
routes(app);

// Middleware para lidar com rotas não encontradas (404)
app.use((req, res, next) => {
    return CommonResponse.error(
        res,
        404,
        'resourceNotFound',
        null,
        [{ message: 'Rota não encontrada.' }]
    );
});


// Listener para erros não tratados (opcional, mas recomendado)
process.on('unhandledRejection', (reason, promise) => {
    logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
    // Não finalizar o processo para evitar interrupção da API
});

process.on('uncaughtException', (error) => {
    logger.error('Uncaught Exception thrown:', error);
    // Não finalizar o processo para evitar interrupção da API
    // Considerar reiniciar a aplicação em caso de exceções críticas
});

// Middleware de Tratamento de Erros (deve ser adicionado após as rotas)
app.use(errorHandler);

// exportando para o server.js fazer uso
export default app;

===== ./config/DbConnect.js =====


===== # =====


===== separador =====


===== legível =====

// src/config/DbConnect.js
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import { URL } from 'url';
import SendMail from '../utils/SendMail.js'; // Assegure-se de que este caminho está correto
import logger from '../utils/logger.js';

dotenv.config(); // Carrega as variáveis de ambiente

/**
 * Classe responsável por gerenciar a conexão com o MongoDB.
 */
class DbConnect {
    /**
     * Estabelece a conexão com o MongoDB.
     */
    static async conectar() {
        try {
            const mongoUri = process.env.DB_URL;

            if (!mongoUri) {
                throw new Error("A variável de ambiente DB_URL não está definida.");
            }

            // Log seguro indicando que a URI está definida
            logger.info('DB_URL está definida.');

            // Configuração de strictQuery baseada no ambiente
            if (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test') {
                mongoose.set('strictQuery', false);
            } else {
                mongoose.set('strictQuery', true);
            }

            // Configurações condicional para autoIndex e debug
            if (process.env.NODE_ENV === 'development') {
                mongoose.set('autoIndex', true); // Cria índices automaticamente
                mongoose.set('debug', true); // Ativa logs de debug
                logger.info('Configurações de desenvolvimento ativadas: autoIndex e debug.');
            } else {
                mongoose.set('autoIndex', false); // Desativa criação automática de índices
                mongoose.set('debug', false); // Desativa logs de debug
                logger.info('Configurações de produção ativadas: autoIndex e debug desativados.');
            }

            // Adiciona listeners para eventos do Mongoose
            mongoose.connection.on('connected', () => {
                logger.info('Mongoose conectado ao MongoDB.');
            });

            mongoose.connection.on('error', (err) => {
                logger.error(`Mongoose erro: ${err}`);
                if (process.env.NODE_ENV !== 'test') {
                    SendMail.enviaEmailErrorDbConect(err, new URL(import.meta.url).pathname, new Date());
                }
            });

            mongoose.connection.on('disconnected', () => {
                logger.info('Mongoose desconectado do MongoDB.');
            });

            // Conexão com opções configuráveis via variáveis de ambiente
            await mongoose.connect(mongoUri, {
                serverSelectionTimeoutMS: process.env.MONGO_SERVER_SELECTION_TIMEOUT_MS
                    ? parseInt(process.env.MONGO_SERVER_SELECTION_TIMEOUT_MS)
                    : 5000,
                socketTimeoutMS: process.env.MONGO_SOCKET_TIMEOUT_MS
                    ? parseInt(process.env.MONGO_SOCKET_TIMEOUT_MS)
                    : 45000,
                connectTimeoutMS: process.env.MONGO_CONNECT_TIMEOUT_MS
                    ? parseInt(process.env.MONGO_CONNECT_TIMEOUT_MS)
                    : 10000,
                retryWrites: true,
                maxPoolSize: process.env.MONGO_MAX_POOL_SIZE
                    ? parseInt(process.env.MONGO_MAX_POOL_SIZE)
                    : 10,
            });

            logger.info('Conexão com o banco estabelecida!');
        } catch (error) {
            logger.error(`Erro na conexão com o banco de dados em ${new Date().toISOString()}: ${error.message}`);
            if (process.env.NODE_ENV !== 'test') {
                SendMail.enviaEmailErrorDbConect(error, new URL(import.meta.url).pathname, new Date());
            }
            throw error; // Re-lança o erro para permitir que o aplicativo lide com a falha de conexão
        }
    }

    /**
     * Desconecta do MongoDB.
     */
    static async desconectar() {
        try {
            await mongoose.disconnect();
            logger.info('Conexão com o banco encerrada!');
        } catch (error) {
            logger.error(`Erro ao desconectar do banco de dados em ${new Date().toISOString()}: ${error.message}`);
            if (process.env.NODE_ENV !== 'test') {
                SendMail.enviaEmailErrorDbConect(error, new URL(import.meta.url).pathname, new Date());
            }
            throw error; // Re-lança o erro para permitir que o aplicativo lide com a falha de desconexão
        }
    }
}

export default DbConnect;

===== ./config/multerConfig.js =====


===== # =====


===== separador =====


===== legível =====

import multer from "multer";

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "uploads/");
  },
  filename: (req, file, cb) => {
    cb(null, `estudante-data-upload-${file.originalname}`);//`${Date.now()}-${file.originalname}`
  },
});

const upload = multer({ storage });

export default upload;
===== ./config/paginacao.js =====


===== # =====


===== separador =====


===== legível =====

import paginate from "mongoose-paginate-v2";

paginate.paginate.options = {
  leanWithId: false
};

const myCustomLabels = {
    totalDocs: "resultados",
    docs: "data",
    limit: "limite",
    page: "pagina",
    totalPages: "totalPaginas",
    pagingCounter: false,
    hasPrevPage: false,
    hasNextPage: false,
    prevPage: false,
    nextPage: false
};

export const paginateOptions = {
    page: 1,
    limit: 50,
    customLabels: myCustomLabels
};

===== ./constants/Constants.js =====


===== # =====


===== separador =====


===== legível =====

// class Constants {
//     static STATUS_ACTIVE = 'active';
//     static STATUS_INACTIVE = 'inactive';
//     static DEFAULT_LIMIT = 100;

//     // Arrays Enums for the event status
//     static EVENT_STATUS = {
//         PENDING: 'pending',
//         PROCESSED: 'processed',
//         FAILED: 'failed',
//     };    
//     // Arrays Enums for the event type
// }

// export default Constants;

===== ./controllers/AuthController.js =====


===== # =====


===== separador =====


===== legível =====

// /src/controllers/AuthController.js

import jwt from 'jsonwebtoken';
import { promisify } from 'util';
import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';
import { LoginSchema } from '../utils/validators/schemas/zod/LoginSchema.js';
import { UsuarioSchema, UsuarioUpdateSchema } from '../utils/validators/schemas/zod/UsuarioSchema.js';
import { UsuarioIdSchema } from '../utils/validators/schemas/zod/querys/UsuarioQuerySchema.js';
import { RequestAuthorizationSchema } from '../utils/validators/schemas/zod/querys/RequestAuthorizationSchema.js';

import AuthService from '../services/AuthService.js';

/**
   * Validação nesta aplicação segue o segue este artigo:
   * https://docs.google.com/document/d/1m2Ns1rIxpUzG5kRsgkbaQFdm7od0e7HSHfaSrrwegmM/edit?usp=sharing
*/
class AuthController {
  constructor() {
    this.service = new AuthService();
  }
  /**
   * Método para fazer o login do usuário
   */
  login = async (req, res) => {
      // 1º validação estrutural - validar os campos passados por body
      const body = req.body || {};
      const validatedBody = LoginSchema.parse(body);
      const data = await this.service.login(validatedBody);
      return CommonResponse.success(res, data);
  }

  /**
   * Método para fazer o refresh do token 
   */
  revoke = async (req, res) => {
    // Extrai ID do usuario a ter o token revogado do body
    const id = req.body.id;
    // remove o token do banco de dados e retorna uma resposta de sucesso
    const data = await this.service.revoke(id);
    return CommonResponse.success(res);

  }

  /**
   * Método para fazer o refresh do token 
   */
  refresh = async (req, res) => {
    // Extrai do body o token
    const token = req.body.refreshtoken;

    console.log('RF' + token);

    // Verifica se o cabeçalho Authorization está presente
    if (!token || token === 'null' || token === 'undefined') {
      console.log('Cabeçalho Authorization ausente.');
      throw new CustomError({
        statusCode: HttpStatusCodes.BAD_REQUEST.code,
        errorType: 'invalidRefresh',
        field: 'Refresh',
        details: [],
        customMessage: 'Refresh token is missing.'
      });
    }

    // Verifica e decodifica o token
    const decoded = await promisify(jwt.verify)(token, process.env.JWT_SECRET);

    // encaminha o token para o serviço
    const data = await this.service.refresh(decoded.id, token);
    return CommonResponse.success(res, data);
  }


  /**
   *  Metodo para recuperar a senha do usuário
   */
  recuperaSenha = async (req, res) => {
    console.log('Estou no logar em RecuperaSenhaController, enviando req para RecuperaSenhaService');

    // 1º validação estrutural - validar os campos passados por body
    const body = req.body || {};

    // Validar apenas o email
    const validatedBody = UsuarioUpdateSchema.parse(req.body);
    const data = await this.service.recuperaSenha(validatedBody);
    return CommonResponse.success(res, data);
  }

  /**
   * Método para fazer o logout do usuário
   */
  logout = async (req, res) => {
    // Extrai o cabeçalho Authorization
    const auth = req.headers.authorization;

    // Verifica se o cabeçalho Authorization está presente
    if (!auth) {
      console.log('Cabeçalho Authorization ausente.');
      throw new CustomError({
        statusCode: HttpStatusCodes.BAD_REQUEST.code,
        errorType: 'invalidLogout',
        field: 'Logout',
        details: [],
        customMessage: 'Authorization header is missing.'
      });
    }

    // Extrai o token do cabeçalho Authorization
    const token = auth.split(' ')[1];

    // Verifica se o token está presente e não é uma string inválida
    if (!token || token === 'null' || token === 'undefined') {
      console.log('Token recebido:', token);
      throw new CustomError({
        statusCode: HttpStatusCodes.BAD_REQUEST.code,
        errorType: 'invalidLogout',
        field: 'Logout',
        details: [],
        customMessage: HttpStatusCodes.BAD_REQUEST.message
      });
    }

    // Verifica e decodifica o token
    const decoded = await promisify(jwt.verify)(token, process.env.JWT_SECRET);

    // Verifica se o token decodificado contém o ID do usuário
    if (!decoded || !decoded.id) {
      console.log('Token decodificado inválido:', decoded);
      throw new CustomError({
        statusCode: HttpStatusCodes.INVALID_TOKEN.code,
        errorType: 'notAuthorized',
        field: 'NotAuthorized',
        details: [],
        customMessage: HttpStatusCodes.INVALID_TOKEN.message
      });
    }

    // Encaminha o token para o serviço de logout
    const data = await this.service.logout(decoded.id, token);

    // Retorna uma resposta de sucesso
    return CommonResponse.success(res, HttpStatusCodes.OK.code, messages.success.logout);
  }

  /**
   * Método para validar o token
   */
  pass = async (req, res) => {
    /** Body esperado para a requisição de autorização
      {
        "accesstoken": "string", // Obrigatório
        "refreshtoken": "string", // Opicional
        "domain": "string", // Obrigatório
        "path": "string", // Obrigatório
        "metodo": "string", // Obrigatório
        "query": "string", // Opcional
        "params": {}, // Opcional
        "body": {} // Opcional
      }
    */

    // Validação estrutural - validar os campos passados por body usando o schema RequestAuthorizationSchema
    const bodyrequest = req.body || {};
    console.log('Body recebido:', bodyrequest);

    const validatedBody = RequestAuthorizationSchema.parse(bodyrequest);

    // const { accesstoken, domain, path, metodo, query, params, body } = validatedBody;

    // Verifica e decodifica o accesstoken
    const decoded = await promisify(jwt.verify)(validatedBody.accesstoken, process.env.JWT_SECRET);

    // Verifica se o accesstoken decodificado contém o ID do usuário ao mesmo tempo que valida o ID
    const validaId = UsuarioIdSchema.parse(decoded.id);

    // Retorna uma resposta de sucesso
    return CommonResponse.success(res, validatedBody, HttpStatusCodes.OK.code, messages.authorized.default);
  }

}

export default AuthController;

===== ./controllers/CursoController.js =====


===== # =====


===== separador =====


===== legível =====

// src/controllers/CursoController.js

import CursoService from '../services/CursoService.js';
import {
  CommonResponse,
  CustomError,
  HttpStatusCodes,
  errorHandler,
  messages,
  StatusService,
  asyncWrapper
} from '../utils/helpers/index.js';

import { CursoQuerySchema, CursoIdSchema } from '../utils/validators/schemas/zod/querys/CursoQuerySchema.js';
import { CursoSchema, CursoUpdateSchema } from '../utils/validators/schemas/zod/CursoSchema.js';

class CursoController {
  constructor() {
    this.service = new CursoService();
  }

  // GET /cursos ou /cursos/:id
  async listar(req, res) {
    console.log('Estou no listar em CursoController');

    // Validação do ID (se existir)
    const { id } = req.params || null;
    if (id) {
      CursoIdSchema.parse(id);
    }

    const query = req.query || {};
    if (Object.keys(query).length !== 0) {
      // Valida as queries (se existirem)
      await CursoQuerySchema.parseAsync(query);
    }

    const data = await this.service.listar(req);
    return CommonResponse.success(res, data);
  }

  // POST /cursos
  async criar(req, res) {
    try {
      const data = await this.service.criar(req.body);
      return CommonResponse.created(res, data);
    } catch (error) {
      return CommonResponse.error(res, error);
    }
  }

  // PUT /cursos/:id
  async atualizar(req, res) {
    try {
      const { id } = req.params;
      const data = await this.service.atualizar(id, req.body);
      return CommonResponse.success(res, data, 200, 'Curso atualizado com sucesso.');
    } catch (error) {
      return CommonResponse.error(res, error);
    }
  }

  // DELETE /cursos/:id
  async deletar(req, res) {
    try {
      const { id } = req.params;
      const data = await this.service.deletar(id);
      return CommonResponse.success(res, data, 200, 'Curso excluído com sucesso.');
    } catch (error) {
      return CommonResponse.error(res, error);
    }
  }
}

export default CursoController;

===== ./controllers/EstagioController.js =====


===== # =====


===== separador =====


===== legível =====

import Estagio from "../models/Estagio.js";
import Estudante from "../models/Estudante.js";
import { paginateOptions } from "../config/paginacao.js";
import { endOfDay, startOfDay } from "date-fns";
import handleQuery from "../utils/handleQuery.js";

class EstagioController {
  static ListarEstagios = async (req, res) => {
    try {
      const query = handleQuery(req.query, { data_inicio: "asc" });

      const estagios = await Estagio.paginate(
        {...query.filtros},
        {
          ...paginateOptions,
            sort: query.ordenar,
            populate: { path: "estudante" },
            page:query.pagina,
            lean: true,
        }
      );
      res.status(200).json(estagios);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  static ListarEstagioPorId = async (req, res) => {
    try {
      const { id } = req.params;
      const estagio = await Estagio.findById(id)
        .populate("estudante");
        if(!estagio){
          throw new Error("Estágio não encontrado!")
        }
      res.status(200).json(estagio);
    } catch (error) {
      if (error.message === "Estágio não encontrado!" || error.kind === "ObjectId") {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };

  static AdicionarEstagio = async (req, res) => {
    try {
      const estagio = req.body;

      // Verificar se o estudante existe
      const estudante = await Estudante.findById(estagio.estudante);
      if (!estudante) {
        throw new Error(
          estagio.estudante === undefined
            ? "O estudante é obrigatório!"
            : `Estudante com matricula/id ${estagio.estudante} não encontrado!`
        );
      }
      const novoEstagio = await Estagio.create(estagio)
        .then((estagio) => estagio.populate("estudante"))
        .then((estagio) => estagio); //Fazer isso para retornar o estudante populado;
      res
        .status(201)
        .json({
          message: "Estágio adicionado com sucesso!",
          estagio: novoEstagio,
        });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  static AtualizarEstagio = async (req, res) => {
    try {
      const { id } = req.params;
      const estagio = req.body;
      const estagioAtualizado = await Estagio.findByIdAndUpdate(id, estagio, {
        new: true,
        runValidators: true,
      })
        .then((estagio) => estagio.populate("estudante"))
        .then((estagio) => estagio); //Fazer isso para retornar o estudante populado;
      if (!estagioAtualizado) {
        throw new Error("Estágio não encontrado!");
      }
      res.status(200).json({
        message: "Estágio atualizado com sucesso!",
        estagio: estagioAtualizado,
      });
    } catch (error) {
      if (error.message === "Estágio não encontrado!" || error.kind === "ObjectId") {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };

  static DeletarEstagio = async (req, res) => {
    try {
      const { id } = req.params;
      const existe =  Estagio.exists({_id: id});
      if (!existe) {
        throw new Error("Estágio não encontrado!");
      }
      await Estagio.findByIdAndDelete(id);
      res.status(200).json({ message: "Estágio deletado com sucesso!" });
    } catch (error) {
      if (error.message === "Estágio não encontrado!" || error.kind === "ObjectId") {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };
}

export default EstagioController;

===== ./controllers/EstudanteController.js =====


===== # =====


===== separador =====


===== legível =====

// /src/controllers/TurmaController.js

import Estudante from "../models/Estudante.js";
import EstudanteService from "../services/EstudanteService.js";
import { paginateOptions } from "../config/paginacao.js";
import handleQuery from "../utils/handleQuery.js";
import Curso from "../models/Curso.js";

import {
  CommonResponse,
  CustomError,
  HttpStatusCodes,
  errorHandler,
  messages,
  StatusService,
  asyncWrapper
} from '../utils/helpers/index.js';

import { EstudanteQuerySchema, EstudanteIdSchema } from '../utils/validators/schemas/zod/querys/EstudanteQuerySchema.js';
import { EstudanteSchema, EstudanteUpdateSchema } from '../utils/validators/schemas/zod/EstudanteSchema.js';

class EstudanteController {
  async listar(req, res) {
    try {
      console.log("Estou no listar em EstudanteController");
      
      const query = handleQuery(req.query, { nome: "asc" });

      const estudantes = await Estudante.paginate(
        { ...query.filtros },
        {
          ...paginateOptions,
          sort: query.ordenar,
          page: query.pagina,
          populate: [{ path: "turma", populate: { path: "curso" } }],
          lean: true,
        }
      );
      res.status(200).json(estudantes);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  async ListarEstudantePorId(req, res) {
    try {
      const { id } = req.params;
      const estudante = await Estudante.findById(id).populate({
        path: "turma",
        populate: { path: "curso" },
      });
      if (!estudante) {
        throw new Error("Estudante não encontrado!");
      }
      res.status(200).json(estudante);
    } catch (error) {
      if (error.message === "Estudante não encontrado!") {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };

  async criar(req, res) {
    try {
      const estudante = req.body;
      estudante._id = estudante.matricula;

      // Verificar se a turma existe
      const turma = await Turma.findById(estudante.turma).catch((error) => {
        throw new Error(`Turma com id ${estudante.turma} não encontrada!`);
      });

      // Verificar se a matricula já existe
      const matriculaExiste = await Estudante.findOne({
        matricula: estudante.matricula,
      });
      if (matriculaExiste) {
        throw new Error("Matrícula já cadastrada!");
      }

      const novoEstudante = await Estudante.create(estudante)
        .then((estudante) => estudante.populate("turma"))
        .then((estudante) => estudante); //Fazer isso para retornar a turma populada;

      res.status(201).json({
        message: "Estudante adicionado com sucesso!",
        estudante: novoEstudante,
      });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  async atualizar(req, res) {
    try {
      const { id } = req.params;
      const estudante = req.body;
      const estudanteAtualizado = await Estudante.findByIdAndUpdate(
        id,
        estudante,
        { new: true }
      )
        .populate("turma")
        .then((estudante) => estudante); //Fazer isso para retornar a turma populada;

      if (!estudanteAtualizado) {
        throw new Error("Estudante não encontrado!");
      }

      res.status(200).json({
        message: "Estudante atualizado com sucesso!",
        estudante: estudanteAtualizado,
      });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  async deletar(req, res) {
    try {
      const { id } = req.params;
      const existe = await Estudante.exists({ _id: id });
      if (!existe) {
        throw new Error("Estudante não encontrado!");
      }
      await Estudante.findByIdAndDelete(id);
      res.status(200).json({ message: "Estudante deletado com sucesso!" });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  async InativarEstudantes(req, res) {
    try {
      await Estudante.updateMany({}, { ativo: false });
      res
        .status(200)
        .json({ message: "Todos os estudantes foram inativados com sucesso!" });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  async Upload(req, res) {
    try {
      const { delimitador } = req.query;
      await EstudanteService.importEstudantesTeste(req.file.filename, delimitador);
      res.status(201).json({
        message: "Importação de estudantes feita com sucesso!",
      });
    } catch (error) {
      res.status(400).json({
        message:
          "Importação Interrompida! Verifique se todas turmas foram adicionadas anteriormente! Verifique se o delimitador do CSV está correto!",
        error_message: error.message,
      });
    }
  };
}

export default EstudanteController;

===== ./controllers/GrupoController.js =====


===== # =====


===== separador =====


===== legível =====

import GrupoService from '../services/GrupoService.js';
import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';
import { GrupoQuerySchema, GrupoIdSchema } from '../utils/validators/schemas/zod/querys/GrupoQuerySchema.js';
import { GrupoSchema, GrupoUpdateSchema } from '../utils/validators/schemas/zod/GrupoSchema.js';

class GrupoController {
    constructor() {
        this.service = new GrupoService();
    }

    /**
     * Validação nesta aplicação segue o segue este artigo:
     * https://docs.google.com/document/d/1m2Ns1rIxpUzG5kRsgkbaQFdm7od0e7HSHfaSrrwegmM/edit?usp=sharing
     */

    /**
     * Lista grupos. Se um ID é fornecido, retorna um único objeto.
     * Caso contrário, retorna todos os objetos com suporte a filtros e paginação.
     */

    async listar(req, res) {
        console.log('Estou no listar em GrupoController, enviando  req para GrupoService');

        //1ª Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (id) {
            GrupoIdSchema.parse(id); // Lança erro automaticamente se inválido
        }

        // 2º Validação estrutural - validar os demais campos passados por query
        const query = req.query || {};
        if (Object.keys(query).length !== 0) {
            const validatedQuery = GrupoQuerySchema.parse(req.query);
        }

        // Chama o serviço para listar os grupos
        const data = await this.service.listar(req);

        console.log('Estou retornando os dados em GrupoController');
        return CommonResponse.success(res, data);
    }

    /**
     * Criar um novo grupo.
     */
    async criar(req, res) {
        console.log('Estou no criar em GrupoController');

        // Validação dos dados de entrada usando Zod (estrutural)
        const parsedData = GrupoSchema.parse(req.body);

        const data = await this.service.criar(parsedData);

        // Se chegou até aqui, é porque deu tudo certo, retornar 201 Created 
        return CommonResponse.created(res, data);
    }

    /**
     * Atualiza um grupo existente.
     */
    async atualizar(req, res) {
        console.log('Estou no atualizar em GrupoController');

        //1ª Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (id) {
            GrupoIdSchema.parse(id); // Lança erro automaticamente se inválido
        }

        // Validação dos dados de entrada usando Zod (estrutural)
        const parsedData = GrupoUpdateSchema.parse(req.body);

        // Chama o serviço para atualizar o grupo
        const data = await this.service.atualizar(parsedData, id);

        // Se chegou até aqui, é porque deu tudo certo, retornar 200 OK
        return CommonResponse.success(res, data);
    }

    /**
     * Deleta um grupo existente.
     */
    async deletar(req, res) {
        console.log('Estou no deletar em GrupoController');
    
        // Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (!id) {
            throw new CustomError('ID do grupo é obrigatório para deletar.', HttpStatusCodes.BAD_REQUEST);
        }
    
        // Chama o serviço para deletar o grupo
        const data = await this.service.deletar(id);
    
        // Se chegou até aqui, é porque deu tudo certo, retornar 200 OK
        return CommonResponse.success(res, data, 200, 'Grupo excluído com sucesso.');
    }
}

export default GrupoController;

===== ./controllers/ProjetoController.js =====


===== # =====


===== separador =====


===== legível =====

import Projeto from "../models/Projeto.js";
import Estudante from "../models/Estudante.js";
import { paginateOptions } from "../config/paginacao.js";
import handleQuery from "../utils/handleQuery.js";

class ProjetoController {
  static ListarProjetos = async (req, res) => {
    try {
      const query = handleQuery(req.query, { nome: "asc" });

      const projetos = await Projeto.paginate(
        { ...query.filtros },
        {
          ...paginateOptions,
          sort: query.ordenar,
          populate: { path: "estudantes" },
          page: query.pagina,
          lean: true,
        }
      );
      res.status(200).json(projetos);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };
  static ListarProjetoPorId = async (req, res) => {
    try {
      const { id } = req.params;
      const projeto = await Projeto.findById(id).populate("estudantes");
      if (!projeto) {
        throw new Error("Projeto não encontrado!");
      }
      res.status(200).json(projeto);
    } catch (error) {
      if (
        error.message === "Projeto não encontrado!" ||
        error.kind === "ObjectId"
      ) {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };
  static AdicionarProjeto = async (req, res) => {
    try {
      const projeto = req.body;

      // Verificar se os estudantes existem
      for (let i = 0; i < projeto.estudantes.length; i++) {
        const estudante = await Estudante.findById(projeto.estudantes[i]);
        if (!estudante) {
          throw new Error(
            `Estudante com id ${projeto.estudantes[i]} não encontrado!`
          );
        }
      }
      const novoProjeto = await Projeto.create(projeto)
        .then((projeto) => projeto.populate("estudantes"))
        .then((projeto) => projeto); //Fazer isso para retornar os estudantes populada;
      res.status(201).json({
        message: "Projeto adicionado com sucesso!",
        projeto: novoProjeto,
      });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };
  static AtualizarProjeto = async (req, res) => {
    try {
      const { id } = req.params;
      const projeto = req.body;
      const projetoAtualizado = await Projeto.findByIdAndUpdate(id, projeto, {
        new: true,
      })
        .then((projeto) => projeto.populate("estudantes"))
        .then((projeto) => projeto); //Fazer isso para retornar os estudantes populada;
      if (!projetoAtualizado) {
        throw new Error("Projeto não encontrado!");
      }
      res.status(200).json({
        message: "Projeto atualizado com sucesso!",
        projeto: projetoAtualizado,
      });
    } catch (error) {
      if (
        error.message === "Projeto não encontrado!" ||
        error.kind === "ObjectId"
      ) {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };
  static DeletarProjeto = async (req, res) => {
    try {
      const { id } = req.params;
      const existe = await Projeto.exists({ _id: id });
      if (!existe) {
        throw new Error("Projeto não encontrado!");
      }
      await Projeto.findByIdAndDelete(id);
      res.status(200).json({
        message: "Projeto deletado com sucesso!",
      });
    } catch (error) {
      if (
        error.message === "Projeto não encontrado!" ||
        error.kind === "ObjectId"
      ) {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };
}

export default ProjetoController;

===== ./controllers/RefeicaoController.js =====


===== # =====


===== separador =====


===== legível =====

import { isValid } from "date-fns";
import RefeicaoService from "../services/RefeicaoService.js";

class RefeicaoController{
  static Registrar = async (req, res) => {
    try {
      const { matricula } = req.body;
      const usuario = req.usuario;

      await RefeicaoService.registrar(matricula, usuario);

      const totalHoje = await RefeicaoService.totalHoje();

      res.status(201).json({error: false, message: "Refeição adicionada com sucesso!", totalHoje: totalHoje });
    } catch (error) {
      res.status(400).json({ error: true, message: error.message });
    }
  }

  static Relatorio = async (req, res) => {
    try {
      const { dataInicio, dataTermino, ...filtros } = req.query;
      /*
        Vai ter filtros de curso, turma, email(do usuario que registrou), tipoRefeicao
      */
      if(!dataInicio || !dataTermino){
        throw new Error("Data de início e data de término são obrigatórias");
      }
      
      if(!isValid(new Date(dataInicio)) || !isValid(new Date(dataTermino))){
        throw new Error("Datas inválidas!");
      }

      const relatorio = await RefeicaoService.relatorio(new Date(dataInicio), new Date(dataTermino), filtros);

      res.status(200).json(relatorio);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  }
}

export default RefeicaoController;
===== ./controllers/RefeicaoTurmaController.js =====


===== # =====


===== separador =====


===== legível =====

import RefeicaoTurma from "../models/RefeicaoTurma.js";
import Turma from "../models/Turma.js";
import { paginateOptions } from "../config//paginacao.js";
import handleQuery from "../utils/handleQuery.js";
import { addHours } from "date-fns";

class RefeicaoTurmaController {
  static ListarRefeicaoTurma = async (req, res) => {
    try {
      const query = handleQuery(req.query, { data_liberado: "desc" });
      const refeicoesTurma = await RefeicaoTurma.paginate(      
        {...query.filtros},
        {
          ...paginateOptions,
          populate: { path: "turma" },
          sort: query.ordenar,
          page: query.pagina,
          lean: true,
        }
      );
      res.status(200).json(refeicoesTurma);
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  static ListarRefeicaoTurmaPorId = async (req, res) => {
    try {
      const { id } = req.params;
      const refeicaoTurma = await RefeicaoTurma.findById(id).populate("turma");
      if (!refeicaoTurma) {
        throw new error("Id de refeiçãoTurma não encontrada!");
      }
      res.status(200).json(refeicaoTurma);
    } catch (error) {
      if (
        error.message === "Id de refeiçãoTurma não encontrada!" ||
        error.kind === "ObjectId"
      ) {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };

  static AdicionarRefeicaoTurma = async (req, res) => {
    try {
      const refeicaoTurma = req.body;

      // Verificar se a turma existe
      const turma = await Turma.findById(refeicaoTurma.turma).catch((error) => {
        throw new Error(`Turma com id ${refeicaoTurma.turma} não encontrada!`);
      });

      //Adicionar a data_liberado + 12 horas porque mexer com data é uma droga
      const novaRefeicaoTurma = await RefeicaoTurma.create({turma: refeicaoTurma.turma, data_liberado: addHours(new Date(refeicaoTurma.data_liberado), 12)})
        .then((refeicaoTurma) => refeicaoTurma.populate("turma"))
        .then((refeicaoTurma) => refeicaoTurma); //Fazer isso para retornar a turma populada;
      res.status(201).json({
        message: "Refeição por turma adicionada com sucesso!",
        refeicaoTurma: novaRefeicaoTurma,
      });
    } catch (error) {
      res.status(400).json({ message: error.message });
    }
  };

  static AtualizarRefeicaoTurma = async (req, res) => {
    try {
      const { id } = req.params;
      const refeicaoTurma = req.body;
      const refeicaoTurmaAtualizado = await RefeicaoTurma.findByIdAndUpdate(
        id,
        refeicaoTurma,
        {
          new: true,
        }
      )
        .then((refeicaoTurma) => refeicaoTurma.populate("turma"))
        .then((refeicaoTurma) => refeicaoTurma); //Fazer isso para retornar a turma populada;
      if (!refeicaoTurmaAtualizado) {
        throw new Error("Id de refeiçãoTurma não encontrada!");
      }
      res.status(200).json({
        message: "Refeição por turma atualizada com sucesso!",
        refeicaoTurma: refeicaoTurmaAtualizado,
      });
    } catch (error) {
      if (
        error.message === "Id de refeiçãoTurma não encontrada!" ||
        error.kind === "ObjectId"
      ) {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };

  static DeletarRefeicaoTurma = async (req, res) => {
    try {
      const { id } = req.params;
      const existe = await RefeicaoTurma.exists({ _id: id });
      if (!existe) {
        throw new Error("Id de refeiçãoTurma não encontrada!");
      }
      await RefeicaoTurma.findByIdAndDelete(id);
      res
        .status(200)
        .json({ message: "Refeição por turma deletada com sucesso!" });
    } catch (error) {
      if (
        error.message === "Id de refeiçãoTurma não encontrada!" ||
        error.kind === "ObjectId"
      ) {
        res.status(404).json({ message: error.message });
      } else {
        res.status(400).json({ message: error.message });
      }
    }
  };
}

export default RefeicaoTurmaController;

===== ./controllers/RotaController.js =====


===== # =====


===== separador =====


===== legível =====

// src/controllers/RotaController.js

import RotaService from '../services/RotaService.js';
import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';
import { RotaQuerySchema, RotaIdSchema } from '../utils/validators/schemas/zod/querys/RotaQuerySchema.js';
import { RotaSchema, RotaUpdateSchema } from '../utils/validators/schemas/zod/RotaSchema.js';

class RotaController {
    constructor() {
        this.service = new RotaService();
    }

    /**
     * Validação nesta aplicação segue o segue este artigo:
     * https://docs.google.com/document/d/1m2Ns1rIxpUzG5kRsgkbaQFdm7od0e7HSHfaSrrwegmM/edit?usp=sharing
     */

    /**
     * Lista grupos. Se um ID é fornecido, retorna um único objeto.
     * Caso contrário, retorna todos os objetos com suporte a filtros e paginação.
     */
    async listar(req, res) {
        console.log('Estou no listar em RotaController, enviando req para RotaService');

        //1ª Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (id) {
            RotaIdSchema.parse(id); // Lança erro automaticamente se inválido
        }

        // 2º Validação estrutural - validar os demais campos passados por query
        const query = req.query || {};
        if (Object.keys(query).length !== 0) {
            const validatedQuery = RotaQuerySchema.parse(req.query);
        }

        // Chama o serviço para listar as rotas
        const data = await this.service.listar(req);

        console.log('Estou retornando os dados em RotaController');
        return CommonResponse.success(res, data);
    }

    /**
     * Cria uma nova rota.
     */
    async criar(req, res) {
        console.log('Estou no criar em RotaController');

        // Validação dos dados de entrada usando Zod (estrutural)
        const parsedData = RotaSchema.parse(req.body);
        const data = await this.service.criar(parsedData);
        // Se chegou até aqui, é porque deu tudo certo, retornar 201 Created
        return CommonResponse.created(res, data);
    }

    /**
     *  Atualiza uma rota existente.
     */
    async atualizar(req, res) {
        console.log('Estou no atualizar em RotaController');

        // 1ª Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (id) {
            RotaIdSchema.parse(id); // Lança erro automaticamente se inválido
        }

        // 2ª Validação estrutural - validar os demais campos passados por query
        const parsedData = RotaUpdateSchema.parse(req.body);

        // Chama o serviço para atualizar a rota
        const data = await this.service.atualizar(parsedData, id);

        // Se chegou até aqui, é porque deu tudo certo, retornar 200 OK
        return CommonResponse.success(res, data);
    }

    /**
     * Método para deletar uma rota existente.
     */
    async deletar(req, res) {
        console.log('Estou no deletar em RotaController');

        // 1ª Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (id) {
            RotaIdSchema.parse(id); // Lança erro automaticamente se inválido
        }

        // Chama o serviço para deletar a rota
        const data = await this.service.deletar(req);
        return CommonResponse.success(res, data);
    }
}

export default RotaController;

===== ./controllers/TurmaController.js =====


===== # =====


===== separador =====


===== legível =====

// src/controllers/TurmaController.js

import TurmaService from '../services/TurmaService.js';
import {
  CommonResponse,
  CustomError,
  HttpStatusCodes,
  errorHandler,
  messages,
  StatusService,
  asyncWrapper
} from '../utils/helpers/index.js';

import { TurmaQuerySchema, TurmaIdSchema } from '../utils/validators/schemas/zod/querys/TurmaQuerySchema.js';
import { TurmaSchema, TurmaUpdateSchema } from '../utils/validators/schemas/zod/TurmaSchema.js';

class TurmaController {
  constructor() {
    this.service = new TurmaService();
  }

  // GET /turmas ou /turmas/:id
  async listar(req, res) {
    console.log('Estou no listar em TurmaController');

    // Validação do ID (se existir)
    const { id } = req.params || null;
    if (id) {
      TurmaIdSchema.parse(id);
    }

    // Validação das queries (se existirem)
    const query = req.query || {};
    if (Object.keys(query).length !== 0) {
      await TurmaQuerySchema.parseAsync(query);
    }

    const data = await this.service.listar(req);
    return CommonResponse.success(res, data);
  }

  // POST /turmas
  async criar(req, res) {
    try {
      // Opcional: validar o corpo da requisição com TurmaSchema.parse(req.body);
      const data = await this.service.criar(req.body);
      return CommonResponse.created(res, data, HttpStatusCodes.CREATED, 'Turma adicionada com sucesso!');
    } catch (error) {
      return CommonResponse.error(res, error);
    }
  }

  // GET /turmas/:id
  async buscarPorId(req, res) {
    try {
      const { id } = req.params;
      TurmaIdSchema.parse(id);
      const data = await this.service.buscarPorId(id);
      return CommonResponse.success(res, data, HttpStatusCodes.OK, 'Turma encontrada com sucesso.');
    } catch (error) {
      return CommonResponse.error(res, error);
    }
  }

  // PUT /turmas/:id
  async atualizar(req, res) {
    try {
      const { id } = req.params;
      // Opcional: validar o corpo da requisição com TurmaUpdateSchema.parse(req.body);
      const data = await this.service.atualizar(id, req.body);
      return CommonResponse.success(res, data, HttpStatusCodes.OK, 'Turma atualizada com sucesso.');
    } catch (error) {
      return CommonResponse.error(res, error);
    }
  }

  // DELETE /turmas/:id
  async deletar(req, res) {
    try {
      const { id } = req.params;
      const data = await this.service.deletar(id);
      return CommonResponse.success(res, data, HttpStatusCodes.OK, 'Turma deletada com sucesso.');
    } catch (error) {
      return CommonResponse.error(res, error);
    }
  }
}

export default TurmaController;

===== ./controllers/UnidadeController.js =====


===== # =====


===== separador =====


===== legível =====

// src/controllers/UnidadeController.js

import UnidadeService from '../services/UnidadeService.js';
import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';
import { UnidadeQuerySchema, UnidadeIdSchema } from '../utils/validators/schemas/zod/querys/UnidadeQuerySchema.js';
import { UnidadeSchema, UnidadeUpdateSchema } from '../utils/validators/schemas/zod/UnidadeSchema.js';

class UnidadeController {
    constructor() {
        this.service = new UnidadeService();
    }

    /**
     * Validação nesta aplicação segue o segue este artigo:
     * https://docs.google.com/document/d/1m2Ns1rIxpUzG5kRsgkbaQFdm7od0e7HSHfaSrrwegmM/edit?usp=sharing
     */

    /**
     * Lista grupos. Se um ID é fornecido, retorna um único objeto.
     * Caso contrário, retorna todos os objetos com suporte a filtros e paginação.
     */

    async listar(req, res) {
        console.log('Estou no listar em UnidadeController, enviando req para UnidadeService');

        //1ª Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (id) {
            UnidadeIdSchema.parse(id); // Lança erro automaticamente se inválido
        }

        // 2º Validação estrutural - validar os demais campos passados por query
        const query = req.query || {};
        if (Object.keys(query).length !== 0) {
            const validatedQuery = UnidadeQuerySchema.parse(req.query);
        }

        // Chama o serviço para listar as unidades
        const data = await this.service.listar(req);
        return CommonResponse.success(res, data);
    }

    /**
     * Criar uma nova unidade.
     */
    async criar(req, res) {
        console.log('Estou no criar em UnidadeController');

        // Validação dos dados de entrada usando Zod (estrutural)
        const parsedData = UnidadeSchema.parse(req.body);

        // Chama o serviço para criar a unidade
        const data = await this.service.criar(req);

        // Se chegou até aqui, é porque deu tudo certo, retornar 201 Created
        return CommonResponse.created(res, data);

    }

    /**
     * Atualiza uma unidade existente.
     */
    async atualizar(req, res) {
        console.log('Estou no atualizar em UnidadeController');

        //1ª Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (id) {
            UnidadeIdSchema.parse(id); // Lança erro automaticamente se inválido
        }

        // Validação dos dados de entrada usando Zod (estrutural)
        const parsedData = UnidadeUpdateSchema.parse(req.body);

        // Chama o serviço para atualizar a unidade
        const data = await this.service.atualizar(req);

        // Se chegou até aqui, é porque deu tudo certo, retornar 200 OK
        return CommonResponse.success(res, data);
    }

    async deletar(req, res) {
        console.log('Estou no deletar em UnidadeController');

        // Validação estrutural - validação do ID passado por parâmetro
        const { id } = req.params || null;
        if (!id) {
            throw new CustomError('ID da unidade é obrigatório para deletar.', HttpStatusCodes.BAD_REQUEST);
        }

        // Chama o serviço para deletar a unidade
        const data = await this.service.deletar(id);

        // Se chegou até aqui, é porque deu tudo certo, retornar 200 OK
        return CommonResponse.success(res, data, 200, 'Unidade deletada com sucesso');
    }
}

export default UnidadeController;

===== ./controllers/UsuarioController.js =====


===== # =====


===== separador =====


===== legível =====

// src/controllers/UsuarioController.js

import UsuarioService from '../services/UsuarioService.js';
import { UsuarioQuerySchema, UsuarioIdSchema } from '../utils/validators/schemas/zod/querys/UsuarioQuerySchema.js';
import { UsuarioSchema, UsuarioUpdateSchema } from '../utils/validators/schemas/zod/UsuarioSchema.js';
import {
    CommonResponse,
    CustomError,
    HttpStatusCodes,
    errorHandler,
    messages,
    StatusService,
    asyncWrapper
} from '../utils/helpers/index.js';

// Importações necessárias para o upload de arquivos
import fileUpload from 'express-fileupload';
import path from 'path';
import { fileURLToPath } from 'url';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';
import sharp from 'sharp';

// Helper para __dirname em módulo ES
const getDirname = () => path.dirname(fileURLToPath(import.meta.url));

class UsuarioController {
    constructor() {
        this.service = new UsuarioService();
    }

    /**
     * Lista usuários. Se um ID é fornecido, retorna um único objeto.
     * Caso contrário, retorna todos os objetos com suporte a filtros e paginação.
     */
    async listar(req, res) {
        console.log('Estou no listar em UsuarioController');

        // Validação do ID (se existir)
        const { id } = req.params || {};
        if (id) {
            UsuarioIdSchema.parse(id);
        }

        // Validação das queries (se existirem)
        const query = req.query || {};
        if (Object.keys(query).length !== 0) {
            // deve apenas validar o objeto query, tendo erro o zod será responsável por lançar o erro
            await UsuarioQuerySchema.parseAsync(query);
        }

        const data = await this.service.listar(req);
        return CommonResponse.success(res, data);
    }

    /**
     * Cria um novo usuário.
     */
    async criar(req, res) {
        console.log('Estou no criar em UsuarioController');

        // Cria o DTO de criação e valida os dados
        const parsedData = UsuarioSchema.parse(req.body);
        let data = await this.service.criar(req);

        // Converte o documento Mongoose para um objeto simples
        let usuarioLimpo = data.toObject();

        // Remove campos indesejados, como a senha e outros que não devem ser expostos
        delete usuarioLimpo.senha;

        return CommonResponse.created(res, usuarioLimpo);
    }


    /**
     * Atualiza um usuário existente.
     */
    async atualizar(req, res) {
        console.log('Estou no atualizar em UsuarioController');

        // >> CORREÇÃO PRINCIPAL: destruturar o ID corretamente <<
        const { id } = req.params;
        UsuarioIdSchema.parse(id);

        const parsedData = UsuarioUpdateSchema.parse(req.body);
       
        const data = await this.service.atualizar(id, parsedData);

        // Converte o documento Mongoose para um objeto simples
        let usuarioLimpo = data.toObject();

        // Remove campos indesejados, como a senha e outros que não devem ser expostos
        delete usuarioLimpo.senha;

        return CommonResponse.success(res, data, 200, 'Usuário atualizado com sucesso. Porém, o e-mail é ignorado em tentativas de atualização, pois é opração proibida. IDs de Unidades e Grupos não cadastradas são ignoradas.');
    }

    /**
     * Deleta um usuário existente.
     */
    async deletar(req, res) {
        console.log('Estou no deletar em UsuarioController');

        const { id } = req.params || {};
        if (!id) {
            throw new CustomError({
                statusCode: HttpStatusCodes.BAD_REQUEST.code,
                errorType: 'validationError',
                field: 'id',
                details: [],
                customMessage: 'ID do usuário é obrigatório para deletar.'
            });
        }

        const data = await this.service.deletar(id);
        return CommonResponse.success(res, data, 200, 'Usuário excluído com sucesso.');
    }

    /**
     * Faz upload de uma foto para um usuário.
     */
    async fotoUpload(req, res, next) {
        try {
            console.log('Estou no fotoUpload em UsuarioController');

            const { id } = req.params || {};
            UsuarioIdSchema.parse(id);

            // Verificar se o arquivo foi enviado
            const file = req.files?.file;
            if (!file) {
                throw new CustomError({
                    statusCode: HttpStatusCodes.BAD_REQUEST.code,
                    errorType: 'validationError',
                    field: 'file',
                    details: [],
                    customMessage: 'Nenhum arquivo foi enviado.'
                });
            }

            // Validar extensão do arquivo
            const extensaoArquivo = path.extname(file.name).slice(1).toLowerCase();
            const extensoesValidas = ["jpg", "jpeg", "png", "svg"];
            if (!extensoesValidas.includes(extensaoArquivo)) {
                throw new CustomError({
                    statusCode: HttpStatusCodes.BAD_REQUEST.code,
                    errorType: 'validationError',
                    field: 'file',
                    details: [],
                    customMessage: 'Extensão de arquivo inválida. Permitido: jpg, jpeg, png, svg.'
                });
            }

            // Preparar o nome do arquivo
            const fileName = uuidv4() + '.' + extensaoArquivo;
            const uploadsDir = path.join(getDirname(), '..', '../uploads');
            const uploadPath = path.join(uploadsDir, fileName);

            // Cria a pasta de uploads se não existir
            if (!fs.existsSync(uploadsDir)) {
                fs.mkdirSync(uploadsDir, { recursive: true });
            }

            // Redimensiona a imagem para 400x400 (corte centralizado)
            const imageBuffer = await sharp(file.data)
                .resize(400, 400, {
                    fit: sharp.fit.cover,
                    position: sharp.strategy.entropy
                })
                .toBuffer();

            // Salva a imagem redimensionada
            await fs.promises.writeFile(uploadPath, imageBuffer);

            // Atualiza o link_foto no usuário
            const dados = { link_foto: fileName };
            UsuarioUpdateSchema.parse(dados);

            const updatedUser = await this.service.atualizar(id, dados);

            return CommonResponse.success(res, {
                message: 'Arquivo recebido e usuário atualizado com sucesso.',
                dados: { link_foto: fileName },
                metadados: {
                    fileName,
                    fileExtension: extensaoArquivo,
                    fileSize: file.size,
                    md5: file.md5
                }
            });
        } catch (error) {
            console.error('Erro no fotoUpload:', error);
            return next(error);
        }
    }

    /**
     * Faz download da foto de um usuário.
     */
    async getFoto(req, res, next) {
        try {
            console.log('Estou no getFoto em UsuarioController');

            const { id } = req.params || {};
            UsuarioIdSchema.parse(id);

            const usuario = await this.service.listar(req);
            const { link_foto } = usuario;

            if (!link_foto) {
                throw new CustomError({
                    statusCode: HttpStatusCodes.NOT_FOUND.code,
                    errorType: 'notFound',
                    field: 'link_foto',
                    details: [],
                    customMessage: 'Foto do usuário não encontrada.'
                });
            }

            const filename = link_foto;
            const uploadsDir = path.join(getDirname(), '..', '../uploads');
            const filePath = path.join(uploadsDir, filename);

            const extensao = path.extname(filename).slice(1).toLowerCase();
            const mimeTypes = {
                jpg: 'image/jpeg',
                jpeg: 'image/jpeg',
                png: 'image/png',
                svg: 'image/svg+xml'
            };
            const contentType = mimeTypes[extensao] || 'application/octet-stream';

            res.setHeader('Content-Type', contentType);
            return res.sendFile(filePath);
        } catch (error) {
            console.error('Erro no getFoto:', error);
            return next(error);
        }
    }
}

export default UsuarioController;

===== ./docs/config/head.js =====


===== # =====


===== separador =====


===== legível =====

import authPaths from "../routes/auth.js";
import usuariosPaths from "../routes/usuarios.js";
import authSchemas from "../schemas/authSchema.js";
import usuariosSchemas from "../schemas/usuariosSchema.js";
import gruposPaths from "../routes/grupos.js";
import gruposSchemas from "../schemas/gruposSchema.js";
import unidadesPaths from "../routes/unidades.js";
import unidadesSchemas from "../schemas/unidadesSchema.js";
import rotasPaths from "../routes/rotas.js";
import rotasSchemas from "../schemas/rotasSchema.js";
import cursoPaths from "../routes/cursos.js";
import cursosSchemas from "../schemas/cursosSchema.js";
import estudantesPaths from "../routes/estudantes.js";
import estudantesSchemas from "../schemas/estudantesSchema.js";
import turmasPaths from "../routes/turmas.js";
import turmasSchemas from "../schemas/turmasSchema.js";
import estagiosPaths from "../routes/estagios.js";
import estagiosSchemas from "../schemas/estagiosSchema.js";
import projetosPaths from "../routes/projetos.js";
import projetosSchemas from "../schemas/projetosSchema.js";
import refeicoesPaths from "../routes/refeicoes.js";
import refeicoesSchemas from "../schemas/refeicoesSchema.js";
import refeicoesTurmasPaths from "../routes/refeicoesTurmas.js";
import refeicoesTurmasSchemas from "../schemas/refeicoesTurmasSchema.js";

// Função para definir as URLs do servidor dependendo do ambiente
const getServersInCorrectOrder = () => {
    const devUrl = { url: process.env.SWAGGER_DEV_URL || "http://localhost:5011" };
    const prodUrl1 = { url: process.env.SWAGGER_PROD_URL || "https://edurondon.tplinkdns.com/event" };

    if (process.env.NODE_ENV === "production") return [prodUrl1, devUrl];
    else return [devUrl, prodUrl1];
};

// Função para obter as opções do Swagger
const getSwaggerOptions = () => {
    return {
        swaggerDefinition: {
            openapi: "3.0.0",
            info: {
                title: "API EVENT AUTH",
                version: "1.0-alpha",
                description: "API AUTH \n\nÉ necessário autenticar com token JWT antes de utilizar a maioria das rotas, faça isso na rota /login com um email e senha válido. Esta API conta com refresh token, que pode ser obtido na rota /token, e com logout, que pode ser feito na rota /logout. Para revogação de acesso de terceiros um perfil de administrador pode usar a rota /token/revoke Para mais informações, acesse a documentação.",
                contact: {
                    name: "Gilberto Silva",
                    email: "gilberto.silva@ifro.edu.br",
                },
            },
            servers: getServersInCorrectOrder(),
            tags: [
                {
                    name: "Auth",
                    description: "Rotas para autenticação e autorização"
                },
                {
                    name: "Usuários",
                    description: "Rotas para gestão de usuários"
                },
                {
                    name: "Grupos",
                    description: "Rotas para gestão de grupos"
                },
                {
                    name: "Rotas",
                    description: "Rotas para gestão de rotas disponíveis nesta API"
                },
                {
                    name: "Unidades",
                    description: "Rotas para gestão de unidades"
                },
                /**
                 * Rotas do sistema de referição
                 */
                {
                    name: "Estudantes",
                    description: "Rotas para gestão de estudantes"
                },
                {
                    name: "Cursos",
                    description: "Rotas para gestão de cursos"
                },
                {
                    name: "Turmas",
                    description: "Rotas para gestão de turmas"
                },
                {
                    name: "Estágios",
                    description: "Rotas para gestão de estágios"
                },
                {
                    name: "Projetos",
                    description: "Rotas para gestão de projetos"
                },
                {
                    name: "Refeições",
                    description: "Rotas para gestão de refeições"
                },
                {
                    name: "RefeiçõesTurmas",
                    description: "Rotas para gestão de refeições por turmas"
                },
            ],
            paths: {
                ...authPaths,
                ...usuariosPaths,
                ...gruposPaths,
                ...unidadesPaths,
                ...rotasPaths,
                /**
                 * Rotas do sistema de referição
                 */
                ...cursoPaths,
                ...estudantesPaths,
                ...turmasPaths,
                ...estagiosPaths,
                ...projetosPaths,
                ...refeicoesPaths,
                ...refeicoesTurmasPaths,

            },
            components: {
                securitySchemes: {
                    bearerAuth: {
                        type: "http",
                        scheme: "bearer",
                        bearerFormat: "JWT"
                    }
                },
                schemas: {
                    ...authSchemas,
                    ...usuariosSchemas,
                    ...gruposSchemas,
                    ...unidadesSchemas,
                    ...rotasSchemas,

                    /**
                     * Schemas do sistema de referição
                     */
                    ...cursosSchemas,
                    ...estudantesSchemas,
                    ...turmasSchemas,
                    ...estagiosSchemas,
                    ...projetosSchemas,
                    ...refeicoesSchemas,
                    ...refeicoesTurmasSchemas,

                }
            },
            security: [{
                bearerAuth: []
            }]
        },
        apis: ["./src/routes/*.js"]
    };
};

export default getSwaggerOptions;

===== ./docs/routes/auth.js =====


===== # =====


===== separador =====


===== legível =====

import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import usuariosSchemas from "../schemas/usuariosSchema.js";

const authRoutes = {
    "/login": {
        post: {
            tags: ["Auth"],
            summary: "Realiza login",
            description: "Rota para realizar login no sistema, usando o email e senha do usuário.",
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            "$ref": "#/components/schemas/loginPost"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/UsuarioRespostaLogin"),
                400: commonResponses[400](),
                422: commonResponses[422](),
            }
        }
    },
    "/recuperasenha": {
        post: {
            tags: ["Auth"],
            summary: "Solicita recuperação de senha",
            description: "Rota para solicitar recuperação de senha, enviando um email para o usuário.",
            requestBody: {
                required: true,
                content: {
                    "application/json": {
                        schema: { "$ref": "#/components/schemas/RequisicaoRecuperaSenha" }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/RespostaRecuperaSenha"),
                400: commonResponses[400](),
                404: commonResponses[404](),
                500: commonResponses[500]()
            }
        }
    },
    "/logout": {
        post: {
            tags: ["Auth"],
            summary: "Realiza logout",
            description: "Rota para realizar logout do sistema, usando o token de autenticação, access token. Após a execução, o token não será mais válido. Sendo o usuário obrigado a fazer login novamentem, usando o email e senha do usuário em /login",
            requestBody: {
                required: true,
                content: {
                    "application/json": {
                        schema: {
                            type: "object",
                            properties: {
                                token: { type: "string", example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0YTYzMjIwOTg4NWQ4ZTgzNzhlZTU5MCIsIm5vbWUiOiJKb8OjbyBkYSBTaWx2YSIsImVtYWlsIjoiam9hb0BlbWFpbC5jb20iLCJpYXQiOjE2ODg3NzQwMjMsImV4cCI6MTY4ODc4MTIyM30.iZvQN6NiGQ9GE1W2UpdUTv5YbDHH8ULsOyLtEockkqc" }
                            },
                            required: ["token"]
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/pass": {
        post: {
            tags: ["Auth"],
            summary: "Realiza verificação de token, quando os cliente quiserem saber se o token é válido",
            description: "Rota para verificar se o token é válido, usando o token de autenticação, access token. Após a execução, o token não será mais válido. Sendo o usuário obrigado a fazer login novamente, usando o email e senha do usuário em /login",
            requestBody: {
                required: true,
                content: {
                    "application/json": {
                        schema: {
                            type: "object",
                            properties: {
                                token: { type: "string", example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0YTYzMjIwOTg4NWQ4ZTgzNzhlZTU5MCIsIm5vbWUiOiJKb8OjbyBkYSBTaWx2YSIsImVtYWlsIjoiam9hb0BlbWFpbC5jb20iLCJpYXQiOjE2ODg3NzQwMjMsImV4cCI6MTY4ODc4MTIyM30.iZvQN6NiGQ9GE1W2UpdUTv5YbDHH8ULsOyLtEockkqc" }
                            },
                            required: ["token"]
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/RespostaPass"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/token": {
        post: {
            tags: ["Auth"],
            summary: "Rota para renovar o refresh token do usuário",
            description: "Rota para renovar o refresh token do usuário, usando o refresh token do usuário.",
            requestBody: {
                required: true,
                content: {
                    "application/json": {
                        schema: {
                            type: "object",
                            properties: {
                                token: { type: "string", example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0YTYzMjIwOTg4NWQ4ZTgzNzhlZTU5MCIsIm5vbWUiOiJKb8OjbyBkYSBTaWx2YSIsImVtYWlsIjoiam9hb0BlbWFpbC5jb20iLCJpYXQiOjE2ODg3NzQwMjMsImV4cCI6MTY4ODc4MTIyM30.iZvQN6NiGQ9GE1W2UpdUTv5YbDHH8ULsOyLtEockkqc" }
                            },
                            required: ["token"]
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/RespostaLogin"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/token/revoke": {
        post: {
            tags: ["Auth"],
            summary: "Revoga token",
            description: "Rota para revogar o refresh token do usuário, usando o refresh token do usuário.",
            requestBody: {
                required: true,
                content: {
                    "application/json": {
                        schema: {
                            type: "object",
                            properties: {
                                id: { type: "string", example: "674fa21d79969d2172e78710" },
                            },
                            required: ["id"]
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default authRoutes;

===== ./docs/routes/cursos.js =====


===== # =====


===== separador =====


===== legível =====

import cursosSchemas from "../schemas/cursosSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const cursosRoutes = {
    "/cursos": {
        get: {
            tags: ["Cursos"],
            summary: "Lista todos os cursos",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(cursosSchemas.CursoFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/CursoListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Cursos"],
            summary: "Cria um novo curso",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/CursoPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/CursoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/cursos/{id}": {
        get: {
            tags: ["Cursos"],
            summary: "Obtém detalhes de um curso",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/CursoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Cursos"],
            summary: "Atualiza um curso",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: { type: "integer" }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/CursoPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/CursoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Cursos"],
            summary: "Deleta um curso",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default cursosRoutes;

===== ./docs/routes/estagios.js =====


===== # =====


===== separador =====


===== legível =====

import estagiosSchemas from "../schemas/estagiosSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const estagiosRoutes = {
    "/estagios": {
        get: {
            tags: ["Estágios"],
            summary: "Lista todos os estagios",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(estagiosSchemas.EstagioFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/EstagioListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Estágios"],
            summary: "Cria um novo estagio",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/EstagioPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/EstagioDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/estagios/{id}": {
        get: {
            tags: ["Estágios"],
            summary: "Obtém detalhes de um estagio",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/EstagioDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Estágios"],
            summary: "Atualiza um estagio",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: { type: "integer" }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/EstagioPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/EstagioDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Estágios"],
            summary: "Deleta um estagio",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default estagiosRoutes;

===== ./docs/routes/estudantes.js =====


===== # =====


===== separador =====


===== legível =====

import estudantesSchemas from "../schemas/estudantesSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const estudantesRoutes = {
    "/estudantes": {
        get: {
            tags: ["Estudantes"],
            summary: "Lista todos os estudantes",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(estudantesSchemas.EstudanteFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/EstudanteListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Estudantes"],
            summary: "Cria um novo estudante",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/EstudantePost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/EstudanteDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/estudantes/{id}": {
        get: {
            tags: ["Estudantes"],
            summary: "Obtém detalhes de um estudante",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/EstudanteDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Estudantes"],
            summary: "Atualiza um estudante",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: { type: "integer" }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/EstudantePutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/EstudanteDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Estudantes"],
            summary: "Deleta um estudante",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default estudantesRoutes;

===== ./docs/routes/grupos.js =====


===== # =====


===== separador =====


===== legível =====

import grupoSchemas from "../schemas/gruposSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const gruposRoutes = {
    "/grupos": {
        get: {
            tags: ["Grupos"],
            summary: "Lista todos os grupos",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(grupoSchemas.GrupoFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/GrupoListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Grupos"],
            summary: "Cria um novo grupo",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/GrupoPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/GrupoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/grupos/{id}": { // endpoint ajustado para manter o padrão plural
        get: {
            tags: ["Grupos"],
            summary: "Obtém detalhes de um grupo",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/GrupoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        patch: {
            tags: ["Grupos"],
            summary: "Atualiza um grupo",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/GrupoPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/GrupoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Grupos"],
            summary: "Atualiza um grupo",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/GrupoPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/GrupoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Grupos"],
            summary: "Deleta um grupo",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default gruposRoutes;

===== ./docs/routes/projetos.js =====


===== # =====


===== separador =====


===== legível =====

import projetosSchemas from "../schemas/projetosSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const projetosRoutes = {
    "/projetos": {
        get: {
            tags: ["Projetos"],
            summary: "Lista todos os projetos",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(projetosSchemas.ProjetoFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/ProjetoListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Projetos"],
            summary: "Cria um novo projeto",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/ProjetoPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/ProjetoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/projetos/{id}": {
        get: {
            tags: ["Projetos"],
            summary: "Obtém detalhes de um projeto",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/ProjetoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Projetos"],
            summary: "Atualiza um projeto",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: { type: "integer" }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/ProjetoPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/ProjetoDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Projetos"],
            summary: "Deleta um projeto",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default projetosRoutes;

===== ./docs/routes/refeicoes.js =====


===== # =====


===== separador =====


===== legível =====

import refeicoesSchemas from "../schemas/refeicoesSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const refeicoesRoutes = {
    "/refeicoes": {
        get: {
            tags: ["Refeições"],
            summary: "Lista todos os refeicoes",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(refeicoesSchemas.RefeicoesFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/RefeicoesListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Refeições"],
            summary: "Cria um novo refeicoes",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/RefeicoesPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/RefeicoesDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/refeicoes/{id}": {
        get: {
            tags: ["Refeições"],
            summary: "Obtém detalhes de um refeicoes",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/RefeicoesDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Refeições"],
            summary: "Atualiza um refeicoes",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: { type: "integer" }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/RefeicoesPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/RefeicoesDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Refeições"],
            summary: "Deleta um refeicoes",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default refeicoesRoutes;

===== ./docs/routes/refeicoesTurmas.js =====


===== # =====


===== separador =====


===== legível =====

import refeicoesTurmaSchemas from "../schemas/refeicoesTurmasSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const refeicoesTurmaRoutes = {
    "/refeicoesTurma": {
        get: {
            tags: ["RefeiçõesTurmas"],
            summary: "Lista todos os refeicoesTurma",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(refeicoesTurmaSchemas.RefeicoesTurmaFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/RefeicoesTurmaListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["RefeiçõesTurmas"],
            summary: "Cria um novo curso",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/RefeicoesTurmaPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/RefeicoesTurmaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/refeicoesTurma/{id}": {
        get: {
            tags: ["RefeiçõesTurmas"],
            summary: "Obtém detalhes de um curso",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/RefeicoesTurmaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["RefeiçõesTurmas"],
            summary: "Atualiza um curso",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: { type: "integer" }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/RefeicoesTurmaPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/RefeicoesTurmaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["RefeiçõesTurmas"],
            summary: "Deleta um curso",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default refeicoesTurmaRoutes;

===== ./docs/routes/rotas.js =====


===== # =====


===== separador =====


===== legível =====

import rotaSchemas from "../schemas/rotasSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const rotasRoutes = {
    "/rotas": {
        get: {
            tags: ["Rotas"],
            summary: "Lista todas as rotas",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(rotaSchemas.RotaFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/RotaListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Rotas"],
            summary: "Cria uma nova rota",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/RotaPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/RotaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/rotas/{id}": { // endpoint ajustado para manter o padrão plural
        get: {
            tags: ["Rotas"],
            summary: "Obtém detalhes de uma rota",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/RotaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        patch: {
            tags: ["Rotas"],
            summary: "Atualiza uma rota",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/RotaPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/RotaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Rotas"],
            summary: "Atualiza uma rota",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/RotaPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/RotaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Rotas"],
            summary: "Deleta uma rota",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default rotasRoutes;

===== ./docs/routes/turmas.js =====


===== # =====


===== separador =====


===== legível =====

import turmasSchemas from "../schemas/turmasSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const turmasRoutes = {
    "/turmas": {
        get: {
            tags: ["Turmas"],
            summary: "Lista todos os turmas",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(turmasSchemas.TurmaFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/RefeicoesTurmaListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Turmas"],
            summary: "Cria um novo turma",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/TurmaPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/TurmaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/turmas/{id}": {
        get: {
            tags: ["Turmas"],
            summary: "Obtém detalhes de um turma",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/TurmaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Turmas"],
            summary: "Atualiza um turma",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: { type: "integer" }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/TurmaPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/TurmaDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Turmas"],
            summary: "Deleta um turma",
            description: "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default turmasRoutes;
===== ./docs/routes/unidades.js =====


===== # =====


===== separador =====


===== legível =====

import unidadeSchemas from "../schemas/unidadesSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const unidadesRoutes = {
    "/unidades": {
        get: {
            tags: ["Unidades"],
            summary: "Lista todas as unidades",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            // Gerando os parâmetros a partir do JSON Schema recursivamente
            parameters: generateParameters(unidadeSchemas.UnidadeFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/UnidadeListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Unidades"],
            summary: "Cria uma nova unidade",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/UnidadePost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/UnidadeDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/unidades/{id}": {
        get: {
            tags: ["Unidades"],
            summary: "Obtém detalhes de uma unidade",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/UnidadeDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        patch: {
            tags: ["Unidades"],
            summary: "Atualiza uma unidade",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/UnidadePutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/UnidadeDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Unidades"],
            summary: "Atualiza uma unidade",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/UnidadePutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/UnidadeDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Unidades"],
            summary: "Deleta uma unidade",
            description:
                "Coloque aqui uma descrição mais detalhada do que esse endpoint faz, regras de negócio, permissões, etc.",
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default unidadesRoutes;

===== ./docs/routes/usuarios.js =====


===== # =====


===== separador =====


===== legível =====

import usuariosSchemas from "../schemas/usuariosSchema.js";
import authSchemas from "../schemas/authSchema.js";
import commonResponses from "../schemas/swaggerCommonResponses.js";
import { generateParameters } from "./utils/generateParameters.js"; // ajuste o caminho conforme necessário

const usuariosRoutes = {
    "/usuarios": {
        get: {
            tags: ["Usuários"],
            summary: "Lista todos os usuários",
            description: `
Este endpoint permite listar todos os usuários cadastrados no sistema. 
Utilize filtros (como nome, status, data, grupo e localidade) e paginação para refinar a consulta e evitar sobrecarga na resposta.
\n**Regras de negócio:**
- Validação dos filtros informados.
- Respeito às permissões do usuário autenticado.
- Retorno dos metadados de paginação, como total de páginas e total de registros.
            `,
            security: [{ bearerAuth: [] }],
            parameters: generateParameters(usuariosSchemas.UsuarioFiltro),
            responses: {
                200: commonResponses[200]("#/components/schemas/UsuarioListagem"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        post: {
            tags: ["Usuários"],
            summary: "Cria um novo usuário",
            description: `
Este endpoint cria um novo usuário no sistema.
**Regras de negócio:**
- Validação dos atributos obrigatórios (por exemplo, e-mail, nome e código interno).
- Verificação de exclusividade para campos únicos (como o e-mail).
- Definição do status inicial (ex.: ativo ou pendente) conforme o fluxo de cadastro.
Em caso de duplicidade ou erro na validação, um erro adequado é retornado.
            `,
            security: [{ bearerAuth: [] }],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/UsuarioPost"
                        }
                    }
                }
            },
            responses: {
                201: commonResponses[201]("#/components/schemas/UsuarioDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    },
    "/usuarios/{id}": {
        get: {
            tags: ["Usuários"],
            summary: "Obtém detalhes de um usuário",
            description: `
Este endpoint retorna os detalhes completos de um usuário específico.
**Regras de negócio:**
- Validação da existência do usuário e do seu status (ativo/inativo).
- Inclusão opcional de dados relacionados, como estatísticas ou vínculos com outros registros.
- Controle de acesso para assegurar que apenas usuários autorizados possam visualizar dados sensíveis.
            `,
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200]("#/components/schemas/UsuarioDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        patch: {
            tags: ["Usuários"],
            summary: "Atualiza um usuário (PATCH)",
            description: `
Este endpoint atualiza parcialmente os dados de um usuário.
**Regras de negócio:**
- Garantia da unicidade de campos, como o e-mail.
- Ações imediatas em alterações críticas, como a inativação do usuário, limitando seu acesso.
- Validação para impedir alterações que violem regras estabelecidas após a criação.
            `,
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/UsuarioPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/UsuarioDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        put: {
            tags: ["Usuários"],
            summary: "Atualiza um usuário (PUT)",
            description: `
Este endpoint substitui os dados de um usuário por novos valores.
**Regras de negócio:**
- Manutenção da unicidade dos campos críticos.
- Validação completa do objeto de usuário, garantindo que todas as informações necessárias estejam presentes.
- Aplicação imediata de alterações críticas, como a alteração de status.
            `,
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: { type: "integer" }
                }
            ],
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            $ref: "#/components/schemas/UsuarioPutPatch"
                        }
                    }
                }
            },
            responses: {
                200: commonResponses[200]("#/components/schemas/UsuarioDetalhes"),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        },
        delete: {
            tags: ["Usuários"],
            summary: "Deleta um usuário",
            description: `
Este endpoint remove ou inativa um usuário do sistema.
**Regras de negócio:**
- Verificação de impedimentos, como regras de compliance ou auditoria, para decidir se o registro deve ser excluído ou apenas inativado.
- Registro de logs ou notificação de sistemas de auditoria para manter o histórico de alterações.
- Garantia de que a exclusão não afete vínculos críticos com outros registros.
            `,
            security: [{ bearerAuth: [] }],
            parameters: [
                {
                    name: "id",
                    in: "path",
                    required: true,
                    schema: {
                        type: "integer"
                    }
                }
            ],
            responses: {
                200: commonResponses[200](),
                400: commonResponses[400](),
                401: commonResponses[401](),
                404: commonResponses[404](),
                498: commonResponses[498](),
                500: commonResponses[500]()
            }
        }
    }
};

export default usuariosRoutes;

===== ./docs/routes/utils/generateParameters.js =====


===== # =====


===== separador =====


===== legível =====

// /src/docs/routes/utils/routeGenerateparameters.js 
 
export function generateParameters(schema, baseRef = '#/components/schemas/UsuarioFiltro', parentKey = '') {
  const params = [];
  const properties = schema.properties || {};

  for (const [key, value] of Object.entries(properties)) {
    // Se value estiver indefinido, pula para o próximo
    if (!value) continue;

    const paramName = parentKey ? `${parentKey}.${key}` : key;

    if (value.type === 'object' && value.properties) {
      params.push(...generateParameters(value, baseRef, paramName));
    } else {
      params.push({
        name: paramName,
        in: 'query',
        required: false,
        schema: {
          $ref: `${baseRef}/properties/${paramName}`
        },
        description: `Filtro por ${paramName}`
      });
    }
  }
  return params;
}

===== ./docs/schemas.bkp/authSchema.js =====


===== # =====


===== separador =====


===== legível =====

const authSchemas = {

    // Request Schemas
    RespostaLogin: {
        type: "object",
        properties: {
            token: {
                type: "string",
                description: "Token JWT para autenticação",
                example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0YTYzMjIwOTg4NWQ4ZTgzNzhlZTU5MCIsIm5vbWUiOiJKb8OjbyBkYSBTaWx2YSIsImVtYWlsIjoiam9hb0BlbWFpbC5jb20iLCJpYXQiOjE2ODg3NzQwMjMsImV4cCI6MTY4ODc4MTIyM30.iZvQN6NiGQ9GE1W2UpdUTv5YbDHH8ULsOyLtEockkqc"
            },
            usuario: {
                $ref: "#/components/schemas/UsuarioDetalhes"
            }
        }
    },
    RespostaRecuperaSenha: {
        type: "object",
        properties: {
            message: {
                type: "string",
                description: "Mensagem indicando o status da solicitação de recuperação de senha",
                example: "Um email de recuperação de senha foi enviado para seu endereço de email."
            }
        },
    },
    RequisicaoRecuperaSenha: {
        type: "object",
        properties: {
            email: {
                type: "string",
                format: "email",
                description: "Endereço de email do usuário para recuperação de senha",
                example: "usuario@exemplo.com"
            }
        },
        required: ["email"]
    },
    loginPost: {
        type: "object",
        required: ["email", "senha"],
        properties: {
            email: {
                type: "string",
                description: "Email do usuário",
                example: "usuario@example.com",
            },
            senha: {
                type: "string",
                description: "Senha do usuário",
                example: "123456",
            },
        },
    },

};

export default authSchemas;

===== ./docs/schemas.bkp/gruposSchema.js =====


===== # =====


===== separador =====


===== legível =====

const gruposSchemas = {
    GrupoFiltro: {
        type: "object",
        properties: {
            nome: {
                type: "string",
                description: "Nome do grupo"
            },
            decricao: {
                type: "string",
                description: "Descrição do grupo"
            },
            ativo: {
                type: "boolean",
                description: "Ativo"
            },
            unidades: {
                type: "string",
                description: "Nome da Unidade"
            }
        }
    },
    GrupoListagem: {
        type: "object",
        properties: {
            id: { type: "integer", description: "ID do grupo" },
            nome: { type: "string", description: "Nome do grupo" },
            descricao: { type: "string", description: "Descrição do grupo" },

        },
        example: {
            id: 1,
            nome: "Desenvolvedores",
            descricao: "Grupo de desenvolvimento",
        }
    },
    GrupoDetalhes: {
        type: "object",
        properties: {
            id: { type: "integer", description: "ID do grupo" },
            nome: { type: "string", description: "Nome do grupo" },
            descricao: { type: "string", description: "Descrição do grupo" },
        },
        example: {
            id: 1,
            nome: "Desenvolvedores",
            descricao: "Grupo de desenvolvimento",
        }
    },
    GrupoPost: {
        type: "object",
        required: ["nome", "description"], // Define quais campos são obrigatórios
        properties: {
            nome: { type: "string", description: "Nome do grupo" },
            descricao: { type: "string", description: "Descrição do grupo" },
        },
        example: {
            nome: "Desenvolvedores",
            descricao: "Grupo de desenvolvimento",
        }
    },
    GrupoPostResposta: {
        type: "object",
        properties: {
            nome: { type: "string", description: "Nome do grupo" },
            descricao: { type: "string", description: "Descrição do grupo" },
        },
        example: {
            id: 1,
            nome: "Desenvolvedores",
            descricao: "Grupo de desenvolvimento",
        }
    },
    GrupoPutPatch: {
        type: "object",
        properties: {
            nome: { type: "string", description: "Nome do grupo" },
            descricao: { type: "string", description: "Descrição do grupo" },
        },
        example: {
            nome: "Desenvolvedores",
            descricao: "Grupo de desenvolvimento",
        }
    },
};

export default gruposSchemas;

===== ./docs/schemas.bkp/rotasSchema.js =====


===== # =====


===== separador =====


===== legível =====

const rotasSchemas = {
    RotaFiltro: {
        type: "object",
        properties: {
            rota: {
                type: "string",
                description: "Nome da rota"
            },
            decricao: {
                type: "string",
                description: "Descrição da rota"
            },
            ativo: {
                type: "boolean",
                description: "Ativo"
            },
        }
    },
    RotaListagem: {
        type: "object",
        properties: {
            id: { type: "integer", description: "ID da rota" },
            rota: { type: "string", description: "Nome da rota" },
            dominio: { type: "string", description: "Domínio da rota" },
            ativo: { type: "boolean", description: "Rota ativa" },
            buscar: { type: "boolean", description: "Permite GET" },
            enviar: { type: "boolean", description: "Permite POST" },
            substituir: { type: "boolean", description: "Permite PUT" },
            modificar: { type: "boolean", description: "Permite PATCH" },
            excluir: { type: "boolean", description: "Permite DELETE" },
        },
        example: {
            id: 1,
            rota: "/usuarios",
            dominio: "http://localhost:3000",
            ativo: true,
            buscar: true,
            enviar: true,
            substituir: true,
            modificar: true,
            excluir: true,
        }
    },
    RotaDetalhes: {
        type: "object",
        properties: {
            id: { type: "integer", description: "ID da rota" },
            rota: { type: "string", description: "Nome da rota" },
            dominio: { type: "string", description: "Domínio da rota" },
            ativo: { type: "boolean", description: "Rota ativa" },
            buscar: { type: "boolean", description: "Permite GET" },
            enviar: { type: "boolean", description: "Permite POST" },
            substituir: { type: "boolean", description: "Permite PUT" },
            modificar: { type: "boolean", description: "Permite PATCH" },
            excluir: { type: "boolean", description: "Permite DELETE" },
        },
        example: {
            id: 1,
            rota: "/usuarios",
            dominio: "http://localhost:3000",
            ativo: true,
            buscar: true,
            enviar: true,
            substituir: true,
            modificar: true,
            excluir: true,
        }
    },
    RotaPost: {
        type: "object",
        required: ["rotas", "dominio", "ativo", "buscar", "enviar", "substituir", "modificar", "excluir"], // Define quais campos são obrigatórios
        properties: {
            rotas: { type: "string", description: "Nome da rota" },
            dominio: { type: "string", description: "Domínio da rota" },
            ativo: { type: "boolean", description: "Rota ativa" },
            buscar: { type: "boolean", description: "Permite GET" },
            enviar: { type: "boolean", description: "Permite POST" },
            substituir: { type: "boolean", description: "Permite PUT" },
            modificar: { type: "boolean", description: "Permite PATCH" },
            excluir: { type: "boolean", description: "Permite DELETE" },
        },
        example: {
            rota: "/usuarios",
            dominio: "http://localhost:3000",
            ativo: true,
            buscar: true,
            enviar: true,
            substituir: true,
            modificar: true,
            excluir: true,
        }
    },
    RotaPostResposta: {
        type: "object",
        properties: {
            _id: { type: "string", description: "ID da rota" },
            rotas: { type: "string", description: "Nome da rota" },
            dominio: { type: "string", description: "Domínio da rota" },
            ativo: { type: "boolean", description: "Rota ativa" },
            buscar: { type: "boolean", description: "Permite GET" },
            enviar: { type: "boolean", description: "Permite POST" },
            substituir: { type: "boolean", description: "Permite PUT" },
            modificar: { type: "boolean", description: "Permite PATCH" },
            excluir: { type: "boolean", description: "Permite DELETE" },
        },
        example: {
            _id: "5f7c5d3b1c9d440000f3c2a1",
            rota: "/usuarios",
            dominio: "http://localhost:3000",
            ativo: true,
            buscar: true,
            enviar: true,
            substituir: true,
            modificar: true,
            excluir: true,
        }
    },
    RotaPutPatch: {
        type: "object",
        required: ["name", "description"], // Define quais campos são obrigatórios
        properties: {
            rotas: { type: "string", description: "Nome da rota" },
            dominio: { type: "string", description: "Domínio da rota" },
            ativo: { type: "boolean", description: "Rota ativa" },
            buscar: { type: "boolean", description: "Permite GET" },
            enviar: { type: "boolean", description: "Permite POST" },
            substituir: { type: "boolean", description: "Permite PUT" },
            modificar: { type: "boolean", description: "Permite PATCH" },
            excluir: { type: "boolean", description: "Permite DELETE" },
        },
        example: {
            rota: "/usuarios",
            dominio: "http://localhost:3000",
            ativo: true,
            buscar: true,
            enviar: true,
            substituir: true,
            modificar: true,
            excluir: true,
        }
    },
};

export default rotasSchemas;

===== ./docs/schemas.bkp/swaggerCommonResponses.js =====


===== # =====


===== separador =====


===== legível =====

import messages from "../../utils/helpers/HttpStatusCodes.js";

const swaggerCommonResponses = {
    200: (schemaRef = null, description = messages.OK.message) => ({
        description: description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef ? { $ref: schemaRef } : { type: "array", items: {}, example: [] },
                        error: { type: "boolean", example: false },
                        code: { type: "integer", example: messages.OK.code },
                        message: { type: "string", example: messages.OK.message },
                        errors: { type: "array", example: [] }
                    }
                }
            }
        }
    }),

    201: (schemaRef = null, description = messages.CREATED.message) => ({
        description: description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef ? { $ref: schemaRef } : { type: "array", items: {}, example: [] },
                        error: { type: "boolean", example: false },
                        code: { type: "integer", example: messages.CREATED.code },
                        message: { type: "string", example: messages.CREATED.message },
                        errors: { type: "array", example: [] }
                    }
                }
            }
        }
    }),
    400: (schemaRef = null, description = messages.BAD_REQUEST.message) => ({
        description: description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef ? { $ref: schemaRef } : { type: "array", items: {}, example: [] },
                        error: { type: "boolean", example: true },
                        code: { type: "integer", example: messages.BAD_REQUEST.code },
                        message: { type: "string", example: messages.BAD_REQUEST.message },
                        errors: {
                            type: "array", example: [{ message: messages.BAD_REQUEST.message }],
                        }
                    }
                }
            }
        }
    }),

    401: (schemaRef = null, description = messages.UNAUTHORIZED.message) => ({
        description: description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef ? { $ref: schemaRef } : { type: "array", items: {}, example: [] },
                        error: { type: "boolean", example: true },
                        code: { type: "integer", example: messages.UNAUTHORIZED.code },
                        message: { type: "string", example: messages.UNAUTHORIZED.message },
                        errors: { type: "array", example: [{ message: messages.UNAUTHORIZED.message }] }
                    }
                }
            }
        }
    }),

    404: (schemaRef = null, description = messages.NOT_FOUND.message) => ({
        description: description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef ? { $ref: schemaRef } : { type: "array", items: {}, example: [] },
                        error: { type: "boolean", example: true },
                        code: { type: "integer", example: messages.NOT_FOUND.code },
                        message: { type: "string", example: messages.NOT_FOUND.message },
                        errors: { type: "array", example: [{ message: messages.NOT_FOUND.message }] }
                    }
                }
            }
        }
    }),

    422: (schemaRef = null, description = messages.UNPROCESSABLE_ENTITY.message) => ({
        description: description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef ? { $ref: schemaRef } : { type: "array", items: {}, example: [] },
                        error: { type: "boolean", example: true },
                        code: { type: "integer", example: messages.UNPROCESSABLE_ENTITY.code },
                        message: { type: "string", example: messages.UNPROCESSABLE_ENTITY.message },
                        errors: { type: "array", example: [{ message: messages.UNPROCESSABLE_ENTITY.message }] }
                    }
                }
            }
        }
    }),

    498: (schemaRef = null, description = messages.INVALID_TOKEN.message) => ({
        description: description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef ? { $ref: schemaRef } : { type: "array", items: {}, example: [] },
                        error: { type: "boolean", example: true },
                        code: { type: "integer", example: messages.INVALID_TOKEN.code },
                        message: { type: "string", example: messages.INVALID_TOKEN.message },
                        errors: { type: "array", example: [{ message: messages.INVALID_TOKEN.message }] }
                    }
                }
            }
        }
    }),

    500: (schemaRef = null, description = messages.INTERNAL_SERVER_ERROR.message) => ({
        description: description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef ? { $ref: schemaRef } : { type: "array", items: {}, example: [] },
                        error: { type: "boolean", example: true },
                        code: { type: "integer", example: messages.INTERNAL_SERVER_ERROR.code },
                        message: { type: "string", example: messages.INTERNAL_SERVER_ERROR.message },
                        errors: { type: "array", example: [{ message: messages.INTERNAL_SERVER_ERROR.message }] }
                    }
                }
            }
        }
    })
};

export default swaggerCommonResponses;

===== ./docs/schemas.bkp/unidadesSchema.js =====


===== # =====


===== separador =====


===== legível =====

const unidadesSchemas = {
    UnidadeFiltro: {
        type: "object",
        properties: {
            nome: {
                type: "string",
                description: "Nome da unidade"
            },
            localidade: {
                type: "string",
                description: "Localidade da unidade"
            },
            ativo: {
                type: "boolean",
                description: "Ativo"
            }
        }
    },
    UnidadeListagem: {
        type: "object",
        properties: {
            _id: { type: "integer", description: "_id do unidade" },
            nome: { type: "string", description: "Nome do unidade" },
            localidade: { type: "string", description: "Localidade do unidade" },
            ativo: {
                type: "boolean", description: "Estado do unidade"
            },
        },
        example: [{
            _id: "674fa21d79969d2172e7876e",
            nome: "Matrix",
            localidade: "Vilhena",
            ativo: true
        },
        {
            _id: "674fa21d79969d2172e7876e",
            nome: "Matrix",
            localidade: "Vilhena",
            ativo: true
        }]
    },
    UnidadeDetalhes: {
        type: "object",
        properties: {
            _id: { type: "integer", description: "_id do unidade" },
            nome: { type: "string", description: "Nome do unidade" },
            localidade: { type: "string", description: "Localidade do unidade" },
            ativo: {
                type: "boolean", description: "Estado do unidade"
            },
        },
        example: {
            _id: "674fa21d79969d2172e7876e",
            nome: "Matrix",
            localidade: "Vilhena",
            ativo: true
        }
    },
    UnidadePost: {
        type: "object",
        required: ["nome", "localidade"], // Define quais campos são obrigatórios
        properties: {
            nome: { type: "string", description: "Nome do unidade" },
            localidade: { type: "string", description: "Localidade do unidade" },
            ativo: {
                type: "boolean", description: "Estado do unidade"
            },
        },
        example: {
            nome: "Matrix",
            localidade: "Vilhena",
            ativo: true
        }
    },
    UnidadePostResposta: {
        type: "object",
        properties: {
            nome: { type: "string", description: "Nome do unidade" },
            localidade: { type: "string", description: "Localidade do unidade" },
            ativo: {
                type: "boolean", description: "Estado do unidade"
            },
        },
        example: {
            _id: "674fa21d79969d2172e7876e",
            nome: "Matrix",
            localidade: "Vilhena",
            ativo: true
        }
    },
    UnidadePutPatch: {
        type: "object",
        properties: {
            nome: { type: "string", description: "Nome do unidade" },
            localidade: { type: "string", description: "Localidade do unidade" },
            ativo: {
                type: "boolean", description: "Estado do unidade"
            },
        },
        example: {
            nome: "Matrix",
            localidade: "Vilhena",
            ativo: true
        }
    },
};

export default unidadesSchemas;

===== ./docs/schemas.bkp/usuariosSchema.js =====


===== # =====


===== separador =====


===== legível =====

const usuariosSchemas = {
    UsuarioFiltro: {
        type: "object",
        properties: {
            nome: {
                type: "string",
                description: "Nome do usuário"
            },
            email: {
                type: "string",
                description: "Email do usuário"
            },
            ativo: {
                type: "boolean",
                description: "Status de atividade do usuário"
            },
            grupo: {
                type: "string",
                description: "Nome de um grupo que o usuário faça parte"
            },
            unidade: {
                type: "string",
                description: "Nome de uma unidade que o usuário faça parte"
            },
        }
    },
    UsuarioListagem: {
        type: "object",
        properties: {
            id: { type: "integer", description: "ID do usuário" },
            nome: { type: "string", description: "Nome do usuário" },
            email: { type: "string", description: "Email do usuário" },
            link_foto: { type: "string", description: "Caminho da foto do usuário" },
            ativo: { type: "string", description: "Status de atividade do usuário" },
            unidades: { type: "array", items: { type: "string" }, description: "Unidades do usuário" },
            grupos: { type: "array", items: { type: "string" }, description: "Grupos do usuário" },
            permissoes: { type: "array", items: { type: "object" }, description: "Permissões do usuário" },
        },
        example: {
            "_id": "674fa21d79969d2172e7876e",
            "nome": "Adnilson Macedo Saraiva",
            "email": "adnilson.saraiva4420773879+fake@yahoo.com",
            "ativo": true,
            "link_foto": "https://s3.amazonaws.com/uifaces/faces/twitter/jeremyworboys/128.jpg",
            "permissoes": [
                {
                    "_id": "674fa21c79969d2172e786fa",
                    "rota": "rotas",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fb",
                    "rota": "rotas:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fc",
                    "rota": "grupos",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fd",
                    "rota": "grupos:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fe",
                    "rota": "unidades",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786ff",
                    "rota": "unidades:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e78700",
                    "rota": "usuarios",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e78701",
                    "rota": "usuarios:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                }
            ],
            "grupos": [
                {
                    "_id": "674fa21c79969d2172e78708",
                    "nome": "Operador",
                    "descricao": "Impedit distinctio repellat ab quis laborum incidunt sed.",
                    "ativo": true,
                    "unidades": [
                        {
                            "_id": "674fa21c79969d2172e786f1",
                            "nome": "Matriz",
                            "localidade": "São Paulo - SP",
                            "ativo": true
                        }
                    ],
                    "permissoes": [
                        {
                            "_id": "674fa21c79969d2172e786fa",
                            "rota": "rotas",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fb",
                            "rota": "rotas:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fc",
                            "rota": "grupos",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fd",
                            "rota": "grupos:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fe",
                            "rota": "unidades",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786ff",
                            "rota": "unidades:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e78700",
                            "rota": "usuarios",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e78701",
                            "rota": "usuarios:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        }
                    ]
                }
            ],
            "unidades": [
                {
                    "_id": "674fa21c79969d2172e786ed",
                    "nome": "Filial 2",
                    "localidade": "Mariella do Sul - Mato Grosso",
                    "ativo": false
                }
            ]
        },
    },
    UsuarioDetalhes: {
        type: "object",
        properties: {
            id: { type: "integer", description: "ID do usuário" },
            nnme: { type: "string", description: "Nome do usuário" },
            email: { type: "string", description: "Email do usuário" },
            link_foto: { type: "string", description: "Caminho da foto do usuário" },
            ativo: { type: "string", description: "Status de atividade do usuário" },
            unidades: { type: "array", items: { type: "string" }, description: "Unidades do usuário" },
            grupos: { type: "array", items: { type: "string" }, description: "Grupos do usuário" },
            permissoes: { type: "array", items: { type: "object" }, description: "Permissões do usuário" },
        },
        example: {
            example: {
                "_id": "674fa21d79969d2172e7876e",
                "nome": "Adnilson Macedo Saraiva",
                "email": "adnilson.saraiva4420773879+fake@yahoo.com",
                "ativo": true,
                "link_foto": "https://s3.amazonaws.com/uifaces/faces/twitter/jeremyworboys/128.jpg",
                "permissoes": [
                    {
                        "_id": "674fa21c79969d2172e786fa",
                        "rota": "rotas",
                        "dominio": "localhost",
                        "ativo": true,
                        "buscar": true,
                        "enviar": true,
                        "substituir": true,
                        "modificar": true,
                        "excluir": true
                    },
                    {
                        "_id": "674fa21c79969d2172e786fb",
                        "rota": "rotas:id",
                        "dominio": "localhost",
                        "ativo": true,
                        "buscar": true,
                        "enviar": true,
                        "substituir": true,
                        "modificar": true,
                        "excluir": true
                    },
                    {
                        "_id": "674fa21c79969d2172e786fc",
                        "rota": "grupos",
                        "dominio": "localhost",
                        "ativo": true,
                        "buscar": true,
                        "enviar": true,
                        "substituir": true,
                        "modificar": true,
                        "excluir": true
                    },
                    {
                        "_id": "674fa21c79969d2172e786fd",
                        "rota": "grupos:id",
                        "dominio": "localhost",
                        "ativo": true,
                        "buscar": true,
                        "enviar": true,
                        "substituir": true,
                        "modificar": true,
                        "excluir": true
                    },
                    {
                        "_id": "674fa21c79969d2172e786fe",
                        "rota": "unidades",
                        "dominio": "localhost",
                        "ativo": true,
                        "buscar": true,
                        "enviar": true,
                        "substituir": true,
                        "modificar": true,
                        "excluir": true
                    },
                    {
                        "_id": "674fa21c79969d2172e786ff",
                        "rota": "unidades:id",
                        "dominio": "localhost",
                        "ativo": true,
                        "buscar": true,
                        "enviar": true,
                        "substituir": true,
                        "modificar": true,
                        "excluir": true
                    },
                    {
                        "_id": "674fa21c79969d2172e78700",
                        "rota": "usuarios",
                        "dominio": "localhost",
                        "ativo": true,
                        "buscar": true,
                        "enviar": true,
                        "substituir": true,
                        "modificar": true,
                        "excluir": true
                    },
                    {
                        "_id": "674fa21c79969d2172e78701",
                        "rota": "usuarios:id",
                        "dominio": "localhost",
                        "ativo": true,
                        "buscar": true,
                        "enviar": true,
                        "substituir": true,
                        "modificar": true,
                        "excluir": true
                    }
                ],
                "grupos": [
                    {
                        "_id": "674fa21c79969d2172e78708",
                        "nome": "Operador",
                        "descricao": "Impedit distinctio repellat ab quis laborum incidunt sed.",
                        "ativo": true,
                        "unidades": [
                            {
                                "_id": "674fa21c79969d2172e786f1",
                                "nome": "Matriz",
                                "localidade": "São Paulo - SP",
                                "ativo": true
                            }
                        ],
                        "permissoes": [
                            {
                                "_id": "674fa21c79969d2172e786fa",
                                "rota": "rotas",
                                "dominio": "localhost",
                                "ativo": true,
                                "buscar": true,
                                "enviar": true,
                                "substituir": true,
                                "modificar": true,
                                "excluir": true
                            },
                            {
                                "_id": "674fa21c79969d2172e786fb",
                                "rota": "rotas:id",
                                "dominio": "localhost",
                                "ativo": true,
                                "buscar": true,
                                "enviar": true,
                                "substituir": true,
                                "modificar": true,
                                "excluir": true
                            },
                            {
                                "_id": "674fa21c79969d2172e786fc",
                                "rota": "grupos",
                                "dominio": "localhost",
                                "ativo": true,
                                "buscar": true,
                                "enviar": true,
                                "substituir": true,
                                "modificar": true,
                                "excluir": true
                            },
                            {
                                "_id": "674fa21c79969d2172e786fd",
                                "rota": "grupos:id",
                                "dominio": "localhost",
                                "ativo": true,
                                "buscar": true,
                                "enviar": true,
                                "substituir": true,
                                "modificar": true,
                                "excluir": true
                            },
                            {
                                "_id": "674fa21c79969d2172e786fe",
                                "rota": "unidades",
                                "dominio": "localhost",
                                "ativo": true,
                                "buscar": true,
                                "enviar": true,
                                "substituir": true,
                                "modificar": true,
                                "excluir": true
                            },
                            {
                                "_id": "674fa21c79969d2172e786ff",
                                "rota": "unidades:id",
                                "dominio": "localhost",
                                "ativo": true,
                                "buscar": true,
                                "enviar": true,
                                "substituir": true,
                                "modificar": true,
                                "excluir": true
                            },
                            {
                                "_id": "674fa21c79969d2172e78700",
                                "rota": "usuarios",
                                "dominio": "localhost",
                                "ativo": true,
                                "buscar": true,
                                "enviar": true,
                                "substituir": true,
                                "modificar": true,
                                "excluir": true
                            },
                            {
                                "_id": "674fa21c79969d2172e78701",
                                "rota": "usuarios:id",
                                "dominio": "localhost",
                                "ativo": true,
                                "buscar": true,
                                "enviar": true,
                                "substituir": true,
                                "modificar": true,
                                "excluir": true
                            }
                        ]
                    }
                ],
                "unidades": [
                    {
                        "_id": "674fa21c79969d2172e786ed",
                        "nome": "Filial 2",
                        "localidade": "Mariella do Sul - Mato Grosso",
                        "ativo": false
                    }
                ]
            },
        }
    },
    UsuarioPost: {
        type: "object",
        required: ["nome", "email", "senha"],
        properties: {
            nome: { type: "string", description: "Nome do usuário" },
            email: { type: "string", description: "Email do usuário" },
            senha: { type: "string", description: "Senha do usuário" },
            ativo: { type: "boolean", description: "Status de atividade do usuário" },
            link_foto: { type: "string", description: "Caminho da foto do usuário" },
            permissoes: { type: "array", items: { type: "object" }, description: "Permissões do usuário" },
            grupos: { type: "array", items: { type: "string" }, description: "Grupos do usuário" },
            unidades: { type: "array", items: { type: "string" }, description: "Unidades do usuário" },
        },
        example: {
            "_id": "674fa21d79969d2172e7876e",
            "nome": "Adnilson Macedo Saraiva",
            "email": "adnilson.saraiva4420773879+fake@yahoo.com",
            "ativo": true,
            "link_foto": "https://s3.amazonaws.com/uifaces/faces/twitter/jeremyworboys/128.jpg",
            "permissoes": [
                {
                    "_id": "674fa21c79969d2172e786fa",
                    "rota": "rotas",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fb",
                    "rota": "rotas:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fc",
                    "rota": "grupos",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fd",
                    "rota": "grupos:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fe",
                    "rota": "unidades",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786ff",
                    "rota": "unidades:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e78700",
                    "rota": "usuarios",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e78701",
                    "rota": "usuarios:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                }
            ],
            "grupos": [
                {
                    "_id": "674fa21c79969d2172e78708",
                    "nome": "Operador",
                    "descricao": "Impedit distinctio repellat ab quis laborum incidunt sed.",
                    "ativo": true,
                    "unidades": [
                        {
                            "_id": "674fa21c79969d2172e786f1",
                            "nome": "Matriz",
                            "localidade": "São Paulo - SP",
                            "ativo": true
                        }
                    ],
                    "permissoes": [
                        {
                            "_id": "674fa21c79969d2172e786fa",
                            "rota": "rotas",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fb",
                            "rota": "rotas:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fc",
                            "rota": "grupos",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fd",
                            "rota": "grupos:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fe",
                            "rota": "unidades",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786ff",
                            "rota": "unidades:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e78700",
                            "rota": "usuarios",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e78701",
                            "rota": "usuarios:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        }
                    ]
                }
            ],
            "unidades": [
                {
                    "_id": "674fa21c79969d2172e786ed",
                    "nome": "Filial 2",
                    "localidade": "Mariella do Sul - Mato Grosso",
                    "ativo": false
                }
            ]
        },
    },
    UsuarioPostResposta: {
        type: "object",
        properties: {
            id: { type: "integer", description: "ID do usuário" },
            nome: { type: "string", description: "Nome do usuário" },
            email: { type: "string", description: "Email do usuário" },
            link_foto: { type: "string", description: "Caminho da foto do usuário" },
            ativo: { type: "string", description: "Status de atividade do usuário" },
            unidades: { type: "array", items: { type: "string" }, description: "Unidades do usuário" },
            grupos: { type: "array", items: { type: "string" }, description: "Grupos do usuário" },
            permissoes: { type: "array", items: { type: "object" }, description: "Permissões do usuário" },
        },
        example: {
            "nome": "Adnilson Macedo Saraiva",
            "email": "adnilson.saraiva4420773879+fake@yahoo.com",
            "ativo": true,
            "link_foto": "https://s3.amazonaws.com/uifaces/faces/twitter/jeremyworboys/128.jpg",
            "permissoes": [
                {
                    "_id": "674fa21c79969d2172e786fa",
                    "rota": "rotas",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fb",
                    "rota": "rotas:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fc",
                    "rota": "grupos",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fd",
                    "rota": "grupos:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fe",
                    "rota": "unidades",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786ff",
                    "rota": "unidades:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e78700",
                    "rota": "usuarios",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e78701",
                    "rota": "usuarios:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                }
            ],
            "grupos": [
                {
                    "_id": "674fa21c79969d2172e78708",
                    "nome": "Operador",
                    "descricao": "Impedit distinctio repellat ab quis laborum incidunt sed.",
                    "ativo": true,
                    "unidades": [
                        {
                            "_id": "674fa21c79969d2172e786f1",
                            "nome": "Matriz",
                            "localidade": "São Paulo - SP",
                            "ativo": true
                        }
                    ],
                    "permissoes": [
                        {
                            "_id": "674fa21c79969d2172e786fa",
                            "rota": "rotas",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fb",
                            "rota": "rotas:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fc",
                            "rota": "grupos",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fd",
                            "rota": "grupos:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fe",
                            "rota": "unidades",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786ff",
                            "rota": "unidades:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e78700",
                            "rota": "usuarios",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e78701",
                            "rota": "usuarios:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        }
                    ]
                }
            ],
            "unidades": [
                {
                    "_id": "674fa21c79969d2172e786ed",
                    "nome": "Filial 2",
                    "localidade": "Mariella do Sul - Mato Grosso",
                    "ativo": false
                }
            ]
        },
    },
    UsuarioPutPatch: {
        type: "object",
        properties: {
            nome: { type: "string", description: "Nome do usuário" },
            link_foto: { type: "string", description: "Caminho da foto do usuário" },
            ativo: { type: "string", description: "Status de atividade do usuário" },
            unidades: { type: "array", items: { type: "string" }, description: "Unidades do usuário" },
            grupos: { type: "array", items: { type: "string" }, description: "Grupos do usuário" },
            permissoes: { type: "array", items: { type: "object" }, description: "Permissões do usuário" },
        },
        example: {
            "nome": "Adnilson Macedo Saraiva",
            "ativo": true,
            "link_foto": "https://s3.amazonaws.com/uifaces/faces/twitter/jeremyworboys/128.jpg",
            "permissoes": [
                {
                    "_id": "674fa21c79969d2172e786fa",
                    "rota": "rotas",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fb",
                    "rota": "rotas:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fc",
                    "rota": "grupos",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fd",
                    "rota": "grupos:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786fe",
                    "rota": "unidades",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e786ff",
                    "rota": "unidades:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e78700",
                    "rota": "usuarios",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                },
                {
                    "_id": "674fa21c79969d2172e78701",
                    "rota": "usuarios:id",
                    "dominio": "localhost",
                    "ativo": true,
                    "buscar": true,
                    "enviar": true,
                    "substituir": true,
                    "modificar": true,
                    "excluir": true
                }
            ],
            "grupos": [
                {
                    "_id": "674fa21c79969d2172e78708",
                    "nome": "Operador",
                    "descricao": "Impedit distinctio repellat ab quis laborum incidunt sed.",
                    "ativo": true,
                    "unidades": [
                        {
                            "_id": "674fa21c79969d2172e786f1",
                            "nome": "Matriz",
                            "localidade": "São Paulo - SP",
                            "ativo": true
                        }
                    ],
                    "permissoes": [
                        {
                            "_id": "674fa21c79969d2172e786fa",
                            "rota": "rotas",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fb",
                            "rota": "rotas:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fc",
                            "rota": "grupos",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fd",
                            "rota": "grupos:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786fe",
                            "rota": "unidades",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e786ff",
                            "rota": "unidades:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e78700",
                            "rota": "usuarios",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        },
                        {
                            "_id": "674fa21c79969d2172e78701",
                            "rota": "usuarios:id",
                            "dominio": "localhost",
                            "ativo": true,
                            "buscar": true,
                            "enviar": true,
                            "substituir": true,
                            "modificar": true,
                            "excluir": true
                        }
                    ]
                }
            ],
            "unidades": [
                {
                    "_id": "674fa21c79969d2172e786ed",
                    "nome": "Filial 2",
                    "localidade": "Mariella do Sul - Mato Grosso",
                    "ativo": false
                }
            ]
        },
    }
};

export default usuariosSchemas;

===== ./docs/schemas/authSchema.js =====


===== # =====


===== separador =====


===== legível =====

import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Definição original do authSchemas
const authSchemas = {
  RespostaRecuperaSenha: {
    type: "object",
    properties: {
      message: {
        type: "string",
        description: "Mensagem indicando o status da recuperação de senha",
        example: "Email enviado com sucesso para recuperação de senha"
      }
    },
  },
  RequisicaoRecuperaSenha: {
    type: "object",
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "Endereço de email do usuário para recuperação de senha",
      }
    },
    required: ["email"]
  },
  loginPost: {
    type: "object",
    properties: {
      email: { type: "string", description: "Email do usuário" },
      senha: { type: "string", description: "Senha do usuário" }
    },
    required: ["email", "senha"]
  },
  RespostaPass: {
    type: "object",
    properties: {
      accesstoken: { type: "string", description: "Token de acesso do usuário" },
      domain: { type: "string", description: "Domínio do usuário" },
      path: { type: "string", description: "Caminho do recurso" },
      metodo: { type: "string", description: "Método HTTP utilizado" }
    },
  },
};

const addExamples = async () => {
  for (const key of Object.keys(authSchemas)) {
    const schema = authSchemas[key];
    if (schema.properties) {
      for (const [propKey, propertySchema] of Object.entries(schema.properties)) {
        propertySchema.example = await generateExample(propertySchema, propKey);
      }
    }
    schema.example = await generateExample(schema);
  }
};

await addExamples();

export default authSchemas;

===== ./docs/schemas/cursosSchema.js =====


===== # =====


===== separador =====


===== legível =====

// schemas/cursosSchemas.js
import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Curso from '../../models/Curso.js';


// Importa as funções utilitárias separadas
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir dos schemas dos modelos
const cursoJsonSchema = Curso.schema.jsonSchema();

// Remove campos que não queremos na base original
delete cursoJsonSchema.properties.__v;

// Componha os diferentes contratos da sua API utilizando cópias profundas dos schemas
const cursosSchemas = {
  CursoFiltro: {
    type: "object",
    properties: {
      codigo: cursoJsonSchema.properties.codigo,
      nome: cursoJsonSchema.properties.nome,
    }
  },
  CursoListagem: {
    ...deepCopy(cursoJsonSchema),
    description: "Schema para listagem de usuários"
  },
  CursoDetalhes: {
    ...deepCopy(cursoJsonSchema),
    description: "Schema para detalhes de um usuário"
  },
  CursoPost: {
    ...deepCopy(cursoJsonSchema),
    description: "Schema para criação de usuário"
  },
  CursoPutPatch: {
    ...deepCopy(cursoJsonSchema),
    required: [],
    description: "Schema para atualização de usuário"
  }
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  CursoListagem: ['__v'],
  CursoDetalhes: ['__v'],
  CursoPost: ['createdAt', 'updatedAt', '__v', '_id'],
  CursoPutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
};

// Aplica a remoção de campos de forma individual a cada schema
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (cursosSchemas[schemaKey]) {
    removeFieldsRecursively(cursosSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detectar referências automaticamente
const cursoMongooseSchema = Curso.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para detecção de referências
cursosSchemas.CursoListagem.example = await generateExample(cursosSchemas.CursoListagem, null, cursoMongooseSchema);
cursosSchemas.CursoDetalhes.example = await generateExample(cursosSchemas.CursoDetalhes, null, cursoMongooseSchema);
cursosSchemas.CursoPost.example = await generateExample(cursosSchemas.CursoPost, null, cursoMongooseSchema);
cursosSchemas.CursoPutPatch.example = await generateExample(cursosSchemas.CursoPutPatch, null, cursoMongooseSchema);

export default cursosSchemas;

===== ./docs/schemas/estagiosSchema.js =====


===== # =====


===== separador =====


===== legível =====

// schemas/estagiosSchemas.js
import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Estagio from '../../models/Estagio.js';


// Importa as funções utilitárias separadas
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir dos schemas dos modelos
const estagioJsonSchema = Estagio.schema.jsonSchema();

// Remove campos que não queremos na base original
delete estagioJsonSchema.properties.__v;

// Componha os diferentes contratos da sua API utilizando cópias profundas dos schemas
const estagiosSchemas = {
  EstagioFiltro: {
    type: "object",
    properties: {
      estudante: estagioJsonSchema.properties.estudante,
      data_inicio: estagioJsonSchema.properties.data_inicio,
      data_termino: estagioJsonSchema.properties.data_termino,
      descricao: estagioJsonSchema.properties.descricao,
      status: estagioJsonSchema.properties.status
    }
  },
  EstagioListagem: {
    ...deepCopy(estagioJsonSchema),
    description: "Schema para listagem de usuários"
  },
  EstagioDetalhes: {
    ...deepCopy(estagioJsonSchema),
    description: "Schema para detalhes de um usuário"
  },
  EstagioPost: {
    ...deepCopy(estagioJsonSchema),
    description: "Schema para criação de usuário"
  },
  EstagioPutPatch: {
    ...deepCopy(estagioJsonSchema),
    required: [],
    description: "Schema para atualização de usuário"
  }
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  EstagioListagem: ['__v'],
  EstagioDetalhes: ['__v'],
  EstagioPost: ['createdAt', 'updatedAt', '__v', '_id'],
  EstagioPutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
};

// Aplica a remoção de campos de forma individual a cada schema
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (estagiosSchemas[schemaKey]) {
    removeFieldsRecursively(estagiosSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detectar referências automaticamente
const estagioMongooseSchema = Estagio.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para detecção de referências
estagiosSchemas.EstagioListagem.example = await generateExample(estagiosSchemas.EstagioListagem, null, estagioMongooseSchema);
estagiosSchemas.EstagioDetalhes.example = await generateExample(estagiosSchemas.EstagioDetalhes, null, estagioMongooseSchema);
estagiosSchemas.EstagioPost.example = await generateExample(estagiosSchemas.EstagioPost, null, estagioMongooseSchema);
estagiosSchemas.EstagioPutPatch.example = await generateExample(estagiosSchemas.EstagioPutPatch, null, estagioMongooseSchema);

export default estagiosSchemas;

===== ./docs/schemas/estudantesSchema.js =====


===== # =====


===== separador =====


===== legível =====

// schemas/estudantesSchemas.js
import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Estudante from '../../models/Estudante.js';


// Importa as funções utilitárias separadas
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir dos schemas dos modelos
const estudanteJsonSchema = Estudante.schema.jsonSchema();

// Remove campos que não queremos na base original
delete estudanteJsonSchema.properties.__v;

// Componha os diferentes contratos da sua API utilizando cópias profundas dos schemas
const estudantesSchemas = {
  EstudanteFiltro: {
    type: "object",
    properties: {
      matricula: estudanteJsonSchema.properties.matricula,
      nome: estudanteJsonSchema.properties.nome,
      ativo: estudanteJsonSchema.properties.ativo,
      turma: estudanteJsonSchema.properties.turma,
    }
  },
  EstudanteListagem: {
    ...deepCopy(estudanteJsonSchema),
    description: "Schema para listagem de usuários"
  },
  EstudanteDetalhes: {
    ...deepCopy(estudanteJsonSchema),
    description: "Schema para detalhes de um usuário"
  },
  EstudantePost: {
    ...deepCopy(estudanteJsonSchema),
    description: "Schema para criação de usuário"
  },
  EstudantePutPatch: {
    ...deepCopy(estudanteJsonSchema),
    required: [],
    description: "Schema para atualização de usuário"
  }
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  EstudanteListagem: ['__v'],
  EstudanteDetalhes: ['__v'],
  EstudantePost: ['createdAt', 'updatedAt', '__v', '_id'],
  EstudantePutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
};

// Aplica a remoção de campos de forma individual a cada schema
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (estudantesSchemas[schemaKey]) {
    removeFieldsRecursively(estudantesSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detectar referências automaticamente
const estudanteMongooseSchema = Estudante.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para detecção de referências
estudantesSchemas.EstudanteListagem.example = await generateExample(estudantesSchemas.EstudanteListagem, null, estudanteMongooseSchema);
estudantesSchemas.EstudanteDetalhes.example = await generateExample(estudantesSchemas.EstudanteDetalhes, null, estudanteMongooseSchema);
estudantesSchemas.EstudantePost.example = await generateExample(estudantesSchemas.EstudantePost, null, estudanteMongooseSchema);
estudantesSchemas.EstudantePutPatch.example = await generateExample(estudantesSchemas.EstudantePutPatch, null, estudanteMongooseSchema);

export default estudantesSchemas;

===== ./docs/schemas/gruposSchema.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Grupo from '../../models/Grupo.js';
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir do schema do modelo Grupo
const grupoJsonSchema = Grupo.schema.jsonSchema();

// Remove o campo __v da representação original, se existir
delete grupoJsonSchema.properties.__v;

// Compondo os diferentes contratos da API utilizando cópias profundas do schema gerado
const gruposSchemas = {
  GrupoFiltro: {
    type: "object",
    properties: {
      nome: grupoJsonSchema.properties.nome,
      descricao: grupoJsonSchema.properties.descricao,
      ativo: grupoJsonSchema.properties.ativo,
      unidades: grupoJsonSchema.properties.nome,
    }
  },
  GrupoListagem: {
    ...deepCopy(grupoJsonSchema),
    required: [],
    description: "Schema para listagem de grupos"
  },
  GrupoDetalhes: {
    ...deepCopy(grupoJsonSchema),
    required: [],
    description: "Schema para detalhes de um grupo"
  },
  GrupoPost: {
    ...deepCopy(grupoJsonSchema),
    required: ["nome", "descricao"],
    description: "Schema para criação de grupo"
  },
  GrupoPostResposta: {
    ...deepCopy(grupoJsonSchema),
    required: [],
    description: "Schema de resposta para criação de grupo"
  },
  GrupoPutPatch: {
    ...deepCopy(grupoJsonSchema),
    required: [],
    description: "Schema para atualização de grupo"
  },
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  GrupoListagem: ['createdAt', 'updatedAt', '__v'],
  GrupoDetalhes: ['createdAt', 'updatedAt', '__v'],
  GrupoPost: ['createdAt', 'updatedAt', '__v', '_id'],
  GrupoPutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
  GrupoPostResposta: ['createdAt', 'updatedAt', '__v'],
};

// Aplica a remoção de campos conforme o mapping definido
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (gruposSchemas[schemaKey]) {
    removeFieldsRecursively(gruposSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detecção automática de referências
const grupoMongooseSchema = Grupo.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose
gruposSchemas.GrupoListagem.example = await generateExample(gruposSchemas.GrupoListagem, null, grupoMongooseSchema);
gruposSchemas.GrupoDetalhes.example = await generateExample(gruposSchemas.GrupoDetalhes, null, grupoMongooseSchema);
gruposSchemas.GrupoPost.example = await generateExample(gruposSchemas.GrupoPost, null, grupoMongooseSchema);
gruposSchemas.GrupoPutPatch.example = await generateExample(gruposSchemas.GrupoPutPatch, null, grupoMongooseSchema);
gruposSchemas.GrupoPostResposta.example = await generateExample(gruposSchemas.GrupoPostResposta, null, grupoMongooseSchema);

export default gruposSchemas;

===== ./docs/schemas/projetosSchema.js =====


===== # =====


===== separador =====


===== legível =====

// schemas/projetosSchemas.js
import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Projeto from '../../models/Projeto.js';


// Importa as funções utilitárias separadas
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';
import estudantesRoutes from '../routes/estudantes.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir dos schemas dos modelos
const projetoJsonSchema = Projeto.schema.jsonSchema();

// Remove campos que não queremos na base original
delete projetoJsonSchema.properties.__v;

// Componha os diferentes contratos da sua API utilizando cópias profundas dos schemas
const projetosSchemas = {
  ProjetoFiltro: {
    type: "object",
    properties: {
      nome: projetoJsonSchema.properties.nome,
      data_inicio: projetoJsonSchema.properties.data_inicio,
      data_termino: projetoJsonSchema.properties.data_termino,
      status: projetoJsonSchema.properties.status,
      estudante: projetoJsonSchema.properties.estudantes,
    }
  },
  ProjetoListagem: {
    ...deepCopy(projetoJsonSchema),
    description: "Schema para listagem de usuários"
  },
  ProjetoDetalhes: {
    ...deepCopy(projetoJsonSchema),
    description: "Schema para detalhes de um usuário"
  },
  ProjetoPost: {
    ...deepCopy(projetoJsonSchema),
    description: "Schema para criação de usuário"
  },
  ProjetoPutPatch: {
    ...deepCopy(projetoJsonSchema),
    required: [],
    description: "Schema para atualização de usuário"
  }
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  ProjetoListagem: ['__v'],
  ProjetoDetalhes: ['__v'],
  ProjetoPost: ['createdAt', 'updatedAt', '__v', '_id'],
  ProjetoPutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
};

// Aplica a remoção de campos de forma individual a cada schema
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (projetosSchemas[schemaKey]) {
    removeFieldsRecursively(projetosSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detectar referências automaticamente
const projetoMongooseSchema = Projeto.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para detecção de referências
projetosSchemas.ProjetoListagem.example = await generateExample(projetosSchemas.ProjetoListagem, null, projetoMongooseSchema);
projetosSchemas.ProjetoDetalhes.example = await generateExample(projetosSchemas.ProjetoDetalhes, null, projetoMongooseSchema);
projetosSchemas.ProjetoPost.example = await generateExample(projetosSchemas.ProjetoPost, null, projetoMongooseSchema);
projetosSchemas.ProjetoPutPatch.example = await generateExample(projetosSchemas.ProjetoPutPatch, null, projetoMongooseSchema);

export default projetosSchemas;

===== ./docs/schemas/refeicoesSchema.js =====


===== # =====


===== separador =====


===== legível =====

// schemas/refeicoesSchemas.js
import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Refeicoes from '../../models/Refeicao.js';


// Importa as funções utilitárias separadas
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir dos schemas dos modelos
const refeicoesJsonSchema = Refeicoes.schema.jsonSchema();

// Remove campos que não queremos na base original
delete refeicoesJsonSchema.properties.__v;

// Componha os diferentes contratos da sua API utilizando cópias profundas dos schemas
const refeicoesSchemas = {
  RefeicoesFiltro: {
    type: "object",
    properties: {
      estudante: refeicoesJsonSchema.properties.estudante,
      data: refeicoesJsonSchema.properties.data,
      tipoRefeicao: refeicoesJsonSchema.properties.tipoRefeicao,
      usuarioRegistrou: refeicoesJsonSchema.properties.usuarioRegistrou,
    }
  },
  RefeicoesListagem: {
    ...deepCopy(refeicoesJsonSchema),
    description: "Schema para listagem de usuários"
  },
  RefeicoesDetalhes: {
    ...deepCopy(refeicoesJsonSchema),
    description: "Schema para detalhes de um usuário"
  },
  RefeicoesPost: {
    ...deepCopy(refeicoesJsonSchema),
    description: "Schema para criação de usuário"
  },
  RefeicoesPutPatch: {
    ...deepCopy(refeicoesJsonSchema),
    required: [],
    description: "Schema para atualização de usuário"
  }
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  RefeicoesListagem: ['__v'],
  RefeicoesDetalhes: ['__v'],
  RefeicoesPost: ['createdAt', 'updatedAt', '__v', '_id'],
  RefeicoesPutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
};

// Aplica a remoção de campos de forma individual a cada schema
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (refeicoesSchemas[schemaKey]) {
    removeFieldsRecursively(refeicoesSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detectar referências automaticamente
const refeicoesMongooseSchema = Refeicoes.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para detecção de referências
refeicoesSchemas.RefeicoesListagem.example = await generateExample(refeicoesSchemas.RefeicoesListagem, null, refeicoesMongooseSchema);
refeicoesSchemas.RefeicoesDetalhes.example = await generateExample(refeicoesSchemas.RefeicoesDetalhes, null, refeicoesMongooseSchema);
refeicoesSchemas.RefeicoesPost.example = await generateExample(refeicoesSchemas.RefeicoesPost, null, refeicoesMongooseSchema);
refeicoesSchemas.RefeicoesPutPatch.example = await generateExample(refeicoesSchemas.RefeicoesPutPatch, null, refeicoesMongooseSchema);

export default refeicoesSchemas;

===== ./docs/schemas/refeicoesTurmasSchema.js =====


===== # =====


===== separador =====


===== legível =====

// schemas/turmasSchemas.js
import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import RefeicaoTurma from '../../models/RefeicaoTurma.js';



// Importa as funções utilitárias separadas
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir dos schemas dos modelos
const refeicoesTurmaJsonSchema = RefeicaoTurma.schema.jsonSchema();

// Remove campos que não queremos na base original
delete refeicoesTurmaJsonSchema.properties.__v;

// Componha os diferentes contratos da sua API utilizando cópias profundas dos schemas
const refeicoesTurmasSchemas = {
  RefeicoesTurmaFiltro: {
    type: "object",
    properties: {
      turma: refeicoesTurmaJsonSchema.properties.turma,
      data_liberado: refeicoesTurmaJsonSchema.properties.data_liberado,
      descricao: refeicoesTurmaJsonSchema.properties.descricao,
    }
  },
  RefeicoesTurmaListagem: {
    ...deepCopy(refeicoesTurmaJsonSchema),
    description: "Schema para listagem de usuários"
  },
  RefeicoesTurmaDetalhes: {
    ...deepCopy(refeicoesTurmaJsonSchema),
    description: "Schema para detalhes de um usuário"
  },
  RefeicoesTurmaPost: {
    ...deepCopy(refeicoesTurmaJsonSchema),
    description: "Schema para criação de usuário"
  },
  RefeicoesTurmaPutPatch: {
    ...deepCopy(refeicoesTurmaJsonSchema),
    required: [],
    description: "Schema para atualização de usuário"
  }
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  RefeicoesTurmaListagem: ['__v'],
  RefeicoesTurmaDetalhes: ['__v'],
  RefeicoesTurmaPost: ['createdAt', 'updatedAt', '__v', '_id'],
  RefeicoesTurmaPutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
};

// Aplica a remoção de campos de forma individual a cada schema
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (refeicoesTurmasSchemas[schemaKey]) {
    removeFieldsRecursively(refeicoesTurmasSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detectar referências automaticamente
const refeicoesTurmaMongooseSchema = RefeicaoTurma.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para detecção de referências
refeicoesTurmasSchemas.RefeicoesTurmaListagem.example = await generateExample(refeicoesTurmasSchemas.RefeicoesTurmaListagem, null, refeicoesTurmaMongooseSchema);
refeicoesTurmasSchemas.RefeicoesTurmaDetalhes.example = await generateExample(refeicoesTurmasSchemas.RefeicoesTurmaDetalhes, null, refeicoesTurmaMongooseSchema);
refeicoesTurmasSchemas.RefeicoesTurmaPost.example = await generateExample(refeicoesTurmasSchemas.RefeicoesTurmaPost, null, refeicoesTurmaMongooseSchema);
refeicoesTurmasSchemas.RefeicoesTurmaPutPatch.example = await generateExample(refeicoesTurmasSchemas.RefeicoesTurmaPutPatch, null, refeicoesTurmaMongooseSchema);

export default refeicoesTurmasSchemas;

===== ./docs/schemas/rotasSchema.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Rota from '../../models/Rota.js';
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir do schema do modelo Rota
const rotaJsonSchema = Rota.schema.jsonSchema();

// Remove o campo __v da representação original, se existir
delete rotaJsonSchema.properties.__v;

// Compondo os diferentes contratos da API utilizando cópias profundas do schema gerado
const rotasSchemas = {
  RotaFiltro: {
    type: "object",
    properties: {
      rota: rotaJsonSchema.properties.rota,
      descricao: rotaJsonSchema.properties.descricao,
      ativo: rotaJsonSchema.properties.ativo,
    }
  },
  RotaListagem: {
    ...deepCopy(rotaJsonSchema),
    required: [],
    description: "Schema para listagem de rotas"
  },
  RotaDetalhes: {
    ...deepCopy(rotaJsonSchema),
    required: [],
    description: "Schema para detalhes de uma rota"
  },
  RotaPost: {
    ...deepCopy(rotaJsonSchema),
    required: ["rota", "dominio"],
    description: "Schema para criação de rota"
  },
  RotaPostResposta: {
    ...deepCopy(rotaJsonSchema),
    required: [],
    description: "Schema de resposta para criação de rota"
  },
  RotaPutPatch: {
    ...deepCopy(rotaJsonSchema),
    required: [],
    description: "Schema para atualização de rota"
  },
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  RotaListagem: ['createdAt', 'updatedAt', '__v'],
  RotaDetalhes: ['createdAt', 'updatedAt', '__v'],
  RotaPost: ['createdAt', 'updatedAt', '__v', '_id'],
  RotaPutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
  RotaPostResposta: ['createdAt', 'updatedAt', '__v'],
};

// Aplica a remoção de campos conforme o mapping definido
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (rotasSchemas[schemaKey]) {
    removeFieldsRecursively(rotasSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detecção automática de referências
const rotaMongooseSchema = Rota.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para referência
rotasSchemas.RotaListagem.example = await generateExample(rotasSchemas.RotaListagem, null, rotaMongooseSchema);
rotasSchemas.RotaDetalhes.example = await generateExample(rotasSchemas.RotaDetalhes, null, rotaMongooseSchema);
rotasSchemas.RotaPost.example = await generateExample(rotasSchemas.RotaPost, null, rotaMongooseSchema);
rotasSchemas.RotaPutPatch.example = await generateExample(rotasSchemas.RotaPutPatch, null, rotaMongooseSchema);
rotasSchemas.RotaPostResposta.example = await generateExample(rotasSchemas.RotaPostResposta, null, rotaMongooseSchema);

export default rotasSchemas;

===== ./docs/schemas/swaggerCommonResponses.js =====


===== # =====


===== separador =====


===== legível =====

// src/docs/swaggerCommonResponses.js

import HttpStatusCodes from "../../utils/helpers/HttpStatusCodes.js";

const swaggerCommonResponses = {};

// Percorre todas as chaves do HttpStatusCodes e cria dinamicamente
// um método para cada status code, no mesmo padrão que você já utiliza.
Object.keys(HttpStatusCodes).forEach((statusKey) => {
    const { code, message } = HttpStatusCodes[statusKey];

    swaggerCommonResponses[code] = (schemaRef = null, description = message) => ({
        description,
        content: {
            "application/json": {
                schema: {
                    type: "object",
                    properties: {
                        data: schemaRef
                            ? { $ref: schemaRef }
                            : { type: "array", items: {}, example: [] },
                        message: { type: "string", example: message },
                        errors: {
                            type: "array",
                            // Para status de erro, retorna um array com um objeto contendo a mensagem
                            example: code >= 400 ? [{ message }] : [],
                        },
                    },
                },
            },
        },
    });
});

export default swaggerCommonResponses;

===== ./docs/schemas/turmasSchema.js =====


===== # =====


===== separador =====


===== legível =====

// schemas/turmasSchemas.js
import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Turma from '../../models/Turma.js';


// Importa as funções utilitárias separadas
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir dos schemas dos modelos
const turmaJsonSchema = Turma.schema.jsonSchema();

// Remove campos que não queremos na base original
delete turmaJsonSchema.properties.__v;

// Componha os diferentes contratos da sua API utilizando cópias profundas dos schemas
const turmasSchemas = {
  TurmaFiltro: {
    type: "object",
    properties: {
      codigo_suap: turmaJsonSchema.properties.codigo_suap,
      descricao: turmaJsonSchema.properties.descricao,
      curso: turmaJsonSchema.properties.curso,
    }
  },
  TurmaListagem: {
    ...deepCopy(turmaJsonSchema),
    description: "Schema para listagem de usuários"
  },
  TurmaDetalhes: {
    ...deepCopy(turmaJsonSchema),
    description: "Schema para detalhes de um usuário"
  },
  TurmaPost: {
    ...deepCopy(turmaJsonSchema),
    description: "Schema para criação de usuário"
  },
  TurmaPutPatch: {
    ...deepCopy(turmaJsonSchema),
    required: [],
    description: "Schema para atualização de usuário"
  }
};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  TurmaListagem: ['__v'],
  TurmaDetalhes: ['__v'],
  TurmaPost: ['createdAt', 'updatedAt', '__v', '_id'],
  TurmaPutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
};

// Aplica a remoção de campos de forma individual a cada schema
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (turmasSchemas[schemaKey]) {
    removeFieldsRecursively(turmasSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detectar referências automaticamente
const turmaMongooseSchema = Turma.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para detecção de referências
turmasSchemas.TurmaListagem.example = await generateExample(turmasSchemas.TurmaListagem, null, turmaMongooseSchema);
turmasSchemas.TurmaDetalhes.example = await generateExample(turmasSchemas.TurmaDetalhes, null, turmaMongooseSchema);
turmasSchemas.TurmaPost.example = await generateExample(turmasSchemas.TurmaPost, null, turmaMongooseSchema);
turmasSchemas.TurmaPutPatch.example = await generateExample(turmasSchemas.TurmaPutPatch, null, turmaMongooseSchema);

export default turmasSchemas;

===== ./docs/schemas/unidadesSchema.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Unidade from '../../models/Unidade.js';
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir do schema do modelo Unidade
const unidadeJsonSchema = Unidade.schema.jsonSchema();

// Remove o campo __v da representação original, se existir
delete unidadeJsonSchema.properties.__v;

// Compondo os diferentes contratos da API utilizando cópias profundas do schema gerado
const unidadesSchemas = {
    UnidadeFiltro: {
        type: "object",
        properties: {
            nome: unidadeJsonSchema.properties.nome,
            localidade: unidadeJsonSchema.properties.localidade,
            ativo: unidadeJsonSchema.properties.ativo,
        }
    },
    UnidadeListagem: {
        ...deepCopy(unidadeJsonSchema),
        required: [],
        description: "Schema para listagem de unidades"
    },
    UnidadeDetalhes: {
        ...deepCopy(unidadeJsonSchema),
        required: [],
        description: "Schema para detalhes de uma unidade"
    },
    UnidadePost: {
        ...deepCopy(unidadeJsonSchema),
        required: ["nome", "localidade"],
        description: "Schema para criação de unidade"
    },
    UnidadePostResposta: {
        ...deepCopy(unidadeJsonSchema),
        required: [],
        description: "Schema de resposta para criação de unidade"
    },
    UnidadePutPatch: {
        ...deepCopy(unidadeJsonSchema),
        required: [],
        description: "Schema para atualização de unidade"
    },
};

// Define, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
    UnidadeListagem: ['createdAt', 'updatedAt', '__v'],
    UnidadeDetalhes: ['createdAt', 'updatedAt', '__v'],
    UnidadePost: ['createdAt', 'updatedAt', '__v', '_id'],
    UnidadePutPatch: ['createdAt', 'updatedAt', '__v', '_id'],
    UnidadePostResposta: ['createdAt', 'updatedAt', '__v'],
};

// Aplica a remoção de campos conforme o mapping definido
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
    if (unidadesSchemas[schemaKey]) {
        removeFieldsRecursively(unidadesSchemas[schemaKey], fields);
    }
});

// Utiliza o schema do Mongoose para detecção automática de referências
const unidadeMongooseSchema = Unidade.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose
unidadesSchemas.UnidadeListagem.example = await generateExample(unidadesSchemas.UnidadeListagem, null, unidadeMongooseSchema);
unidadesSchemas.UnidadeDetalhes.example = await generateExample(unidadesSchemas.UnidadeDetalhes, null, unidadeMongooseSchema);
unidadesSchemas.UnidadePost.example = await generateExample(unidadesSchemas.UnidadePost, null, unidadeMongooseSchema);
unidadesSchemas.UnidadePutPatch.example = await generateExample(unidadesSchemas.UnidadePutPatch, null, unidadeMongooseSchema);
unidadesSchemas.UnidadePostResposta.example = await generateExample(unidadesSchemas.UnidadePostResposta, null, unidadeMongooseSchema);

export default unidadesSchemas;

===== ./docs/schemas/usuariosSchema.js =====


===== # =====


===== separador =====


===== legível =====

// schemas/usuariosSchemas.js
import mongoose from 'mongoose';
import mongooseSchemaJsonSchema from 'mongoose-schema-jsonschema';
import removeFieldsRecursively from '../../utils/swagger_utils/removeFields.js';
import Usuario from '../../models/Usuario.js';
import Grupo from '../../models/Grupo.js';
import Unidade from '../../models/Unidade.js';


// Importa as funções utilitárias separadas
import { deepCopy, generateExample } from '../utils/schemaGenerate.js';

// Registra o plugin para que o Mongoose ganhe o método jsonSchema()
mongooseSchemaJsonSchema(mongoose);

// Gera o JSON Schema a partir dos schemas dos modelos
const usuarioJsonSchema = Usuario.schema.jsonSchema();
const grupoJsonSchema = Grupo.schema.jsonSchema();
const unidadeJsonSchema = Unidade.schema.jsonSchema();

// Remove campos que não queremos na base original
delete usuarioJsonSchema.properties.__v;

// Componha os diferentes contratos da sua API utilizando cópias profundas dos schemas
const usuariosSchemas = {
  UsuarioFiltro: {
    type: "object",
    properties: {
      nome: usuarioJsonSchema.properties.nome,
      email: usuarioJsonSchema.properties.email,
      ativo: usuarioJsonSchema.properties.ativo,
      grupo: grupoJsonSchema.properties.nome,
      unidade: unidadeJsonSchema.properties.nome,
    }
  },
  UsuarioListagem: {
    ...deepCopy(usuarioJsonSchema),
    description: "Schema para listagem de usuários"
  },
  UsuarioDetalhes: {
    ...deepCopy(usuarioJsonSchema),
    description: "Schema para detalhes de um usuário"
  },
  UsuarioPost: {
    ...deepCopy(usuarioJsonSchema),
    description: "Schema para criação de usuário"
  },
  UsuarioPutPatch: {
    ...deepCopy(usuarioJsonSchema),
    required: [],
    description: "Schema para atualização de usuário"
  },
  UsuarioLogin: {
    ...deepCopy(usuarioJsonSchema),
    required: ["email", "senha"],
    description: "Schema para login de usuário"
  },
  UsuarioRespostaLogin: {
    ...deepCopy(usuarioJsonSchema),
    description: "Schema para resposta de login de usuário"
  },

};

// Mapeamento para definir, de forma individual, quais campos serão removidos de cada schema
const removalMapping = {
  UsuarioListagem: ['accesstoken', 'refreshtoken', 'tokenUnico', 'senha'],
  UsuarioDetalhes: ['accesstoken', 'tokenUnico', 'refreshtoken', 'senha'],
  UsuarioPost: ['accesstoken', 'refreshtoken', 'tokenUnico', 'createdAt', 'updatedAt', '__v', '_id', 'senha'],
  UsuarioPutPatch: ['accesstoken', 'refreshtoken', 'tokenUnico', 'senha', 'email', 'createdAt', 'updatedAt', '__v', '_id'],
  UsuarioLogin: ['tokenUnico', 'senha', '__v', '_id'],
  UsuarioRespostaLogin: ['tokenUnico', 'senha', 'createdAt', 'updatedAt', '__v'],
};

// Aplica a remoção de campos de forma individual a cada schema
Object.entries(removalMapping).forEach(([schemaKey, fields]) => {
  if (usuariosSchemas[schemaKey]) {
    removeFieldsRecursively(usuariosSchemas[schemaKey], fields);
  }
});

// Utiliza o schema do Mongoose para detectar referências automaticamente
const usuarioMongooseSchema = Usuario.schema;

// Gera os exemplos automaticamente para cada schema, passando o schema do Mongoose para detecção de referências
usuariosSchemas.UsuarioListagem.example = await generateExample(usuariosSchemas.UsuarioListagem, null, usuarioMongooseSchema);
usuariosSchemas.UsuarioDetalhes.example = await generateExample(usuariosSchemas.UsuarioDetalhes, null, usuarioMongooseSchema);
usuariosSchemas.UsuarioPost.example = await generateExample(usuariosSchemas.UsuarioPost, null, usuarioMongooseSchema);
usuariosSchemas.UsuarioPutPatch.example = await generateExample(usuariosSchemas.UsuarioPutPatch, null, usuarioMongooseSchema);
usuariosSchemas.UsuarioLogin.example = await generateExample(usuariosSchemas.UsuarioLogin, null, usuarioMongooseSchema);
usuariosSchemas.UsuarioRespostaLogin.example = await generateExample(usuariosSchemas.UsuarioRespostaLogin, null, usuarioMongooseSchema);



export default usuariosSchemas;

===== ./docs/utils/schemaGenerate.js =====


===== # =====


===== separador =====


===== legível =====

// utils/schemaUtils.js
import mongoose from 'mongoose';
import getGlobalFakeMapping from '../../seeds/globalFakeMapping.js';

/**
 * Realiza uma cópia profunda do objeto.
 */
export function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Verifica se o campo é um array de referência com base no schema do Mongoose.
 * @param {string} key - Nome do campo.
 * @param {mongoose.Schema} mongooseSchema - Schema do modelo do Mongoose.
 */
export function isRefField(key, mongooseSchema) {
  const path = mongooseSchema.path(key);
  return !!(
    path &&
    path.instance === 'Array' &&
    path.caster &&
    path.caster.options &&
    path.caster.options.ref
  );
}

/**
 * Gera um exemplo recursivamente a partir do JSON Schema, utilizando o mapeamento global para campos específicos.
 * Esta versão é assíncrona para aguardar a resolução do mapping.
 * @param {object} schema - O JSON Schema.
 * @param {string|null} key - Nome do campo atual (opcional).
 * @param {mongoose.Schema|null} mongooseSchema - Schema do modelo do Mongoose para detectar referências (opcional).
 */
export async function generateExample(schema, key = null, mongooseSchema = null) {
  // Se já houver um exemplo definido no schema, retorna-o
  if (schema.example !== undefined) {
    return schema.example;
  }

  // Obtém o mapping global resolvido
  const mapping = await getGlobalFakeMapping();

  // Se existir um gerador para o campo, utiliza-o para gerar um exemplo realista
  if (key && mapping[key]) {
    const generator = mapping[key];
    return typeof generator === 'function' ? generator() : generator;
  }

  // Se a propriedade for "_id", gera um ObjectId válido
  if (key === '_id') {
    return new mongoose.Types.ObjectId().toString();
  }

  // Se o schema for do tipo "object", gera exemplo para cada propriedade recursivamente
  if (schema.type === "object" && schema.properties) {
    const example = {};
    for (const [propKey, propertySchema] of Object.entries(schema.properties)) {
      example[propKey] = await await generateExample(propertySchema, propKey, mongooseSchema);
    }
    return example;
  }

  // Se for um array
  if (schema.type === "array" && schema.items) {
    // Se o campo for um array de referência, detectado automaticamente
    if (key && mongooseSchema && isRefField(key, mongooseSchema)) {
      return [
        { _id: new mongoose.Types.ObjectId().toString() },
        { _id: new mongoose.Types.ObjectId().toString() }
      ];
    }
    return [await await generateExample(schema.items, null, mongooseSchema)];
  }

  // Valores padrão para tipos primitivos
  if (schema.type === "string") {
    return "exemplo string";
  }
  if (schema.type === "number" || schema.type === "integer") {
    return 0;
  }
  if (schema.type === "boolean") {
    return true;
  }
  return null;
}

===== ./middlewares/asyncWrapper.js =====


===== # =====


===== separador =====


===== legível =====

// src/middleware/asyncWrapper.js

const asyncWrapper = (handler) => {
    return (req, res, next) => {
        Promise.resolve(handler(req, res, next)).catch(next);
    };
};

export default asyncWrapper;
===== ./middlewares/AuthMiddleware.js =====


===== # =====


===== separador =====


===== legível =====

// src/middlewares/AuthMiddleware.js
import jwt from 'jsonwebtoken';
import { promisify } from 'util';
import AuthenticationError from '../utils/errors/AuthenticationError.js';
import TokenExpiredError from '../utils/errors/TokenExpiredError.js';
import { CustomError } from '../utils/helpers/index.js';
import AuthService from '../services/AuthService.js';

class AuthMiddleware {
  constructor() {
    this.service = new AuthService();

    /**
     * Vinculação para grantir ao método handle o contexto 'this' correto
     * Ao usar bind(this) no método handle garantimos independentemente de como ou onde o método é chamado, 
     * this sempre se referirá à instância atual de AuthMiddleware.
     */
    this.handle = this.handle.bind(this);
  }

  async handle(req, res, next) {
    try {
      const authHeader = req.headers.authorization;

      if (!authHeader) {
        throw new AuthenticationError("O token de autenticação não existe!");
      }

      const [scheme, token] = authHeader.split(' ');

      if (scheme !== 'Bearer' || !token) {
        throw new AuthenticationError("Formato do token de autenticação inválido!");
      }

      // Verifica e decodifica o token
      const decoded = await promisify(jwt.verify)(token, process.env.JWT_SECRET);

      if (!decoded) { // Se não ocorrer a decodificação do token
        throw new TokenExpiredError("O token JWT está expirado!");
      }

      // Verifica se o refreshtoken está presente no banco de dados e se é válido
      const tokenData = await this.service.carregatokens(decoded.id);

      if (!tokenData?.data?.refreshtoken) {
        throw new CustomError({
          statusCode: 401,
          errorType: 'unauthorized',
          field: 'Token',
          details: [],
          customMessage: 'Refresh token inválido, autentique novamente!'
        });
      }

      // Se o token for válido, anexa o user_id à requisição
      req.user_id = decoded.id;
      next();

    } catch (err) {
      if (err.name === 'JsonWebTokenError') {
        next(new AuthenticationError("Token JWT inválido!"));
      } else if (err.name === 'TokenExpiredError') {
        next(new TokenExpiredError("O token JWT está expirado!"));
      } else {
        next(err); // Passa outros erros para o errorHandler
      }
    }
  }
}

// Instanciar e exportar apenas o método 'handle' como função de middleware
export default new AuthMiddleware().handle;

===== ./middlewares/AuthPermission.js =====


===== # =====


===== separador =====


===== legível =====

// middlewares/AuthPermission.js

import jwt from 'jsonwebtoken';
import PermissionService from '../services/PermissionService.js';
import Rota from '../models/Rota.js';
import { CustomError, errorHandler, messages } from '../utils/helpers/index.js';

// Certifique-se de que as variáveis de ambiente estejam carregadas
const JWT_SECRET = process.env.JWT_SECRET;

class AuthPermission {
  constructor() {
    this.jwt = jwt;
    this.permissionService = new PermissionService();
    this.Rota = Rota;
    this.JWT_SECRET = JWT_SECRET;
    this.messages = messages;
    

    // Vincula o método handle ao contexto da instância
    this.handle = this.handle.bind(this);
  }

  async handle(req, res, next) {
    try {
      // 1. Extrai o token do cabeçalho Authorization
      const authHeader = req.headers.authorization;

      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        throw new CustomError({
          statusCode: 401,
          errorType: 'authenticationError',
          field: 'Authorization',
          details: [],
          customMessage: this.messages.error.resourceNotFound('Token')
        });
      }

      const token = authHeader.split(' ')[1];

      // 2. Verifica e decodifica o token
      let decoded;
      try {
        decoded = this.jwt.verify(token, this.JWT_SECRET);
      } catch (err) {
        throw new CustomError({
          statusCode: 401,
          errorType: 'authenticationError',
          field: 'Token',
          details: [],
          customMessage: this.messages.error.resourceNotFound('Token')
        });
      }
      const userId = decoded.id;

      /**
       * 3. Determina a rota e o domínio da requisição
       * Remove barras iniciais e finais, remove query strings e pega a primeira parte da URL
       */
      const rotaReq = req.url.split('/').filter(Boolean)[0].split('?')[0];

      const dominioReq = `localhost`; // domínio foi colocado como localhost para fins de teste

      // 4. Busca a rota atual no banco de dados
      const rotaDB = await this.Rota.findOne({ rota: rotaReq, dominio: dominioReq });
      if (!rotaDB) {
        throw new CustomError({
          statusCode: 404,
          errorType: 'resourceNotFound',
          field: 'Rota',
          details: [],
          customMessage: this.messages.error.resourceNotFound('Rota')
        });
      }

      // 5. Mapeia o método HTTP para o campo de permissão correspondente
      const metodoMap = {
        'GET': 'buscar',
        'POST': 'enviar',
        'PUT': 'substituir',
        'PATCH': 'modificar',
        'DELETE': 'excluir'
      };

      const metodo = metodoMap[req.method];
      if (!metodo) {
        throw new CustomError({
          statusCode: 405,
          errorType: 'methodNotAllowed',
          field: 'Método',
          details: [],
          customMessage: this.messages.error.resourceNotFound('Método.')
        });
      }

      // 6. Verifica se a rota está ativa e suporta o método
      if (!rotaDB.ativo || !rotaDB[metodo]) {
        throw new CustomError({
          statusCode: 403,
          errorType: 'forbidden',
          field: 'Rota',
          details: [],
          customMessage: this.messages.error.resourceNotFound('Rota.')
        });
      }

      // 7. Verifica se o usuário tem permissão
      const hasPermission = await this.permissionService.hasPermission(
        userId,
        rotaReq.toLowerCase(),
        rotaDB.dominio,
        metodo
      );

      if (!hasPermission) {
        throw new CustomError({
          statusCode: 403,
          errorType: 'forbidden',
          field: 'Permissão',
          details: [],
          customMessage: this.messages.error.resourceNotFound('Permissão')
        });
      }

      // 8. Anexa o usuário ao objeto de requisição para uso posterior
      req.user = { id: userId };

      // 9. Permite a continuação da requisição
      next();
    } catch (error) {
      // Utilize o handler de erros personalizado
      errorHandler(error, req, res, next);
    }
  }
}

// Instanciar e exportar apenas o método 'handle' como função de middleware
export default new AuthPermission().handle;

===== ./middlewares/csvFileValidator.js =====


===== # =====


===== separador =====


===== legível =====

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import getFirstLine from "../utils/getFirstLine.js";

export default async (req, res, next) => {
  try {
    //Verificar se foi enviado algum arquivo
    if (!req.file) {
      return res.status(400).json({ message: "Nenhum Arquivo Enviado!" });
    }

    // Pegar o local do arquivo
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const filePath = path.join(
      __dirname,
      "..",
      "..",
      "uploads",
      `${req.file.filename}`
    );
    
    // Verificar se o arquivo é um CSV
    if (req.file.mimetype !== "text/csv") {
      fs.unlinkSync(filePath);
      return res
        .status(400)
        .json({ message: "O arquivo enviado não é um CSV!" });
    }

    // Verificar se o cabeçalho do arquivo está correto
    const cabecalho = await getFirstLine(filePath);

    if(!(cabecalho.includes("aluno") && cabecalho.includes("matricula") && cabecalho.includes("turma"))){
      fs.unlinkSync(filePath);
      return res.status(400).json({ message: "O cabeçalho do arquivo CSV está incorreto!\nVerifique se tem os campos necessários(turma,aluno,matricula) e se os campos do cabeçalho estão todos em minusculo e sem acentos." });
    }


    return next();
  } catch (error) {
    res
      .status(500)
      .json({ message: "Ocorreu um erro no sistema!" + error.message });
  }
};

===== ./middlewares/LogRoutesMiddleware.js =====


===== # =====


===== separador =====


===== legível =====


const logRoutes = async (req, res, next) => {
    try {
        const timestamp = new Date().toISOString();

        let ip = req.headers["x-forwarded-for"] ||
            req.socket.remoteAddress ||
            null;

        console.log(timestamp + " " + ip + " " + req.method + " " + req.protocol + "://" + req.get("host") + req.originalUrl);
    } catch (e) {
        console.log("Erro ao fazer o log", e);
    }
    next();
};

export default logRoutes;
===== ./models/Curso.js =====


===== # =====


===== separador =====


===== legível =====

// /src/models/Curso.js

import mongoose from "mongoose";
import mongoosePaginate from 'mongoose-paginate-v2';

class Curso {
  constructor() {
    const cursoSchema = new mongoose.Schema(
      {
        codigo: { type: String, required: [true, "O codigo do curso é obrigatório!"] },
        nome: { type: String, ndex: true, required: [true, "O nome do curso é obrigatório!"] },
        contra_turnos: {
          type: {
            segunda: { type: Boolean, required: true, default: false },
            terca: { type: Boolean, required: true, default: false },
            quarta: { type: Boolean, required: true, default: false },
            quinta: { type: Boolean, required: true, default: false },
            sexta: { type: Boolean, required: true, default: false },
            sabado: { type: Boolean, required: true, default: false },
            domingo: { type: Boolean, required: true, default: false },
          }, required: [true, "Os contra-turnos são obrigatórios!"],
          _id: false
        },
      },
      {
        timestamps: true,
        versionKey: false
      }
    );
    cursoSchema.plugin(mongoosePaginate);
    this.model = mongoose.model('cursos', cursoSchema);
  }
}
export default new Curso().model;
===== ./models/Estagio.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from "mongoose";
import mongoosePaginate from "mongoose-paginate-v2";
import Estudante from "./Estudante.js"; //Se não tiver o populate falha

class Estagio {
    constructor() {
        const schema = new mongoose.Schema({
            descricao: { type: String },
            estudante: {
                type: mongoose.Schema.Types.ObjectId,
                ref: "estudantes",
                required: [true, "O estudante é obrigatório!"]
            },
            data_inicio: { type: Date, required: [true, "A data de início é obrigatória!"] },
            data_termino: { type: Date, required: [true, "A data de término é obrigatória!"] },
            contra_turnos: {
                type: {
                  segunda: { type: Boolean, required: true, default: false },
                  terca: { type: Boolean, required: true, default: false },
                  quarta: { type: Boolean, required: true, default: false },
                  quinta: { type: Boolean, required: true, default: false },
                  sexta: { type: Boolean, required: true, default: false },
                  sabado: { type: Boolean, required: true, default: false },
                  domingo: { type: Boolean, required: true, default: false },
                }, required: [true, "Os contra-turnos são obrigatórios!"],
                _id: false
              },
            status: {
                type: String,
                enum: {
                    values: ["ativo", "inativo", "cancelado", "suspenso"],
                    message: "O valor tem quer ser ativo, inativo, cancelado ou suspenso"
                }
            }
        }, {
            timestamps: true,      // Registra createdAt e updatedAt automaticamente
            versionKey: false
        });

        schema.plugin(mongoosePaginate);
        this.model = mongoose.model("estagios", schema);
    }
}

export default new Estagio().model;

===== ./models/Estudante.js =====


===== # =====


===== separador =====


===== legível =====

import { ObjectId } from "mongodb";
import mongoose from "mongoose";
import mongoosePaginate from "mongoose-paginate-v2";
import Turma from "./Turma.js"; //Se não tiver o populate falha

class Estudante {
  constructor() {
    const schema = new mongoose.Schema(
      {
        matricula: { type: String, required: true },
        nome: { type: String, required: true },
        ativo: { type: Boolean, required: true, default: true },
        cursos_id: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "cursos",
          required: true
        },
        turma_id: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "turmas",
          required: true
        },
      },
      { timestamps: true, versionKey: false }
    );

    schema.plugin(mongoosePaginate);
    this.model = mongoose.model("estudantes", schema);
  }
}

export default new Estudante().model;
===== ./models/Grupo.js =====


===== # =====


===== separador =====


===== legível =====

// models/Grupo.js
import mongoose from "mongoose";
import mongoosePaginate from 'mongoose-paginate-v2';
import Unidade from './Unidade.js'; // Importa o modelo Unidade para referência

class Grupo {
    constructor( ) {
        const grupoSchema = new mongoose.Schema(
            {
                nome: { type: String, index: true, required: true, unique: true },
                descricao: { type: String, required: true },
                ativo: { type: Boolean, default: true },
                unidades: [
                    {
                        type: mongoose.Schema.Types.ObjectId,
                        ref: 'unidades'
                    }
                ],
                /**
                 * Permissões personalizadas para cada rota, a rota e o domínio 
                 * devem ser únicos e conrrespondentes a rota e domínio do sistema em /rotas
                 */
                permissoes: [
                    {
                        rota: { type: String, index: true, required: true }, // usuários / grupos / unidades / rotas
                        dominio: { type: String }, // http://localhost:3000
                        ativo: { type: Boolean, default: false },  // false
                        buscar: { type: Boolean, default: false },    // false
                        enviar: { type: Boolean, default: false },   // false
                        substituir: { type: Boolean, default: false },    // false
                        modificar: { type: Boolean, default: false },  // false
                        excluir: { type: Boolean, default: false }, // false
                    }
                ],
            },
            {
                timestamps: true,
                versionKey: false
            }
        );

        // Validação personalizada para garantir que rota + dominio sejam únicos dentro do grupo
        grupoSchema.pre('save', function (next) {
            const permissoes = this.permissoes;
            const combinacoes = permissoes.map(p => `${p.rota}_${p.dominio}`);
            const setCombinacoes = new Set(combinacoes);

            if (combinacoes.length !== setCombinacoes.size) {
                return next(new Error('Permissões duplicadas encontradas: rota + domínio devem ser únicos dentro de cada grupo.'));
            }

            next();
        });

        grupoSchema.plugin(mongoosePaginate);

        this.model = mongoose.model('grupos', grupoSchema);
    }
}

export default new Grupo().model;
===== ./models/Projeto.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from "mongoose";
import mongoosePaginate from "mongoose-paginate-v2";
import Estudante from "./Estudante.js"; //Se não tiver o populate falha

class Projeto {
  constructor() {
    const schema = new mongoose.Schema(
      {
        descricao: { type: String, required: [true, "O nome do projeto é obrigatório!"] },
        professor_responsavel: {type: String, required: [true, "O professor é obrigatório!"]},
        data_inicio: { type: Date, required: [true, "A data de início é obrigatória!"] },
        data_termino: { type: Date, required: [true, "A data de término é obrigatória!"] },
      
        contra_turnos: {
          type: {
            segunda: { type: Boolean, required: true, default: false },
            terca: { type: Boolean, required: true, default: false },
            quarta: { type: Boolean, required: true, default: false },
            quinta: { type: Boolean, required: true, default: false },
            sexta: { type: Boolean, required: true, default: false },
            sabado: { type: Boolean, required: true, default: false },
            domingo: { type: Boolean, required: true, default: false },
          }, required: [true, "Os contra-turnos são obrigatórios!"],
          _id: false
        },
        lista_estudantes: [
          {
            estudante: {
              type: mongoose.Schema.Types.ObjectId,
              ref: "estudantes",
              required: true
            },
            ativo: { type: Boolean, required: true, default: true },
          }
        ],
      },
      { timestamps: true, versionKey: false }
    );

    schema.plugin(mongoosePaginate);
    this.model = mongoose.model("projetos", schema);
  }
}

export default new Projeto().model;

===== ./models/Refeicao.js =====


===== # =====


===== separador =====


===== legível =====

// /src/models/Refeicao.js

import mongoose from "mongoose";
import mongoosePaginate from "mongoose-paginate-v2";
import Estudante from "./Estudante.js"; //Se não tiver o populate falha
import Usuario from "./Usuario.js"; //Se não tiver o populate falha

class Refeicao {
  constructor() {
    const schema = new mongoose.Schema(
      {
        estudante: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "estudantes",
          required: true
        },
        data: { type: Date, required: true },
        tipoRefeicao: { type: String, required: true, enum : ["contra-turno-curso", "ruma", "projeto", "estágio"] },
        usuarioRegistrou: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "usuarios",
          required: true
        }
      },
      { timestamps: true, versionKey: false }
    );

    schema.plugin(mongoosePaginate);
    this.model = mongoose.model("refeicoes", schema);
  }
}

export default new Refeicao().model;
===== ./models/RefeicaoTurma.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from "mongoose";
import mongoosePaginate from "mongoose-paginate-v2";
import Turma from "./Turma.js"; //Se não tiver o populate falha


class RefeicaoTurma {
    constructor() {
        const schema = new mongoose.Schema(
            {
                turma: {
                    type: mongoose.Schema.Types.ObjectId,
                    ref: "turmas",
                    required: [true, "A turma é obrigatória!"]
                },
                data_inicial: { type: Date, required: [true, "Uma data é obrigatória!"] },
                data_final: { type: Date, required: [true, "Uma data é obrigatória!"] },
                contra_turnos: {
                    type: {
                      segunda: { type: Boolean, required: true, default: false },
                      terca: { type: Boolean, required: true, default: false },
                      quarta: { type: Boolean, required: true, default: false },
                      quinta: { type: Boolean, required: true, default: false },
                      sexta: { type: Boolean, required: true, default: false },
                      sabado: { type: Boolean, required: true, default: false },
                      domingo: { type: Boolean, required: true, default: false },
                    }, required: [true, "Os contra-turnos são obrigatórios!"],
                    _id: false
                  },
            },
            { timestamps: true, versionKey: false }
        );

        schema.plugin(mongoosePaginate);
        this.model = mongoose.model("refeicoesTurmas", schema);
    }
}

export default new RefeicaoTurma().model;

===== ./models/Rota.js =====


===== # =====


===== separador =====


===== legível =====

// models/Rota.js
import mongoose from "mongoose";
import mongoosePaginate from 'mongoose-paginate-v2';

class Rota {
    constructor() {
        const rotaSchema = new mongoose.Schema(
            {
                rota: { type: String, index: true, required: true, trim: true, lowercase: true },
                dominio: { type: String, required: true },
                ativo: { type: Boolean, default: false },  // false
                buscar: { type: Boolean, default: false },    // false
                enviar: { type: Boolean, default: false },   // false
                substituir: { type: Boolean, default: false },    // false
                modificar: { type: Boolean, default: false },  // false
                excluir: { type: Boolean, default: false }, // falseæ
            },
            { timestamps: true }
        );

        // Adiciona a restrição de unicidade para o campo 'rota' + 'dominio'
        rotaSchema.index({ rota: 1, dominio: 1 }, { unique: true });

        // Plugin de paginação
        rotaSchema.plugin(mongoosePaginate);

        // Hook para garantir que o campo 'rota' está em minúsculas antes de salvar
        rotaSchema.pre('save', function (next) {
            if (this.rota) {
                this.rota = this.rota.toLowerCase();
            }
            next();
        });

        this.model = mongoose.model('rotas', rotaSchema);
    }
}

export default new Rota().model;

===== ./models/Turma.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from "mongoose";
import mongoosePaginate from "mongoose-paginate-v2";
import Curso from "./Curso.js"; //Se não tiver o populate falha

class Turma {
    constructor() {
        const schema = new mongoose.Schema(
            {
                codigo_suap: { type: String, required: [true, "Um código do SUAP é obrigatório!"] },
                descricao: { type: String, required: [true, "Uma descrição é obrigatória!"] },
                curso: {
                    type: mongoose.Schema.Types.ObjectId,
                    ref: "cursos",
                    required: [true, "Um id de curso é obrigatório!"]
                }
            },
            { timestamps: true, versionKey: false }
        );

        schema.plugin(mongoosePaginate);
        this.model = mongoose.model("turmas", schema);
    }
}

export default new Turma().model;

===== ./models/Unidade.js =====


===== # =====


===== separador =====


===== legível =====

// src/models/Unidade.js

import mongoose from 'mongoose';
import mongoosePaginate from 'mongoose-paginate-v2';

class Unidade {
    constructor() {
        const unidadeSchema = new mongoose.Schema(
            {
                nome: { type: String, index: true, required: true, trim: true },
                localidade: { type: String, required: true, trim: true },
                ativo: { type: Boolean, default: true }
            },
            {
                timestamps: true,
                versionKey: false
            }
        );

        // Índice composto para garantir a unicidade de 'nome' e 'localidade'
        unidadeSchema.index({ nome: 1, localidade: 1 }, { unique: true });

        // Plugin de paginação
        unidadeSchema.plugin(mongoosePaginate);
        this.model = mongoose.model('unidades', unidadeSchema);
    }
}

export default new Unidade().model;

===== ./models/Usuario.js =====


===== # =====


===== separador =====


===== legível =====

// models/Usuario.js
import mongoose from "mongoose";
import mongoosePaginate from 'mongoose-paginate-v2';
import Grupo from './Grupo.js';
import Unidade from './Unidade.js';

class Usuario {
  constructor() {
    const usuarioSchema = new mongoose.Schema(
      {
        nome: { type: String, index: true, required: true },
        email: { type: String, unique: true, required: true },
        senha: { type: String, select: false },
        link_foto: { type: String },
        ativo: { type: Boolean, default: false },
        tokenUnico: { type: String, select: false }, // token único para recuperação de senha
        refreshtoken: { type: String, select: false }, // Refresh token para geração de access token de autenticação longa duração 7 dias para invalidação
        accesstoken: { type: String, select: false }, // Refresh token para  autenticação curta longa 15 minutos para invalidação
        // Referências para Unidades
        unidades: [
          {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'unidades'
          }
        ],

        // Referências para Grupos
        grupos: [
          {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'grupos',
          }
        ],

        /**
         * Permissões personalizadas para cada rota, a rota e o domínio 
         * devem ser únicos e conrrespondentes a rota e domínio do sistema em /rotas
         */
        permissoes: [
          {
            rota: { type: String, index: true, required: true }, // usuários / grupos / unidades / rotas
            dominio: { type: String }, // http://localhost:3000
            ativo: { type: Boolean, default: false },  // false
            buscar: { type: Boolean, default: false },    // false
            enviar: { type: Boolean, default: false },   // false
            substituir: { type: Boolean, default: false },    // false
            modificar: { type: Boolean, default: false },  // false
            excluir: { type: Boolean, default: false }, // false
          }
        ],
      },
      {
        timestamps: true,
        versionKey: false
      }
    );

    // Validação personalizada para garantir que rota + dominio sejam únicos dentro do usuário isso tbm vai ser feito pelo ZOD
    usuarioSchema.pre('save', function (next) {
      const permissoes = this.permissoes;
      const combinacoes = permissoes.map(p => `${p.rota}_${p.dominio}`);
      const setCombinacoes = new Set(combinacoes);

      if (combinacoes.length !== setCombinacoes.size) {
        return next(new Error('Permissões duplicadas encontradas: rota + domínio devem ser únicos dentro de cada usuário.'));
      }

      next();
    });

    usuarioSchema.plugin(mongoosePaginate);

    this.model = mongoose.model('usuarios', usuarioSchema);
  }
}

export default new Usuario().model;

===== ./repositories/AuthRepository.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from 'mongoose';
import UsuarioModel from '../models/Usuario.js';
import GrupoModel from '../models/Grupo.js';
import UnidadeModel from '../models/Unidade.js';
import RotaModel from '../models/Rota.js';
import { CustomError, messages } from '../utils/helpers/index.js';

class AuthRepository {
    constructor({
        usuarioModel = UsuarioModel,
        grupoModel = GrupoModel,
        unidadeModel = UnidadeModel,
        rotaModel = RotaModel
    } = {}) {
        this.model = usuarioModel;
        this.grupoModel = grupoModel;
        this.unidadeModel = unidadeModel;
        this.rotaModel = rotaModel;
    }

    /**
     * Armazenar accesstoken e refreshtoken no banco de dados
     */
    async armazenarTokens(id, accesstoken, refreshtoken) {
        const documento = await this.model.findById(id);
        if (!documento) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Usuário',
                details: [],
                customMessage: messages.error.resourceNotFound('Usuário')
            });
        }
        documento.accesstoken = accesstoken;
        documento.refreshtoken = refreshtoken;
        const data = await documento.save();
        return data;
    }

    /**
     * Atualizar usuário removendo accesstoken e refreshtoken
     */
    async removeToken(id) {
        // Criar objeto com os campos a serem atualizados
        const parsedData = {
            accesstoken: null,
            refreshtoken: null
        };
        const usuario = await this.model.findByIdAndUpdate(id, parsedData, { new: true }).exec();

        // Validar se o usuário atualizado foi retornado
        if (!usuario) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Usuário',
                details: [],
                customMessage: messages.error.resourceNotFound('Usuário')
            });
        }
        return usuario;
    }
}

export default AuthRepository;

===== ./repositories/CursoRepository.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/CursoRepository.js

import mongoose from 'mongoose';
import mongoosePaginate from 'mongoose-paginate-v2';
import CursoModel from '../models/Curso.js';
import CursoFilterBuilder from './filters/CursoFilterBuilder.js';
import { CustomError, messages } from '../utils/helpers/index.js';

class CursoRepository {
    constructor({
        model = CursoModel
    } = {}) {
        this.model = model;
    }

    async listar(req) {
        console.log('Listando cursos em CursoRepository');

        const { id } = req.params || null;

        if (id) {
            console.log('Buscando curso por ID:', id);

            const data = await this.model.findById(id);
            if (!data) {
                throw new CustomError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Curso',
                    customMessage: messages.error.resourceNotFound('Curso'),
                });
            }
            return data;
        }

        const { nome, codigo, page = 1 } = req.query;
        const limit = Math.min(parseInt(req.query.limite, 10) || 10, 100);

        const filterBuilder = new CursoFilterBuilder()
            .comNome(nome)
            .comCodigo(codigo);

        if (typeof filterBuilder.build !== 'function') {
            throw new CustomError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Curso',
                customMessage: messages.error.internalServerError('Curso'),
            });
        }

        const filtros = filterBuilder.build();

        const options = {
            page: parseInt(page, 10),
            limit: parseInt(limit, 10),
            sort: { nome: 1 },
        };

        return await this.model.paginate(filtros, options)
    }

    async criar(dados) {
        const curso = new this.model(dados);
        return await curso.save();
    }

    async atualizar(id, dados) {
        const curso = await this.model.findByIdAndUpdate(id, dados, { new: true });
        if (!curso) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Curso',
                customMessage: messages.error.resourceNotFound('Curso'),
            });
        }
        return curso;
    }

    async deletar(id) {
        /**
         *  TODO
         * VERIFIQCAR SE O CURSO ESTÁ EM USO EM TURMA 
         * Ùnica referencia no momento da construção deste metodo
         */



        const curso = await this.model.findByIdAndDelete(id);
        return curso;
    }

    async buscarPorId(id) {
        const curso = await this.model.findById(id);
        if (!curso) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Curso',
                customMessage: messages.error.resourceNotFound('Curso'),
            });
        }
        return curso;
    }

    // buscar por nome
    async buscarPorNome(nome, idIgnorado = null) {
        // Criar o filtro base
        const filtro = { nome };

        // Adicionar a condição para excluir o ID, se fornecido
        if (idIgnorado) {
            filtro._id = { $ne: idIgnorado }; // Adiciona a condição _id != idIgnorado
        }

        // Consultar o documento no banco de dados
        const documento = await this.model.findOne(filtro);

        // Retornar o documento encontrado
        return documento;
    }
}

export default CursoRepository;

===== ./repositories/EstudanteRepository.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/EstudanteRepository.js
import EstudanteModel from '../models/Estudante.js';
import { CustomError, messages } from '../utils/helpers/index.js';
import EstudanteFilterBuilder from './filters/EstudanteFilterBuilder.js';

class EstudanteRepository {
    constructor({ model = EstudanteModel } = {}) {
        this.model = model;
    }

    // Método para listar estudantes,
    // podendo buscar por ID ou aplicar filtros de matrícula, nome e turma.
    async listar(req) {
        const { id } = req.params || {};

        // Se vier um ID na rota, retorna apenas o Estudante correspondente
        if (id) {
            const estudante = await this.model.findById(id).populate('turma');
            if (!estudante) {
                throw new CustomError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Estudante',
                    customMessage: messages.error.resourceNotFound('Estudante'),
                });
            }
            return estudante;
        }

        // Se não houver ID, aplicamos filtros
        const { matricula, nome, turma, page = 1 } = req.query;
        const limite = Math.min(parseInt(req.query.limite, 10) || 10, 100);

        const filterBuilder = new EstudanteFilterBuilder()
            .comMatricula(matricula || '')
            .comNome(nome || '');

        // Se for assíncrono, precisamos aguardar
        await filterBuilder.comTurma(turma || '');

        const filtros = filterBuilder.build();

        const options = {
            page: parseInt(page, 10),
            limit: limite,
            populate: 'turma',
            sort: { nome: 1 }, // exemplo de ordenação por nome
        };

        const resultado = await this.model.paginate(filtros, options);
        return resultado;
    }

    // Método para criar um novo Estudante
    async criar(dadosEstudante) {
        const estudante = new this.model(dadosEstudante);
        return await estudante.save();
    }

    // Método para atualizar um Estudante existente
    async atualizar(id, dadosAtualizados) {
        const estudante = await this.model
            .findByIdAndUpdate(id, dadosAtualizados, { new: true })
            .populate('turma');

        if (!estudante) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Estudante',
                customMessage: messages.error.resourceNotFound('Estudante'),
            });
        }
        return estudante;
    }

    // Método para deletar um Estudante
    async deletar(id) {
        return await this.model.findByIdAndDelete(id);
    }

    // Método para buscar Estudante por ID
    async buscarPorId(id) {
        const estudante = await this.model.findById(id).populate('turma');
        if (!estudante) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Estudante',
                customMessage: messages.error.resourceNotFound('Estudante'),
            });
        }
        return estudante;
    }
}

export default EstudanteRepository;

===== ./repositories/filters/CursoFilterBuilder.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/filters/CursoFilterBuilder.js

class CursoFilterBuilder {
    constructor() {
        this.filtros = {};
    }

    comNome(nome) {
        if (nome) {
            this.filtros.nome = { $regex: nome, $options: 'i' };
        }
        return this;
    }

    comCodigo(codigo) {
        if (codigo) {
            this.filtros.codigo = { $regex: codigo, $options: 'i' };
        }
        return this;
    }

    build() {
        return this.filtros;
    }
}

export default CursoFilterBuilder;

===== ./repositories/filters/EstudanteFilterBuilder.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/filters/EstudanteFilterBuilder.js
import { Types } from 'mongoose';
import Turma from '../../models/Turma.js'; // ou utilize um TurmaRepository, caso prefira

class EstudanteFilterBuilder {
  constructor() {
    this.filtros = {};
  }

  // Exemplo de filtro por matrícula (busca case-insensitive)
  comMatricula(matricula) {
    if (matricula) {
      this.filtros.matricula = { $regex: matricula, $options: 'i' };
    }
    return this;
  }

  // Exemplo de filtro por nome (busca case-insensitive)
  comNome(nome) {
    if (nome) {
      this.filtros.nome = { $regex: nome, $options: 'i' };
    }
    return this;
  }

  // Exemplo de filtro por turma. Caso seja um ObjectId válido, filtra diretamente;
  // caso contrário, faz a busca pela turma via código_suap (ou outro campo que desejar).
  async comTurma(turma) {
    if (turma) {
      if (Types.ObjectId.isValid(turma)) {
        // Se já for um ObjectId, faz o populate direto
        this.filtros.turma = turma;
        const turmaEncontrada = await Turma.findById(turma);
        if (!turmaEncontrada) {
          // Caso não exista, força a busca “vazia”
          this.filtros.turma = { $in: [] };
        }
      } else {
        // Se for string, por exemplo código_suap
        const turmaEncontrada = await Turma.findOne({
          codigo_suap: { $regex: turma, $options: 'i' },
        });
        if (turmaEncontrada) {
          this.filtros.turma = turmaEncontrada._id;
        } else {
          // Força a busca “vazia”
          this.filtros.turma = { $in: [] };
        }
      }
    }
    return this;
  }

  // Retorna o objeto de filtros construído
  build() {
    return this.filtros;
  }
}

export default EstudanteFilterBuilder;

===== ./repositories/filters/GrupoFilterBuilder.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/filters/GrupoFilterBuilder.js

import UnidadeRepository from '../UnidadeRepository.js';

class GrupoFilterBuilder {
    constructor() {
        this.filtros = {};
        this.unidadeRepository = new UnidadeRepository();
    }

    comNome(nome) {
        if (nome) {
          const nomeEscapado = this.escapeRegex(nome);
          this.filtros.nome = { $regex: nomeEscapado, $options: 'i' };
        }
        return this;
      }
      
      comDescricao(descricao) {
        if (descricao) {
          const descricaoEscapada = this.escapeRegex(descricao);
          this.filtros.descricao = { $regex: descricaoEscapada, $options: 'i' };
        }
        return this;
      }
      

    comAtivo(ativo) {
        if (ativo === 'true') {
            this.filtros.ativo = true;
        } else if (ativo === 'false') {
            this.filtros.ativo = false;
        } else {
            // Ação executável mínima para cobertura
            this.filtros.ativo = this.filtros.ativo; // No-op
        }
        return this;
    }

    async comUnidade(unidade) {
        if (unidade) {
            const unidadesEncontradas = await this.unidadeRepository.buscarPorNome(unidade);

            const unidadeIds = unidadesEncontradas
                ? Array.isArray(unidadesEncontradas)
                    ? unidadesEncontradas.map(u => u._id)
                    : [unidadesEncontradas._id]
                : [];

            this.filtros.unidades = { $in: unidadeIds };
        }
        return this;
    }

    escapeRegex(texto) {
        return texto.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }

    build() {
        return this.filtros;
    }
}

export default GrupoFilterBuilder;

===== ./repositories/filters/RotaFilterBuilder.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/utils/RotaFilterBuilder.js

class RotaFilterBuilder {
    constructor() {
        this.filtros = {};
    }

    comRota(rota) {
        if (rota) {
            this.filtros.rota = { $regex: rota, $options: 'i' }; // Filtro para rota usando regex (case-insensitive)
        }
        return this;
    }

    comDominio(dominio) {
        if (dominio) {
            this.filtros.dominio = { $regex: dominio, $options: 'i' }; // Filtro para domínio usando regex (case-insensitive)
        }
        return this;
    }

    comAtivo(ativo) {
        if (ativo === 'true') {
            this.filtros.ativo = true;
        } else if (ativo === 'false') {
            this.filtros.ativo = false;
        }
        return this;
    }


    comGet(buscar) {
        if (buscar === 'true') {
            this.filtros.buscar = true;
        } else if (buscar === 'false') {
            this.filtros.buscar = false;
        }
        return this;
    }

    comPost(enviar) {
        if (enviar === 'true') {
            this.filtros.enviar = true;
        } else if (enviar === 'false') {
            this.filtros.enviar = false;
        }
        return this;
    }

    comPut(substituir) {
        if (substituir === 'true') {
            this.filtros.substituir = true;
        } else if (substituir === 'false') {
            this.filtros.substituir = false;
        }
        return this;
    }

    comPatch(modificar) {
        if (modificar === 'true') {
            this.filtros.modificar = true;
        } else if (modificar === 'false') {
            this.filtros.modificar = false;
        }
        return this;
    }

    comDelete(excluir) { // 'delete' é uma palavra reservada, então usamos 'del'
        if (excluir === 'true') {
            this.filtros.excluir = true;
        } else if (excluir === 'false') {
            this.filtros.excluir = false;
        }
        return this;
    }

    build() {
        return this.filtros;
    }
}

export default RotaFilterBuilder;

===== ./repositories/filters/TurmaFilterBuilder.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/TurmaFilterBuilder.js

import CursoRepository from '../../repositories/CursoRepository.js';
import { Types } from 'mongoose';

class TurmaFilterBuilder {
    constructor() {
        this.filtros = {};
        this.cursoRepository = new CursoRepository();
    }

    // Filtra pela propriedade codigo_suap usando regex (busca case-insensitive)
    comCodigoSuap(codigoSuap) {
        if (codigoSuap) {
            this.filtros.codigo_suap = { $regex: codigoSuap, $options: 'i' };
        }
        return this;
    }

    // Filtra pela propriedade descricao usando regex (busca case-insensitive)
    comDescricao(descricao) {
        if (descricao) {
            this.filtros.descricao = { $regex: descricao, $options: 'i' };
        }
        return this;
    }

    // Filtra pela referência de curso. Se o valor for um ObjectID válido, utiliza-o diretamente;
    // caso contrário, faz a busca pelo nome.
    async comCurso(curso) {
        if (curso) {
            console.log('Curso recebido:', curso);
            if (Types.ObjectId.isValid(curso)) {
                console.log('Curso é um ObjectId válido');
                this.filtros.curso = curso;
                const cursoEncontrado = await this.cursoRepository.buscarPorId(curso);
                if (!cursoEncontrado) {
                    this.filtros.curso = { $in: [] };
                }
            } else if (typeof curso === 'string') {
                console.log('Curso é uma string');
                const regexCurso = new RegExp(this.escapeRegex(curso), 'i');
                // Pode inicialmente definir um regex, mas vamos buscar pelo nome
                let cursosEncontrados = await this.cursoRepository.buscarPorNome(curso);
                // Se não for array, converta para array (se for objeto ou outro valor truthy)
                if (cursosEncontrados && !Array.isArray(cursosEncontrados)) {
                    cursosEncontrados = [cursosEncontrados];
                }
                if (cursosEncontrados && cursosEncontrados.length > 0) {
                    this.filtros.curso = { $in: cursosEncontrados.map(c => c._id) };
                } else {
                    this.filtros.curso = { $in: [] };
                }
            }
        }
        return this;
    }



    // Método utilitário para escapar caracteres especiais em regex
    escapeRegex(texto) {
        return texto.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }

    // Retorna o objeto de filtros construído
    build() {
        return this.filtros;
    }
}

export default TurmaFilterBuilder;

===== ./repositories/filters/UnidadeFilterBuilder.js =====


===== # =====


===== separador =====


===== legível =====

import UnidadeModel from '../../models/Unidade.js';

class UnidadeFilterBuilder {
    constructor() {
        this.filtros = {};
    }

    comNome(nome) {
        if (nome) {
            this.filtros.nome = { $regex: nome, $options: 'i' }; // Filtro para nome usando regex (case-insensitive)
        }
        return this;
    }

    comLocalidade(localidade) {
        if (localidade) {
            this.filtros.localidade = { $regex: localidade, $options: 'i' }; // Filtro para localidade usando regex (case-insensitive)
        }
        return this;
    }

    comAtivo(ativo) {
        if (ativo === 'true') {
            this.filtros.ativo = true;
        } else if (ativo === 'false') {
            this.filtros.ativo = false;
        }
        return this;
    }

    build() {
        return this.filtros;
    }
}

export default UnidadeFilterBuilder;

===== ./repositories/filters/UsuarioFilterBuilder.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/UsuarioFilterBuilder.js

import GrupoModel from '../../models/Grupo.js';
import UnidadeModel from '../../models/Unidade.js';
import UsuarioModel from '../../models/Usuario.js';

import UsuarioRepository from '../UsuarioRepository.js';
import GrupoRepository from '../GrupoRepository.js';
import UnidadeRepository from '../UnidadeRepository.js';

class UsuarioFilterBuilder {
    constructor() {
        this.filtros = {};
        this.grupoRepository = new GrupoRepository();
        this.unidadeRepository = new UnidadeRepository();
        this.usuarioRepository = new UsuarioRepository();
        this.grupoModel = GrupoModel;
        this.unidadeModel = UnidadeModel;
        this.usuarioModel = UsuarioModel;
    }

    comNome(nome) {
        if (nome) {
            this.filtros.nome = { $regex: nome, $options: 'i' };
        }
        return this;
    }

    comEmail(email) {
        if (email) {
            this.filtros.email = { $regex: email, $options: 'i' };
        }
        return this;
    }

    comAtivo(ativo = 'true') {
        if (ativo === 'true') {
            this.filtros.ativo = true;
        }
        if (ativo === 'false') {
            this.filtros.ativo = false;
        }
        this.filtros = {};
        return this;
    }

    async comGrupo(grupo) {
        if (grupo) {
            // Não re-instancie o grupoRepository aqui.
            const gruposEncontrados = await this.grupoRepository.buscarPorNome(grupo);

            const grupoIds = gruposEncontrados
                ? Array.isArray(gruposEncontrados)
                    ? gruposEncontrados.map(g => g._id)
                    : [gruposEncontrados._id]
                : [];

            this.filtros.grupos = { $in: grupoIds };
        }
        return this;
    }

    async comUnidade(unidade) {
        if (unidade) {
            const unidadesEncontradas = await this.unidadeRepository.buscarPorNome(unidade);

            const unidadeIds = unidadesEncontradas
                ? Array.isArray(unidadesEncontradas)
                    ? unidadesEncontradas.map(u => u._id)
                    : [unidadesEncontradas._id]
                : [];

            this.filtros.unidades = { $in: unidadeIds };
        }
        return this;
    }

    escapeRegex(texto) {
        return texto.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }

    build() {
        return this.filtros;
    }
}

export default UsuarioFilterBuilder;

===== ./repositories/GrupoRepository.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/GrupoRepository.js

import mongoose from 'mongoose';
import GrupoModel from '../models/Grupo.js';
import UnidadeModel from '../models/Unidade.js';
import UsuarioModel from '../models/Usuario.js';
import RotaModel from '../models/Rota.js';
import { CustomError, messages } from '../utils/helpers/index.js';
import GrupoFilterBuilder from './filters/GrupoFilterBuilder.js';

class GrupoRepository {
    constructor({
        grupoModel = GrupoModel,
        unidadeModel = UnidadeModel,
        rotaModel = RotaModel,
        usuarioModel = UsuarioModel,
        grupoFilterBuilder = GrupoFilterBuilder,
        customError = CustomError,
    } = {}) {
        this.model = grupoModel;
        this.unidadeModel = unidadeModel;
        this.rotaModel = rotaModel;
        this.usuarioModel = usuarioModel;
        this.grupoFilterBuilder = grupoFilterBuilder;
        this.customError = customError;
    }

    /**
     * Verificar se há permissões duplicadas na requisição.
     */
    async obterParesRotaDominioUnicos(permissoes) {
        const combinacoes = permissoes.map(p => `${p.rota}_${p.dominio || 'undefined'}`);
        const combinacoesUnicas = [...new Set(combinacoes)];
        return combinacoesUnicas.map(combinacao => {
            const [rota, dominio] = combinacao.split('_');
            return { rota, dominio: dominio === 'undefined' ? null : dominio };
        });
    }

    /**
     * Obter permissões duplicadas na requisição.
     */
    obterPermissoesDuplicadas(permissoes, combinacoesRecebidas) {
        const combinacoes = permissoes.map(permissao => `${permissao.rota}_${permissao.dominio}`);
        const counts = {};
        combinacoes.forEach(combinacao => {
            counts[combinacao] = (counts[combinacao] || 0) + 1;
        });
        const duplicates = Object.keys(counts).filter(combinacao => counts[combinacao] > 1);
        const uniqueDuplicates = [];
        const seen = new Set();
        permissoes.forEach(permissao => {
            const combinacao = `${permissao.rota}_${permissao.dominio}`;
            if (duplicates.includes(combinacao) && !seen.has(combinacao)) {
                seen.add(combinacao);
                uniqueDuplicates.push(permissao);
            }
        });
        return uniqueDuplicates;
    }

    /**
     * Buscar grupo por nome e, opcionalmente, por um ID diferente.
     */
    async buscarPorNome(nome, idIgnorado = null) {
        // Criar o filtro base
        const filtro = { nome };

        // Adicionar a condição para excluir o ID, se fornecido
        if (idIgnorado) {
            filtro._id = { $ne: idIgnorado }; // Adiciona a condição _id != idIgnorado
        }

        // Consultar o documento no banco de dados
        const documento = await this.model.findOne(filtro);

        // Retornar o documento encontrado
        return documento;
    }

    /**
     * Método buscar por ID - Deve ser chamado por controllers ou services.
     * para retornar um usuário e ser utilizado em outras funções de validação
     * cujo listar não atende por exigir req.
     */
    async buscarPorId(id) {
        const group = await this.model.findById(id);
        if (!group) {
            throw new this.customError(
                {
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Grupo',
                    details: [],
                    customMessage: messages.error.resourceNotFound('Grupo')
                }
            );
        }
        return group;
    }

    /** Método buscar por permissão 
     * para saber se a permissão existe no cadastrado de rotas e domínios
     * O método deve buscar combinando rota e domínio
     */
    async buscarPorPermissao(permissoes) {
        // find recursivo lendo um array de objetos de permissão,
        // Mapear as permissões para combinar rota e domínio
        const query = permissoes.map(p => ({
            rota: p.rota,
            dominio: p.dominio || null
        }));

        const rotasEncontradas = await this.rotaModel.find({ $or: query });
        return rotasEncontradas;
    }


    /**
     * Método listar grupo tanto com filtro quanto sem filtro ou por ID, caso seja passado
     */
    async listar(req) {
        try {
            console.log('Estou no listar em GrupoRepository');
            const id = req.params.id || null;

            if (id) {
                const data = await this.model.findById(id)
                    .populate('permissoes')
                    .populate('unidades');
                if (!data) {
                    throw new this.customError({
                        statusCode: 404,
                        errorType: 'resourceNotFound',
                        field: 'Grupo',
                        details: [],
                        customMessage: messages.error.resourceNotFound('Grupo')
                    });
                }

                // Utilizando o length dos arrays
                const totalUnidades = data.unidades ? data.unidades.length : 0;
                const totalPermissoes = data.permissoes ? data.permissoes.length : 0;

                const dataWithStats = {
                    ...data.toObject(),
                    estatisticas: {
                        totalUnidades,
                        totalPermissoes
                    }
                };

                return data;
            }

            // Extrair os filtros da query
            const { nome, descricao, ativo = 'true', unidade, page = 1 } = req.query;

            // Garantir que o limite não ultrapasse 100
            const limite = Math.min(parseInt(req.query.limite, 10) || 10, 100);

            // Usar o GrupoFilterBuilder injetado para construir os filtros
            const filterBuilder = this.grupoFilterBuilder
                .comNome(nome || '')
                .comDescricao(descricao || '')
                .comAtivo(ativo || '');

            await filterBuilder.comUnidade(unidade);

            // Agora sim construir os filtros
            const filtros = filterBuilder.build();
            console.log('Filtros construídos:', filtros);

            // Configurar a paginação
            const options = {
                page: parseInt(page, 10),
                limit: parseInt(limite, 10),
                populate: [
                    'permissoes',
                    'unidades'
                ],
                sort: { nome: 1 },
            };

            const resultado = await this.model.paginate(filtros, options);
            console.log('Resultado da paginação:', resultado);


            // Enriquecer cada usuário com estatísticas utilizando o length dos arrays
            resultado.docs = resultado.docs.map(doc => {
                const grupoObj = typeof doc.toObject === 'function' ? doc.toObject() : doc;

                const totalUnidades = grupoObj.unidades ? grupoObj.unidades.length : 0;
                const totalPermissoes = grupoObj.permissoes ? grupoObj.permissoes.length : 0;

                return {
                    ...grupoObj,
                    estatisticas: {
                        totalUnidades,
                        totalPermissoes
                    }
                };
            });

            return resultado;
        } catch (error) {
            console.error('Erro ao listar grupos:', error);
            // Verificar se o erro já possui uma propriedade 'statusCode'
            if (error.statusCode) {
                throw error;
            }
            // Caso contrário, lançar um erro interno do servidor
            throw new this.customError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Grupo',
                details: [],
                customMessage: messages.error.internalServerError('Grupo')
            });
        }
    }

    /**
     * Verificar se há usuários associados ao grupo.
     * @param {String} id - ID do grupo.
     * @returns {Boolean} - true se houver usuários associados, false caso contrário.
     */
    async verificarUsuariosAssociados(id) {
        try {
            const usuariosAssociados = await this.usuarioModel.findOne({ grupos: id });
            return usuariosAssociados; // Retorna true se houver usuários, false caso contrário
        } catch (error) {
            console.error('Erro ao verificar usuários associados:', error);
            throw new this.customError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Grupo',
                details: [],
                customMessage: messages.error.internalServerError('Grupo')
            });
        }
    }


    // Método criar grupo
    async criar(parsedData) {
        const grupo = new this.model(parsedData);
        return await grupo.save();
    }

    // Método atualizar grupo
    async atualizar(id, parsedData) {
        try {
            const grupo = await this.model.findByIdAndUpdate(id, parsedData, { new: true });

            if (!grupo) {
                throw new this.customError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Grupo',
                    details: [],
                    customMessage: messages.error.resourceNotFound('Grupo')
                });
            }
            return grupo;
        } catch (error) {
            console.error('Erro ao atualizar grupo:', error);
            // Verificar se o erro já possui uma propriedade 'statusCode'
            if (error.statusCode) {
                throw error;
            }
            // Caso contrário, lançar um erro interno do servidor
            throw new this.customError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Grupo',
                details: [],
                customMessage: messages.error.internalServerError('Grupo')
            });
        }
    }

    /**
     * Método deletar grupo.
     */
    async deletar(id) {
        try {
            const grupoDeletado = await this.model.findByIdAndDelete(id);

            if (!grupoDeletado) {
                throw new this.customError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Grupo',
                    details: [],
                    customMessage: messages.error.resourceNotFound('Grupo')
                });
            }
            return grupoDeletado;
        } catch (error) {
            console.error('Erro ao deletar grupo:', error);
            // Verificar se o erro já possui uma propriedade 'statusCode'
            if (error.statusCode) {
                throw error;
            }
            // Caso contrário, lançar um erro interno do servidor
            throw new this.customError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Grupo',
                details: [],
                customMessage: messages.error.internalServerError('Grupo')
            });
        }
    }


}

export default GrupoRepository;

===== ./repositories/RotaRepository.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/RotaRepository.js

import RotaModel from '../models/Rota.js';
import RotaFilterBuilder from './filters/RotaFilterBuilder.js';
import GrupoModel from '../models/Grupo.js';
import UnidadeModel from '../models/Unidade.js';
import UsuarioModel from '../models/Usuario.js';
import { CustomError, messages } from '../utils/helpers/index.js';

class RotaRepository {
    constructor({
        rotaModel = RotaModel,
        grupoModel = GrupoModel,
        unidadeModel = UnidadeModel,
    } = {}) {
        this.model = rotaModel;
        this.grupoModel = grupoModel;
        this.unidadeModel = unidadeModel;
    }

    /**
 * Método buscar por ID - Deve ser chamado por controllers ou services.
 * para retornar um usuário e ser utilizado em outras funções de validação
 * cujo listar não atende por exigir req.
 */
    async buscarPorId(id) {
        const group = await this.model.findById(id);
        if (!group) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Grupo',
                details: [],
                customMessage: messages.error.resourceNotFound('Grupo')
            });
        }
        return group;
    }

    /**
     * Método para listar rotas no banco de dados.
     */
    async listar(req) {
        console.log('Estou no listar em RotaRepository');
        const id = req?.params?.id || null;

        // Se um ID foi fornecido, retornar a rota correspondente
        if (id) {
            const data = await this.model.findById(id);
            if (!data) {
                throw new CustomError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Rotas',
                    details: [],
                    customMessage: messages.error.resourceNotFound('Rotas'),
                });
            }
            return data;
        }

        // Extrair os filtros da query
        const { rota, dominio, ativo, buscar, enviar, substituir, modificar, excluir, page = 1, } = req.query;

        // Garantir que o limite não ultrapasse 100
        const limite = Math.min(parseInt(req.query.limite, 10) || 10, 100);

        // Construir os filtros
        const filterBuilder = new RotaFilterBuilder()
            .comRota(rota || '')
            .comDominio(dominio || '')
            .comAtivo(ativo || '')
            .comGet(buscar || '')
            .comPost(enviar || '')
            .comPut(substituir || '')
            .comPatch(modificar || '')
            .comDelete(excluir || '');

        // Validação do filtro de unidade para evitar erro de cast    
        if (typeof filterBuilder.build !== 'function') {
            throw new CustomError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Rota',
                details: [],
                customMessage: messages.error.internalServerError('Rota')
            });
        }

        // Construir os filtros
        const filtros = filterBuilder.build();

        // Configurar a paginação
        const options = {
            page: parseInt(page, 10),
            limit: parseInt(limite, 10),
        };

        // Aplicar os filtros na busca com paginação
        const data = await this.model.paginate(filtros, options);
        return data;
    }

    /**
     * Método para criar uma nova rota no banco de dados.
     */
    async criar(dados) {
        console.log('Estou no criar em RotaRepository');
        const rota = new this.model(dados);
        return await rota.save();
    }

    /**
     * Método para atualizar uma rota existente no banco de dados.
     */
    async atualizar(parsedData, id) {
        console.log('Estou no atualizar em RotaRepository');
        const data = await this.model.findByIdAndUpdate(id, parsedData);

        // Garante que a rota exista
        if (!data) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Rota',
                details: [],
                customMessage: messages.error.resourceNotFound('Rota'),
            });
        }
        return data;

    }

    /**
     * Método para deletar uma rota existente no banco de dados.
     */
    async deletar(id) {
        console.log('Estou no deletar em RotaRepository');
        const data = await this.model.findByIdAndDelete(id);

        // Garante que a rota exista
        if (!data) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Rota',
                details: [],
                customMessage: messages.error.resourceNotFound('Rota'),
            });
        }
        return data;
    }
}

export default RotaRepository;

===== ./repositories/TurmaRepository.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/TurmaRepository.js

import TurmaModel from '../models/Turma.js';
import { CustomError, messages } from '../utils/helpers/index.js';
import CursoRepository from '../repositories/CursoRepository.js';
import TurmaFilterBuilder from './filters/TurmaFilterBuilder.js';

class TurmaRepository {
    constructor({ model = TurmaModel } = {}) {
        this.model = model;
    }

    // Método para listar turmas, podendo buscar por ID ou aplicar filtros simples (codigo_suap, descricao e curso)
    async listar(req) {
        console.log('Estou no listar em TurmaRepository');
        const { id } = req.params || null;
        if (id) {
            const turma = await this.model.findById(id)
                .populate('curso');
            if (!turma) {
                throw new CustomError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Turma',
                    customMessage: messages.error.resourceNotFound('Turma'),
                });
            }
            return turma;
        }

        const { codigo_suap, descricao, curso, page = 1 } = req.query;
        const limite = Math.min(parseInt(req.query.limite, 10) || 10, 100);

        console.log(req.query);

        const filterBuilder = new TurmaFilterBuilder()
            .comCodigoSuap(codigo_suap || '')
            .comDescricao(descricao || '')

        if (typeof filterBuilder.build !== 'function') {
            throw new CustomError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Turma',
                details: [],
                customMessage: messages.error.internalServerError('Turma')
            });
        }

        await filterBuilder.comCurso(curso || '');

        const filtros = filterBuilder.build();

        const options = {
            page: parseInt(page, 10),
            limit: parseInt(limite, 10),
            populate: 'curso',
            sort: { descricao: 1 },
        };

        const resultado = await this.model.paginate(filtros, options);
        return resultado;
    }

    // Método para criar uma nova turma
    async criar(dadosTurma) {
        const turma = new this.model(dadosTurma);
        return await turma.save();
    }

    // Método para atualizar uma turma existente
    async atualizar(id, dadosAtualizados) {
        const turma = await this.model.findByIdAndUpdate(id, dadosAtualizados, { new: true })
            .populate('curso');

        if (!turma) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Turma',
                customMessage: messages.error.resourceNotFound('Turma'),
            });
        }
        return turma;
    }

    // Método para deletar uma turma
    async deletar(id) {
        const turma = await this.model.findByIdAndDelete(id);
        return turma;
    }

    // Método para buscar uma turma por ID, com populate do campo curso
    async buscarPorId(id) {
        const turma = await this.model.findById(id).populate('curso');
        if (!turma) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Turma',
                customMessage: messages.error.resourceNotFound('Turma'),
            });
        }
        return turma;
    }
}

export default TurmaRepository;

===== ./repositories/UnidadeRepository.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/UnidadeRepository.js

import UnidadeModel from '../models/Unidade.js';
import UnidadeFilterBuilder from './filters/UnidadeFilterBuilder.js';
import { CustomError, messages } from '../utils/helpers/index.js';


class UnidadeRepository {
    constructor() {
        this.model = UnidadeModel;
    }
    /**
     * metodos assincrono para bUscar Total de grupos associados a uma unidade
     */
    async buscarTotalGruposAssociados(idUnidade) {
        const grupos = await UnidadeModel.aggregate([
            {
                $match: { _id: idUnidade }
            },
            {
                $lookup: {
                    from: 'grupos',
                    localField: '_id',
                    foreignField: 'unidades',
                    as: 'grupos'
                }
            },
            {
                $unwind: '$grupos'
            },
            {
                $group: {
                    _id: '$_id',
                    total: { $sum: 1 }
                }
            }
        ]);
        return grupos;
    }


    /**
     * Método assíncrono para buscar o total de usuários associados a uma unidade.
     */
    async buscarTotalUsuariosAssociados(idUnidade) {
        const usuarios = await UnidadeModel.aggregate([
            {
                $match: { _id: idUnidade }
            },
            {
                $lookup: {
                    from: 'usuarios',
                    localField: '_id',
                    foreignField: 'unidades',
                    as: 'usuarios'
                }
            },
            {
                $unwind: '$usuarios'
            },
            {
                $group: {
                    _id: '$_id',
                    total: { $sum: 1 }
                }
            }
        ]);
        return usuarios
    }


    /**
     * Buscar grupo por nome e, opcionalmente, por um ID diferente.
     */
    async buscarPorNome(nome, localidade = null, idDiferente = null) {
        const filtro = { nome };
        if (idDiferente) {
            filtro._id = { $ne: idDiferente }; // Adiciona a condição _id != idDiferente
        }
        if (localidade) {
            filtro.localidade = localidade;
        }
        const documento = await this.model.findOne(filtro);
        return documento;
    }

    /**
     * Método buscar por ID - Deve ser chamado por controllers ou services.
     * para retornar um usuário e ser utilizado em outras funções de validação
     * cujo listar não atende por exigir req.
     */
    async buscarPorId(id) {
        const unit = await this.model.findById(id);
        if (!unit) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Unidade',
                details: [],
                customMessage: messages.error.resourceNotFound('Unidade')
            });
        }
        return unit;
    }

    async listar(req) {
        const id = req?.params?.id || null;

        // Se um ID for fornecido, retorna a unidade correspondente enriquecida com estatísticas
        if (id) {
            const data = await this.model.findById(id);
            if (!data) {
                throw new CustomError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Unidade',
                    details: [],
                    customMessage: messages.error.resourceNotFound('Unidade'),
                });
            }
            // Buscar estatísticas para a unidade única
            const gruposResult = await this.buscarTotalGruposAssociados(data._id);
            const totalGrupos = gruposResult.length ? gruposResult[0].total : 0;

            const usuariosResult = await this.buscarTotalUsuariosAssociados(data._id);
            const totalUsuarios = usuariosResult.length ? usuariosResult[0].total : 0;

            console.log('totalGrupos', totalGrupos);

            // Converter para objeto simples (caso seja um documento do Mongoose) e adicionar estatísticas
            const dataWithStats = {
                ...data.toObject(),
                estatisticas: {
                    totalGrupos,
                    totalUsuarios
                }
            };
            return dataWithStats;
        }

        // Caso não haja ID, retorna todas as unidades com suporte a filtros e paginação
        const { nome, localidade, ativo, page = 1 } = req.query || {};

        // Garantir que o limite não ultrapasse 100
        const limite = Math.min(parseInt(req.query?.limite, 10) || 10, 100);

        // Construir os filtros usando o filter builder
        const filterBuilder = new UnidadeFilterBuilder()
            .comNome(nome)
            .comLocalidade(localidade)
            .comAtivo(ativo);

        // Validação do filtro de unidade para evitar erro de cast
        if (typeof filterBuilder.build !== 'function') {
            throw new CustomError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Unidade',
                details: [],
                customMessage: messages.error.internalServerError('Unidade'),
            });
        }

        // Construir os filtros e as opções de paginação
        const filtros = filterBuilder.build();
        const options = {
            page: parseInt(page, 10),
            limit: parseInt(limite, 10),
            sort: { nome: 1 },
        };

        // Realizar a busca no banco de dados
        const resultado = await this.model.paginate(filtros, options);

        // Enriquecer cada documento com estatísticas
        resultado.docs = await Promise.all(resultado.docs.map(async (doc) => {
            // Caso o documento seja um documento Mongoose, converta-o para objeto simples
            const unidadeObj = typeof doc.toObject === 'function' ? doc.toObject() : doc;

            const gruposResult = await this.buscarTotalGruposAssociados(unidadeObj._id);
            const totalGrupos = gruposResult.length ? gruposResult[0].total : 0;

            const usuariosResult = await this.buscarTotalUsuariosAssociados(unidadeObj._id);
            const totalUsuarios = usuariosResult.length ? usuariosResult[0].total : 0;

            return {
                ...unidadeObj,
                estatisticas: {
                    totalGrupos,
                    totalUsuarios
                }
            };
        }));

        return resultado;
    }


    async criar(dadosUnidade) {
        const unidade = new this.model(dadosUnidade);
        return await unidade.save();
    }

    /**
     * Atualiza uma unidade existente.
     */
    async atualizar(id, dadosAtualizados) {
        const unidade = await this.model.findByIdAndUpdate(id, dadosAtualizados, { new: true });

        // Validar se a unidade  atualizada foi retornada
        if (!unidade) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Unidade',
                details: [],
                customMessage: messages.error.resourceNotFound('Unidade'),
            });
        }

        return unidade;
    }

    /**
     * Método para deletar uma unidade existente.
     */
    async deletar(id) {
        const unidadeDeletada = await this.model.findByIdAndDelete(id);

        // Validação de grupo deletado foi retornado
        if (!unidadeDeletada) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Unidade',
                details: [],
                customMessage: messages.error.resourceNotFound('Unidade')
            });
        }
        return unidadeDeletada;
    }

    /**
     * Verificar se há usuários associados a unidade.
     */
    async verificarUsuariosAssociados(id) {
        const usuariosAssociados = await UsuarioModel.findOne({ unidades: id });
        return usuariosAssociados;
    }
}


export default UnidadeRepository;

===== ./repositories/UsuarioRepository.js =====


===== # =====


===== separador =====


===== legível =====

// src/repositories/UsuarioRepository.js

import mongoose from 'mongoose';
import UsuarioFilterBuilder from './filters/UsuarioFilterBuilder.js';
import UsuarioModel from '../models/Usuario.js';
import GrupoModel from '../models/Grupo.js';
import UnidadeModel from '../models/Unidade.js';
import RotaModel from '../models/Rota.js';
import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';

class UsuarioRepository {
    constructor({
        usuarioModel = UsuarioModel,
        grupoModel = GrupoModel,
        unidadeModel = UnidadeModel,
        rotaModel = RotaModel
    } = {}) {
        this.model = usuarioModel;
        this.grupoModel = grupoModel;
        this.unidadeModel = unidadeModel;
        this.rotaModel = rotaModel;
    }



    /**
     * Obter combinações únicas de rota e domínio a partir das permissões.
     */
    async obterParesRotaDominioUnicos(permissoes) {
        const combinacoes = permissoes.map(p => `${p.rota}_${p.dominio || 'undefined'}`);
        const combinacoesUnicas = [...new Set(combinacoes)];
        return combinacoesUnicas.map(combinacao => {
            const [rota, dominio] = combinacao.split('_');
            return { rota, dominio: dominio === 'undefined' ? null : dominio };
        });
    }

    /**
     * Obter permissões duplicadas na requisição.
     */
    async obterPermissoesDuplicadas(permissoes, combinacoesRecebidas) {
        return permissoes.filter((p, index) =>
            combinacoesRecebidas.indexOf(`${p.rota}_${p.dominio || 'undefined'}`) !== index
        );
    }

    /**
     * Buscar usuário por email e, opcionalmente, por um ID diferente.
     */
    async buscarPorEmail(email, idIgnorado = null) {
        const filtro = { email };

        if (idIgnorado) {
            filtro._id = { $ne: idIgnorado };
        }

        const documento = await this.model.findOne(filtro, '+senha')
            .populate({
                path: 'grupos',
                populate: { path: 'unidades' }
            })
            .populate('permissoes')
            .populate('unidades');

        return documento;
    }

    /**
     * Método buscar por ID - Deve ser chamado por controllers ou services para retornar
     * um usuário e ser utilizado em outras funções de validação cujo listar não atende por exigir req.
     */
    async buscarPorId(id, includeTokens = false) {
        let query = this.model.findById(id);

        if (includeTokens) {
            query = query.select('+refreshtoken +accesstoken');
        }
        const user = await query;
        if (!user) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Usuário',
                details: [],
                customMessage: messages.error.resourceNotFound('Usuário')
            });
        }
        return user;
    }

    /**
     * Método buscar por permissão para saber se a permissão existe no cadastro de rotas e domínios.
     * O método deve buscar combinando rota e domínio.
     */
    async buscarPorPermissao(permissoes) {
        const query = permissoes.map(p => ({
            rota: p.rota,
            dominio: p.dominio || null
        }));
        const rotasEncontradas = await this.rotaModel.find({ $or: query });
        return rotasEncontradas;
    }

    /**
     * Método listar usuário com suporte a filtros, paginação e enriquecimento com estatísticas.
     */
    async listar(req) {
        console.log('Estou no listar em UsuarioRepository');
        const id = req.params.id || null;

        // Se um ID for fornecido, retorna o usuário enriquecido com estatísticas
        if (id) {
            const data = await this.model.findById(id)
                .populate({
                    path: 'grupos',
                    populate: { path: 'unidades' }
                })
                .populate('permissoes')
                .populate('unidades');

            if (!data) {
                throw new CustomError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Usuário',
                    details: [],
                    customMessage: messages.error.resourceNotFound('Usuário')
                });
            }

            // Utilizando o length dos arrays
            const totalGrupos = data.grupos ? data.grupos.length : 0;
            const totalUnidades = data.unidades ? data.unidades.length : 0;
            const totalPermissoes = data.permissoes ? data.permissoes.length : 0;
            const dataWithStats = {
                ...data.toObject(),
                estatisticas: {
                    totalGrupos,
                    totalUnidades,
                    totalPermissoes
                }
            };
            return dataWithStats;
        }

        // Caso não haja ID, retorna todos os usuários com suporte a filtros e paginação
        const { nome, email, ativo, grupo, unidade, page = 1 } = req.query;
        const limite = Math.min(parseInt(req.query.limite, 10) || 10, 100);

        const filterBuilder = new UsuarioFilterBuilder()
            .comNome(nome || '')
            .comEmail(email || '')
            .comAtivo(ativo || '');

        if (typeof filterBuilder.build !== 'function') {
            throw new CustomError({
                statusCode: 500,
                errorType: 'internalServerError',
                field: 'Usuário',
                details: [],
                customMessage: messages.error.internalServerError('Usuário')
            });
        }

        await filterBuilder.comGrupo(grupo);
        await filterBuilder.comUnidade(unidade);
        const filtros = filterBuilder.build();

        const options = {
            page: parseInt(page, 10),
            limit: parseInt(limite, 10),
            populate: [
                {
                    path: 'grupos',
                    populate: { path: 'unidades' }
                },
                'permissoes',
                'unidades'
            ],
            sort: { nome: 1 },
        };

        const resultado = await this.model.paginate(filtros, options);

        // Enriquecer cada usuário com estatísticas utilizando o length dos arrays
        resultado.docs = resultado.docs.map(doc => {
            const usuarioObj = typeof doc.toObject === 'function' ? doc.toObject() : doc;

            const totalGrupos = usuarioObj.grupos ? usuarioObj.grupos.length : 0;
            const totalUnidades = usuarioObj.unidades ? usuarioObj.unidades.length : 0;
            const totalPermissoes = usuarioObj.permissoes ? usuarioObj.permissoes.length : 0;

            return {
                ...usuarioObj,
                estatisticas: {
                    totalGrupos,
                    totalUnidades,
                    totalPermissoes
                }
            };
        });

        return resultado;
    }

    // Método criar usuário
    async criar(dadosUsuario) {
        const usuario = new this.model(dadosUsuario);
        return await usuario.save();
    }

    // Método atualizar usuário
    async atualizar(id, parsedData) {
        const usuario = await this.model.findByIdAndUpdate(id, parsedData, { new: true })
            .populate([
                {
                    path: 'grupos',
                    populate: { path: 'unidades' }
                },
                'permissoes',
                'unidades'
            ])
            .exec();

        if (!usuario) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Usuário',
                details: [],
                customMessage: messages.error.resourceNotFound('Usuário')
            });
        }
        return usuario;
    }

    // Método deletar usuário
    async deletar(id) {
        const usuario = await this.model.findByIdAndDelete(id);
        return usuario;
    }
}

export default UsuarioRepository;

===== ./routes/authRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import express from "express";
import AuthController from '../controllers/AuthController.js';
import authPermission from '../middlewares/AuthPermission.js';
import { asyncWrapper } from '../utils/helpers/index.js';

const router = express.Router();

const authController = new AuthController();

router  
  .post("/login", asyncWrapper(authController.login.bind(authController)))
  .post("/recuperasenha", asyncWrapper(authController.recuperaSenha.bind(authController)))
  .post("/logout", asyncWrapper(authController.logout.bind(authController)))
  .post("/token/revoke", asyncWrapper(authController.revoke.bind(authController)))
  .post("/token", asyncWrapper(authController.refresh.bind(authController)))
  .post("/pass", asyncWrapper(authController.pass.bind(authController)))

export default router;

===== ./routes/cursoRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import express from "express";
import CursoController from "../controllers/CursoController.js";
import { asyncWrapper } from '../utils/helpers/index.js';
import AuthMiddleware from "../middlewares/AuthMiddleware.js";
import authPermission from '../middlewares/AuthPermission.js';

const router = express.Router();

const cursoController = new CursoController(); // Instância da classe

router
  .get("/cursos", asyncWrapper(cursoController.listar.bind(cursoController)))
  .get("/cursos/:id", asyncWrapper(cursoController.listar.bind(cursoController)))
  .post("/cursos", AuthMiddleware, authPermission, asyncWrapper(cursoController.criar.bind(cursoController)))
  .put("/cursos/:id", AuthMiddleware, authPermission, asyncWrapper(cursoController.atualizar.bind(cursoController)))
  .delete("/cursos/:id", AuthMiddleware, authPermission, asyncWrapper(cursoController.deletar.bind(cursoController)))

export default router;

===== ./routes/estagioRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import e from "express";
import EstagioController from "../controllers/EstagioController.js";

const router = e.Router();

router
  .get("/estagios",  EstagioController.ListarEstagios)
  .post("/estagios",  EstagioController.AdicionarEstagio)
  .get("/estagios/:id",  EstagioController.ListarEstagioPorId)
  .put("/estagios/:id",  EstagioController.AtualizarEstagio)
  .delete("/estagios/:id",  EstagioController.DeletarEstagio);

export default router;

===== ./routes/estudanteRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import express from "express";
import AuthMiddleware from "../middlewares/AuthMiddleware.js";
import authPermission from '../middlewares/AuthPermission.js';
import EstudanteController from '../controllers/EstudanteController.js';
import upload from "../config/multerConfig.js";
import csvFileValidator from "../middlewares/csvFileValidator.js";
import { asyncWrapper } from '../utils/helpers/index.js';

const router = express.Router();

const estudanteController = new EstudanteController(); // Instância da classe

router
  .get("/estudantes", asyncWrapper(estudanteController.listar.bind(estudanteController)))
  .get("/estudantes/:id", asyncWrapper(estudanteController.ListarEstudantePorId.bind(estudanteController)))
  
  .post("/estudantes", asyncWrapper(estudanteController.criar.bind(estudanteController)))
  .put("/estudantes/:id", asyncWrapper(estudanteController.atualizar.bind(estudanteController)))
  .delete("/estudantes/:id", asyncWrapper(estudanteController.deletar.bind(estudanteController)))
  
  .patch("/estudantes/inativar", asyncWrapper(estudanteController.InativarEstudantes.bind(estudanteController)))
  .post("/estudantes/upload", upload.single("file"), csvFileValidator, asyncWrapper(estudanteController.Upload.bind(estudanteController)))

export default router;

===== ./routes/grupoRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import express from "express";
import AuthMiddleware from "../middlewares/AuthMiddleware.js";
import authPermission from '../middlewares/AuthPermission.js';
import GrupoController from '../controllers/GrupoController.js';
import { asyncWrapper } from '../utils/helpers/index.js';

const router = express.Router();

const grupoController = new GrupoController(); // Instância da classe

router
  .get("/grupos", AuthMiddleware, authPermission, asyncWrapper(grupoController.listar.bind(grupoController)))
  .get("/grupos/:id", AuthMiddleware, authPermission, asyncWrapper(grupoController.listar.bind(grupoController)))
  .post("/grupos", AuthMiddleware, authPermission, asyncWrapper(grupoController.criar.bind(grupoController)))
  .patch("/grupos/:id", AuthMiddleware, authPermission, asyncWrapper(grupoController.atualizar.bind(grupoController)))
  .put("/grupos/:id", AuthMiddleware, authPermission, asyncWrapper(grupoController.atualizar.bind(grupoController)))
  .delete("/grupos/:id", AuthMiddleware, authPermission, asyncWrapper(grupoController.deletar.bind(grupoController)))
export default router;
===== ./routes/index.js =====


===== # =====


===== separador =====


===== legível =====

// src/routes/index.js

import express from "express";
import swaggerJsDoc from "swagger-jsdoc";
import swaggerUI from "swagger-ui-express";
import getSwaggerOptions from "../docs/config/head.js";
import logRoutes from "../middlewares/LogRoutesMiddleware.js";
import usuarios from './usuarioRoutes.js';
import grupos from './grupoRoutes.js';
import rotas from './rotaRoutes.js';
import unidades from './unidadeRoutes.js';
import auth from './authRoutes.js';

import cursos from "./cursoRoutes.js";
import turmas from "./turmaRoutes.js";
import estudantes from "./estudanteRoutes.js";
import projetos from "./projetoRoutes.js";
import estagios from "./estagioRoutes.js";
import refeicaoTurmas from "./refeicaoTurmaRoutes.js";
import refeicoes from "./refeicoesRoutes.js";

import dotenv from "dotenv";

dotenv.config();

const routes = (app) => {
    if (process.env.DEBUGLOG) {
        app.use(logRoutes);
    }
    // rota para encaminhar da raiz para /docs
    app.get("/", (req, res) => {
        res.redirect("/docs");
    }
    );

    const swaggerDocs = swaggerJsDoc(getSwaggerOptions());
    app.use(swaggerUI.serve);
    app.get("/docs", (req, res, next) => {
        swaggerUI.setup(swaggerDocs)(req, res, next);
    });

    app.use(express.json(),
        auth, 
        usuarios,
        grupos,
        rotas,
        unidades,
        
        cursos,
        turmas,
        estudantes,
        projetos,
        estagios,
        refeicaoTurmas,
        refeicoes
    );

    // Se não é nenhuma rota válida, produz 404
    app.use((req, res) => {
        res.status(404).json({ message: "Rota não encontrada" });
    });
};

export default routes;
===== ./routes/projetoRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import e from "express";
import ProjetoController from "../controllers/ProjetoController.js";

const router = e.Router();

router
  .get("/projetos",  ProjetoController.ListarProjetos)
  .post("/projetos",  ProjetoController.AdicionarProjeto)
  .get("/projetos/:id",  ProjetoController.ListarProjetoPorId)
  .put("/projetos/:id",  ProjetoController.AtualizarProjeto)
  .delete("/projetos/:id",  ProjetoController.DeletarProjeto);

export default router;

===== ./routes/refeicaoTurmaRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import e from"express";
import RefeicaoTurmaController from "../controllers/RefeicaoTurmaController.js";

const router =  e.Router();

router
  .get("/refeicoes-turmas",  RefeicaoTurmaController.ListarRefeicaoTurma)
  .post("/refeicoes-turmas",  RefeicaoTurmaController.AdicionarRefeicaoTurma)
  .get("/refeicoes-turmas/:id",  RefeicaoTurmaController.ListarRefeicaoTurmaPorId)
  .put("/refeicoes-turmas/:id",  RefeicaoTurmaController.AtualizarRefeicaoTurma)
  .delete("/refeicoes-turmas/:id",  RefeicaoTurmaController.DeletarRefeicaoTurma);

export default router;

===== ./routes/refeicoesRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import e from "express";
import RefeicaoController from "../controllers/RefeicaoController.js";

const router = e.Router();

router
  .post("/refeicoes", RefeicaoController.Registrar)
  .get("/refeicoes", RefeicaoController.Relatorio);

export default router;

===== ./routes/rotaRoutes.js =====


===== # =====


===== separador =====


===== legível =====

// src/routes/rotaRoutes.js

import express from "express";
import AuthMiddleware from "../middlewares/AuthMiddleware.js";
import authPermission from '../middlewares/AuthPermission.js';
import RotaController from '../controllers/RotaController.js';
import { asyncWrapper } from '../utils/helpers/index.js';

const router = express.Router();

const rotaController = new RotaController();

router
  .get("/rotas", AuthMiddleware, authPermission, asyncWrapper(rotaController.listar.bind(rotaController)))
  .get("/rotas/:id", AuthMiddleware, authPermission, asyncWrapper(rotaController.listar.bind(rotaController)))
  .post("/rotas", AuthMiddleware, authPermission, asyncWrapper(rotaController.criar.bind(rotaController)))
  .patch("/rotas/:id", AuthMiddleware, authPermission, asyncWrapper(rotaController.atualizar.bind(rotaController)))
  .put("/rotas/:id", AuthMiddleware, authPermission, asyncWrapper(rotaController.atualizar.bind(rotaController)))
  .delete("/rotas/:id", AuthMiddleware, authPermission, asyncWrapper(rotaController.deletar.bind(rotaController)))

export default router;

===== ./routes/turmaRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import express from "express";
import AuthMiddleware from "../middlewares/AuthMiddleware.js";
import authPermission from '../middlewares/AuthPermission.js';
import TurmaController from "../controllers/TurmaController.js";
import { asyncWrapper } from '../utils/helpers/index.js';

const router = express.Router();

const turmaController = new TurmaController(); // Instância da classe

router
  .get("/turmas", asyncWrapper(turmaController.listar.bind(turmaController)))
  .get("/turmas/:id", asyncWrapper(turmaController.listar.bind(turmaController)))
  .post("/turmas", asyncWrapper(turmaController.criar.bind(turmaController)))
  .put("/turmas/:id", asyncWrapper(turmaController.atualizar.bind(turmaController)))
  .delete("/turmas/:id", asyncWrapper(turmaController.deletar.bind(turmaController)))


export default router;
===== ./routes/unidadeRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import express from "express";
import AuthMiddleware from "../middlewares/AuthMiddleware.js";
import authPermission from '../middlewares/AuthPermission.js';
import UnidadeController from '../controllers/UnidadeController.js';
import { asyncWrapper } from '../utils/helpers/index.js';

const router = express.Router();

const unidadeController = new UnidadeController(); // Instância da classe

router
  .get("/unidades", AuthMiddleware, authPermission, asyncWrapper(unidadeController.listar.bind(unidadeController)))
  .get("/unidades/:id", AuthMiddleware, authPermission, asyncWrapper(unidadeController.listar.bind(unidadeController)))
  .post("/unidades", AuthMiddleware, authPermission, asyncWrapper(unidadeController.criar.bind(unidadeController)))
  .patch("/unidades/:id", AuthMiddleware, authPermission, asyncWrapper(unidadeController.atualizar.bind(unidadeController)))
  .put("/unidades/:id", AuthMiddleware, authPermission, asyncWrapper(unidadeController.atualizar.bind(unidadeController)))
  .delete("/unidades/:id", AuthMiddleware, authPermission, asyncWrapper(unidadeController.deletar.bind(unidadeController)))

export default router;

===== ./routes/usuarioRoutes.js =====


===== # =====


===== separador =====


===== legível =====

import express from "express";
import AuthMiddleware from "../middlewares/AuthMiddleware.js";
import authPermission from '../middlewares/AuthPermission.js';
import UsuarioController from '../controllers/UsuarioController.js';
import { asyncWrapper } from '../utils/helpers/index.js';

const router = express.Router();

const usuarioController = new UsuarioController(); // Instância da classe

router
  .get("/usuarios", AuthMiddleware, authPermission, asyncWrapper(usuarioController.listar.bind(usuarioController)))
  .get("/usuarios/:id", AuthMiddleware, authPermission, asyncWrapper(usuarioController.listar.bind(usuarioController)))
  .post("/usuarios", AuthMiddleware, authPermission, asyncWrapper(usuarioController.criar.bind(usuarioController)))
  .patch("/usuarios/:id", AuthMiddleware, authPermission, asyncWrapper(usuarioController.atualizar.bind(usuarioController)))
  .put("/usuarios/:id", AuthMiddleware, authPermission, asyncWrapper(usuarioController.atualizar.bind(usuarioController)))
  .delete("/usuarios/:id", AuthMiddleware, authPermission, asyncWrapper(usuarioController.deletar.bind(usuarioController)))
  // Foto do usuário
  .post("/usuarios/:id/foto", AuthMiddleware, authPermission, asyncWrapper(usuarioController.fotoUpload.bind(usuarioController)))
  .get("/usuarios/:id/foto", asyncWrapper(usuarioController.getFoto.bind(usuarioController)))
 
  /**
   * Rotas para usuários (desativadas)
   * Antingas
   */
  // .post("/usuarios",  UsuarioController.CadastrarUsuario)
  // .get("/usuarios",  UsuarioController.ListarUsuarios)
  // .get("/usuarios/:id", adminOrSelfMiddleware,UsuarioController.ListarUsuarioPorId)
  // .put("/usuarios/:id", adminOrSelfMiddleware, UsuarioController.AtualizarUsuario)
  // .delete("/usuarios/:id", UsuarioController.DeletarUsuario);

export default router;

===== ./seeds/globalFakeMapping.js =====


===== # =====


===== separador =====


===== legível =====

// /src/seeds/globalFakeMapping.js

import fakebr from 'faker-br';
import mongoose from 'mongoose';
import { v4 as uuid } from 'uuid';
import TokenUtil from '../utils/TokenUtil.js';
import loadModels from './loadModels.js';

/**
 * Estrutura de mappings organizada por model.
 */
const fakeMappings = {
  // Campos comuns a vários models
  common: {
    nome: () =>
      fakebr.name.firstName() +
      " " +
      fakebr.name.lastName() +
      " " +
      fakebr.name.lastName(),
    email: () => fakebr.internet.email(),
    senha: () => fakebr.internet.password(),
    link_foto: () => fakebr.internet.url() + "/" + uuid() + ".jpg",
    ativo: () => fakebr.random.boolean(),
    tokenUnico: () =>
      TokenUtil.generateAccessToken(new mongoose.Types.ObjectId().toString()),
    refreshtoken: () =>
      TokenUtil.generateRefreshToken(new mongoose.Types.ObjectId().toString()),
    accesstoken: () =>
      TokenUtil.generateAccessToken(new mongoose.Types.ObjectId().toString()),
    descricao: () => fakebr.lorem.sentence(),
    localidade: () => fakebr.address.city() + " - " + fakebr.address.state(),
    rota: () => fakebr.lorem.word(10),
    dominio: () => fakebr.internet.url(),
    // Arrays de referências
    unidades: () => [{ _id: new mongoose.Types.ObjectId().toString() }],
    grupos: () => [{ _id: new mongoose.Types.ObjectId().toString() }],
    // Permissões (objeto complexo)
    permissoes: () => [
      {
        rota: fakebr.lorem.word(),
        dominio: fakebr.internet.url(),
        ativo: fakebr.random.boolean(),
        buscar: fakebr.random.boolean(),
        enviar: fakebr.random.boolean(),
        substituir: fakebr.random.boolean(),
        modificar: fakebr.random.boolean(),
        excluir: fakebr.random.boolean(),
      },
    ],
    // Campos para versionamento e permissões simples
    dataVersao: () => fakebr.date.past(),
    historico: () => [],
    buscar: () => fakebr.random.boolean(),
    enviar: () => fakebr.random.boolean(),
    substituir: () => fakebr.random.boolean(),
    modificar: () => fakebr.random.boolean(),
    excluir: () => fakebr.random.boolean(),
  },

  // Mapping específico para o model Curso
  Curso: {
    contra_turnos: () => ({
      segunda: fakebr.random.boolean(),
      terca: fakebr.random.boolean(),
      quarta: fakebr.random.boolean(),
      quinta: fakebr.random.boolean(),
      sexta: fakebr.random.boolean(),
      sabado: fakebr.random.boolean(),
      domingo: fakebr.random.boolean(),
    }),
    codigo: () =>
      fakebr.random.number({ min: 1000, max: 9999 }).toString(),
  },

  // Mapping específico para o model Estagio
  Estagio: {
    descricao: () => fakebr.lorem.sentence(),
    estudante: () => new mongoose.Types.ObjectId().toString(),
    data_inicio: () => fakebr.date.past(),
    data_termino: () => fakebr.date.future(),
    contra_turnos: () => ({
      segunda: fakebr.random.boolean(),
      terca: fakebr.random.boolean(),
      quarta: fakebr.random.boolean(),
      quinta: fakebr.random.boolean(),
      sexta: fakebr.random.boolean(),
      sabado: fakebr.random.boolean(),
      domingo: fakebr.random.boolean(),
    }),
    status: () => {
      const values = ["ativo", "inativo", "cancelado", "suspenso"];
      return values[Math.floor(Math.random() * values.length)];
    },
  },

  // Mapping específico para o model Estudante
  Estudante: {
    matricula: () => fakebr.random.number().toString(),
    nome: () =>
      fakebr.name.firstName() +
      " " +
      fakebr.name.lastName() +
      " " +
      fakebr.name.lastName(),
    ativo: () => fakebr.random.boolean(),
    cursos_id: () => new mongoose.Types.ObjectId().toString(),
    turma_id: () => new mongoose.Types.ObjectId().toString(),
  },

  // Mapping específico para o model Projeto
  Projeto: {
    descricao: () => fakebr.lorem.sentence(),
    professor_responsavel: () =>
      fakebr.name.firstName() +
      " " +
      fakebr.name.lastName() +
      " " +
      fakebr.name.lastName(),
    data_inicio: () => fakebr.date.past(),
    data_termino: () => fakebr.date.future(),
    contra_turnos: () => ({
      segunda: fakebr.random.boolean(),
      terca: fakebr.random.boolean(),
      quarta: fakebr.random.boolean(),
      quinta: fakebr.random.boolean(),
      sexta: fakebr.random.boolean(),
      sabado: fakebr.random.boolean(),
      domingo: fakebr.random.boolean(),
    }),
    lista_estudantes: () => [
      {
        estudante: new mongoose.Types.ObjectId().toString(),
        ativo: fakebr.random.boolean(),
      },
    ],
  },

  // Mapping específico para o model Refeicao
  Refeicao: {
    estudante: () => new mongoose.Types.ObjectId().toString(),
    data: () => fakebr.date.past(),
    tipoRefeicao: () => fakebr.lorem.word(),
    usuarioRegistrou: () => new mongoose.Types.ObjectId().toString(),
  },

  // Mapping específico para o model RefeicaoTurma
  RefeicaoTurma: {
    turma: () => new mongoose.Types.ObjectId().toString(),
    data_inicial: () => fakebr.date.past(),
    data_final: () => fakebr.date.future(),
    contra_turnos: () => ({
      segunda: fakebr.random.boolean(),
      terca: fakebr.random.boolean(),
      quarta: fakebr.random.boolean(),
      quinta: fakebr.random.boolean(),
      sexta: fakebr.random.boolean(),
      sabado: fakebr.random.boolean(),
      domingo: fakebr.random.boolean(),
    }),
  },

  // Mapping específico para o model Turma
  Turma: {
    codigo_suap: () => fakebr.random.alphaNumeric(6),
    curso: () => new mongoose.Types.ObjectId().toString(),
  }
};

/**
 * Retorna o mapping global, consolidando os mappings comuns e específicos.
 * Nesta versão automatizada, carregamos os models e combinamos o mapping comum com o mapping específico de cada model.
 */
export async function getGlobalFakeMapping() {
  const models = await loadModels();
  let globalMapping = { ...fakeMappings.common };

  models.forEach(({ name }) => {
    if (fakeMappings[name]) {
      globalMapping = {
        ...globalMapping,
        ...fakeMappings[name],
      };
    }
  });

  return globalMapping;
}

/**
 * Função auxiliar para extrair os nomes dos campos de um schema,
 * considerando apenas os níveis superiores (campos aninhados são verificados pela parte antes do ponto).
 */
function getSchemaFieldNames(schema) {
  const fieldNames = new Set();
  Object.keys(schema.paths).forEach((key) => {
    if (['_id', '__v', 'createdAt', 'updatedAt'].includes(key)) return;
    const topLevel = key.split('.')[0];
    fieldNames.add(topLevel);
  });
  return Array.from(fieldNames);
}

/**
 * Valida se o mapping fornecido cobre todos os campos do model.
 * Retorna um array com os nomes dos campos que estiverem faltando.
 */
function validateModelMapping(model, modelName, mapping) {
  const fields = getSchemaFieldNames(model.schema);
  const missing = fields.filter((field) => !(field in mapping));
  if (missing.length > 0) {
    console.error(
      `Model ${modelName} está faltando mapeamento para os campos: ${missing.join(', ')}`
    );
  } else {
    console.log(`Model ${modelName} possui mapeamento para todos os campos.`);
  }
  return missing;
}

/**
 * Executa a validação para os models fornecidos, utilizando o mapping específico de cada um.
 */
async function validateAllMappings() {
  const models = await loadModels();
  let totalMissing = {};

  models.forEach(({ model, name }) => {
    // Combina os campos comuns com os específicos de cada model
    const mapping = {
      ...fakeMappings.common,
      ...(fakeMappings[name] || {}),
    };
    const missing = validateModelMapping(model, name, mapping);
    if (missing.length > 0) {
      totalMissing[name] = missing;
    }
  });

  if (Object.keys(totalMissing).length === 0) {
    console.log('globalFakeMapping cobre todos os campos de todos os models.');
    return true;
  } else {
    console.warn('Faltam mapeamentos para os seguintes models:', totalMissing);
    return false;
  }
}

// Executa a validação antes de prosseguir com o seeding ou outras operações
validateAllMappings()
  .then((valid) => {
    if (valid) {
      console.log('Podemos acessar globalFakeMapping com segurança.');
      // Prossegue com o seeding ou outras operações
    } else {
      throw new Error('globalFakeMapping não possui todos os mapeamentos necessários.');
    }
  })
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

export default getGlobalFakeMapping;

===== ./seeds/loadModels.js =====


===== # =====


===== separador =====


===== legível =====

// /src/seeds/loadModels.js

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Obtém o diretório atual do arquivo
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Função para ler automaticamente os models da pasta "../models".
 * Retorna um array com objetos { model, name }.
 */
async function loadModels() {
    const models = [];
    const modelsDir = path.join(__dirname, '../models');
    const files = fs.readdirSync(modelsDir);

    for (const file of files) {
        if (file.endsWith('.js')) {
            const modelPath = path.join(modelsDir, file);
            // Importação dinâmica do módulo
            const module = await import(modelPath);
            // Considera que o model está exportado como default
            const model = module.default || module;
            // Usa o nome do arquivo (sem extensão) como identificador
            const modelName = path.basename(file, '.js');
            models.push({ model, name: modelName });
        }
    }
    return models;
}

export default loadModels;



===== ./seeds/meals/cursoSeed.js =====


===== # =====


===== separador =====


===== legível =====

import Curso from "../../models/Curso.js";

export default async function cursoSeed() {
  //Serão adicionados 3 cursos, info, edif e eletro

  const infoMock = {
    nome: "Informática",
    contra_turnos: {
      segunda: false,
      terca: false,
      quarta: true,
      quinta: false,
      sexta: false,
      sabado: false,
      domingo: false,
    },
    codigo: "0303"
  };
  const edifMock = {
    nome: "Edificações",
    contra_turnos: {
      segunda: false,
      terca: true,
      quarta: false,
      quinta: false,
      sexta: false,
      sabado: false,
      domingo: false,
    },
    codigo: "0301"
  };
  const eletroMock = {
    nome: "Eletromecânica",
    contra_turnos: {
      segunda: true,
      terca: false,
      quarta: false,
      quinta: false,
      sexta: false,
      sabado: false,
      domingo: false,
    },
    codigo: "0302"
  };

  const adsMock = {
    nome: "ADS",
    contra_turnos: {
      segunda: true,
      terca: false,
      quarta: false,
      quinta: false,
      sexta: false,
      sabado: false,
      domingo: false,
    },
    codigo: "0314"
  };

  await Curso.deleteMany({});

  await Curso.create(infoMock);

  await Curso.create(edifMock);

  await Curso.create(eletroMock);

  await Curso.create(adsMock);

  console.log("Cursos adicionados com sucesso!");
}

===== ./seeds/meals/estagioSeed.js =====


===== # =====


===== separador =====


===== legível =====

import Estagio from "../../models/Estagio.js";
import Estudante from "../../models/Estudante.js";
import { faker } from "@faker-js/faker";

export default async function estagioSeed() {
  //Serão adicionados 5 estágios

  const estudantes = await Estudante.find({}).limit(5);

  await Estagio.deleteMany({});

  for(let i = 0; i < 5; i++){
    const estudante = estudantes[i];
    const estagio = {
      descricao: "Estágio na CGTI do IFRO campus Vilhena",
      data_inicio: faker.date.recent(),
      data_termino: faker.date.future(),
      estudante: estudante._id,
      turnos: {
        segunda: faker.datatype.boolean(),
        terca: faker.datatype.boolean(),
        quarta: faker.datatype.boolean(),
        quinta: faker.datatype.boolean(),
        sexta: faker.datatype.boolean(),
        sabado: faker.datatype.boolean(),
        domingo: faker.datatype.boolean(),
      },
      status: "Em andamento"
    }
    await Estagio.create(estagio);
  }

  console.log("Estágios adicionados com sucesso!");
}
===== ./seeds/meals/estudanteSeed.js =====


===== # =====


===== separador =====


===== legível =====

import { faker } from "@faker-js/faker";
import Estudante from "../../models/Estudante.js";
import Turma from "../../models/Turma.js";

export default async function estudanteSeed() {

  // Serão gerados 100 alunos com turmas aleatorias

  const turmas = await Turma.find({});

  await Estudante.deleteMany({});

  for(let i = 0; i < 100; i++){
    const randomTurma = Math.floor(Math.random() * turmas.length);
    const turma = turmas[randomTurma];
    const matriculaEstudante = faker.string.numeric(13);
    const nomeEstudante = faker.person.fullName();
    const estudante = {
      _id: matriculaEstudante,
      matricula: matriculaEstudante,
      nome: nomeEstudante,
      turma: turma._id,
      ativo: true
    }
    await Estudante.create(estudante);
  }
  console.log("Estudantes gerados com sucesso")
}
===== ./seeds/meals/projetoSeed.js =====


===== # =====


===== separador =====


===== legível =====

import Projeto from "../../models/Projeto.js";
import Estudante from "../../models/Estudante.js";
import { faker } from "@faker-js/faker";

export default async function projetoSeed() {
  //Serão adicionados 10 projetos com 5 estudantes cada
  const estudantes = await Estudante.find({}).limit(50);

  await Projeto.deleteMany({});

  for (let i = 0; i < 10; i++) {
    const estudantesProjeto = estudantes.slice(i * 5, (i + 1) * 5);
    const projeto = {
      nome: `Projeto ${faker.hacker.noun()}`,
      data_inicio: faker.date.recent(),
      data_termino: faker.date.future(),
      estudantes: estudantesProjeto.map((estudante) => estudante._id),
      turnos: {
        segunda: faker.datatype.boolean(),
        terca: faker.datatype.boolean(),
        quarta: faker.datatype.boolean(),
        quinta: faker.datatype.boolean(),
        sexta: faker.datatype.boolean(),
        sabado: faker.datatype.boolean(),
        domingo: faker.datatype.boolean(),
      },
      status: "Em andamento"
    };
    await Projeto.create(projeto);
  }

  console.log("Projetos adicionados com sucesso!");
}
===== ./seeds/meals/seed.js =====


===== # =====


===== separador =====


===== legível =====

import "dotenv/config";
import cursoSeed from './cursoSeed.js';
import turmaSeed from './turmaSeed.js';
import usuarioSeed from './usuarioSeed.js';
import estudanteSeed from './estudanteSeed.js';
import estagioSeed from './estagioSeed.js';
import projetoSeed from './projetoSeed.js';
import { conectarBanco } from "../config/dbConnect.js";
import Turma from "../models/Turma.js";
import Estudante from "../models/Estudante.js";



async function seed() {
  await conectarBanco();

  await cursoSeed();
  
  await turmaSeed();
  //await Turma.deleteMany({});

  await estudanteSeed();
  //await Estudante.deleteMany({});

  await projetoSeed();
  await estagioSeed();

  console.log("Seed finalizado com sucesso!");
  process.exit();
}

seed();
===== ./seeds/meals/turmaSeed.js =====


===== # =====


===== separador =====


===== legível =====

import Curso from "../../models/Curso.js";
import Turma from "../../models/Turma.js";

export default async function turmaSeed() {
  //Serão adicionadas 18 turmas, 6 de cada curso

  const turmaDescrioes = [
    "Informática 1A",
    "Informática 2A",
    "Informática 3A",
    "Informática 1B",
    "Informática 2B",
    "Informática 3B",
    "Edificações 1A",
    "Edificações 2A",
    "Edificações 3A",
    "Edificações 1B",
    "Edificações 2B",
    "Edificações 3B",
    "Eletromecânica 1A",
    "Eletromecânica 2A",
    "Eletromecânica 3A",
    "Eletromecânica 1B",
    "Eletromecânica 2B",
    "Eletromecânica 3B",
  ];

  const turmaCodigos = [
    "20241.1.0303.1M",
    "20241.2.0303.1M",
    "20241.3.0303.1M",
    "20241.1.0303.1D",
    "20241.2.0303.1D",
    "20241.3.0303.1D",
    "20241.1.0301.1M",
    "20241.2.0301.1M",
    "20241.3.0301.1M",
    "20241.1.0301.1D",
    "20241.2.0301.1D",
    "20241.3.0301.1D",
    "20241.1.0302.1M",
    "20241.2.0302.1M",
    "20241.3.0302.1M",
    "20241.1.0302.1D",
    "20241.2.0302.1D",
    "20241.3.0302.1D",
  ];

  const cursos = await Curso.find({});
  const info = cursos.find((curso) => curso.nome === "Informática");
  const edif = cursos.find((curso) => curso.nome === "Edificações");
  const eletro = cursos.find((curso) => curso.nome === "Eletromecânica");

  await Turma.deleteMany({});

  for (let i = 0; i < turmaDescrioes.length; i++) {
    const descricao = turmaDescrioes[i];

    if (descricao.includes("Informática")) {
      await Turma.create({codigo_suap: turmaCodigos[i] ,descricao, curso: info._id });
    } else if (descricao.includes("Edificações")) {
      await Turma.create({codigo_suap: turmaCodigos[i] ,descricao, curso: edif._id });
    } else {
      await Turma.create({codigo_suap: turmaCodigos[i] ,descricao, curso: eletro._id });
    }
  }

  console.log("Turmas adicionadas com sucesso!");
}

===== ./seeds/renomear_jpg.sh =====


===== # =====


===== separador =====


===== legível =====

#!/bin/bash

# Caminho da pasta onde os arquivos estão localizados
FOLDER_PATH="./"

# Verifica se a pasta existe
if [ ! -d "$FOLDER_PATH" ]; then
  echo "A pasta especificada não existe."
  exit 1
fi

# Itera sobre todos os arquivos .jpg na pasta
for file in "$FOLDER_PATH"/*.jpg; do
  # Gera um UUID aleatório
  UUID=$(uuidgen)
  
  # Cria o novo nome do arquivo com o UUID
  NEW_NAME="$FOLDER_PATH/$UUID.jpg"
  
  # Renomeia o arquivo
  mv "$file" "$NEW_NAME"
  echo "Renomeado: $file -> $NEW_NAME"
done

echo "Processo concluído."

===== ./seeds/seeds copy.js =====


===== # =====


===== separador =====


===== legível =====

import bcrypt from 'bcryptjs';
import { randomBytes as _randomBytes } from 'crypto';
import faker from 'faker-br';
import DbConect from '../config/DbConnect.js';
import Grupo from '../models/Grupo.js';
import Rota from '../models/Rota.js';
import Unidade from '../models/Unidade.js';
import Usuario from '../models/Usuario.js';
import UsuarioCreateDTO from '../dtos/usuario/UsuarioCreateDTO.js'; // Importa o DTO
import fs from 'fs';
import path from 'path';
import globalFakeMapping from './globalFakeMapping.js';

import cursoSeed from './meals/cursoSeed.js';
import turmaSeed from './meals/turmaSeed.js';
import estudanteSeed from './meals/estudanteSeed.js';
import estagioSeed from './meals/estagioSeed.js';
import projetoSeed from './meals/projetoSeed.js';

// Função para obter um arquivo aleatório da pasta 'rostos'
async function getRandomImageFromFolder() {
  const directoryPath = './src/seeds/rostos'; // Caminho para a pasta 'rostos'
  const files = fs.readdirSync(directoryPath);
  const randomIndex = getRandomInt(files.length);
  return path.join(directoryPath, files[randomIndex]);
}

// Conectando ao banco de dados
await DbConect.conectar();

// Como vamos deixar o Model ou algum hook fazer o hash, usamos a senha em seu formato puro
const senhaPura = 'ABab@123456';

// Função para gerar um número aleatório entre 0 e max-1
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

// -------------------- Seed de Unidades --------------------

// Remove todas as Unidades existentes
await Unidade.deleteMany();

// Array de nomes de unidades fixas
const unidades_array = ['Matriz', 'Filial 1', 'Filial 2', 'Filial 3', 'Filial 4', 'Filial 5'];

// Função para obter o nome da unidade (fixo)
function getUnidadesNome(i) {
  return unidades_array[i].toString();
}

// Array de unidades a serem inseridas
let unidades = [];

function seedUnidades(qtdunidades) {
  // Unidade fixa com acesso total
  const seedUnidadeFixaAcessoTotalTodasRotas = {
    nome: 'Matriz',
    localidade: 'São Paulo - SP',
    ativo: true,
  };

  for (let i = 0; i < qtdunidades; i++) {
    const unidade = {
      nome: getUnidadesNome(i),
      localidade: globalFakeMapping.localidade() + ' - ' + faker.address.state(),
      ativo: globalFakeMapping.ativo(),
    };
    unidades.push(unidade);
  }
  unidades.push(seedUnidadeFixaAcessoTotalTodasRotas);
  return unidades;
}

seedUnidades(unidades_array.length);
const unidadesInseridasResult = await Unidade.collection.insertMany(unidades);
console.log(Object.keys(unidadesInseridasResult.insertedIds).length + ' Unidades inseridas!');
// Atualiza o array "unidades" com os documentos inseridos (agora contendo _id)
unidades = await Unidade.find();

// -------------------- Seed de Rotas --------------------

// Remove todas as Rotas existentes
await Rota.deleteMany();

// Array de rotas a serem inseridas
let rotas = [];

const rotas_array = [
  'rotas',
  'rotas:id',
  'grupos',
  'grupos:id',
  'unidades',
  'unidades:id',
  'usuarios',
  'usuarios:id'
];

function getRotaName(i) {
  return rotas_array[i].toString();
}

function seedRotas(qtdrotas) {
  for (let i = 0; i < qtdrotas; i++) {
    const rota = {
      rota: getRotaName(i),
      dominio: 'localhost', // Pode ser substituído por globalFakeMapping.dominio() se necessário
      ativo: true,
      buscar: true,
      enviar: true,
      substituir: true,
      modificar: true,
      excluir: true,
    };
    rotas.push(rota);
  }
  return rotas;
}

seedRotas(rotas_array.length);
const rotasInseridasResult = await Rota.collection.insertMany(rotas);
console.log(Object.keys(rotasInseridasResult.insertedIds).length + ' Rotas inseridas!');
// Atualiza o array "rotas" com os documentos inseridos
rotas = await Rota.find();

// -------------------- Seed de Grupos --------------------

// Função para obter uma unidade aleatória (dos documentos inseridos)
function getUnidadeAleatoria() {
  return unidades[getRandomInt(unidades.length)];
}

// Array para armazenar grupos
let grupos = [];
// Função para obter um grupo aleatório (dos documentos inseridos)
function getGrupoAleatorio() {
  return grupos[getRandomInt(grupos.length)];
}

// Remove todos os Grupos existentes
await Grupo.deleteMany();

// Array de nomes de grupos fictícios
const grupos_array = ['Gerente', 'Supervisor', 'Operador', 'Vendedor', 'Padrão'];

function getGrupoName(i) {
  return grupos_array[i].toString();
}

function seedGrupos(qtdgrupos) {
  // Grupo fixo com acesso total a todas as unidades e rotas
  const seedGrupoFixoAcessoTotalTodasUnidades = {
    nome: 'Administrador',
    descricao: 'Grupo com acesso total a todas as unidades e rotas',
    ativo: true,
    // Converte os _id para string e garante que o _id convertido sobrescreva o original
    unidades: unidades.map(u => u._id.toString()),
    permissoes: rotas.map(r => ({ ...r.toObject(), _id: r._id.toString() }))
  };
  grupos.push(seedGrupoFixoAcessoTotalTodasUnidades);

  // Grupos adicionais
  for (let i = 0; i < qtdgrupos; i++) {
    const seedGrupo = {
      nome: getGrupoName(i),
      descricao: globalFakeMapping.descricao(),
      ativo: true,
      unidades: [getUnidadeAleatoria()._id.toString()],
      permissoes: rotas.map(r => ({ ...r.toObject(), _id: r._id.toString() }))
    };
    grupos.push(seedGrupo);
  }
  return grupos;
}

seedGrupos(grupos_array.length);
const gruposInseridosResult = await Grupo.collection.insertMany(grupos);
console.log(Object.keys(gruposInseridosResult.insertedIds).length + ' Grupos inseridos!');
// Atualiza o array "grupos" com os documentos inseridos
grupos = await Grupo.find();

// -------------------- Seed de Usuários --------------------

// Remove todos os Usuários existentes
await Usuario.deleteMany();
const usuariosFixos = [];

// Obter todas as Rotas completas com _id convertidos para string
let RotasCompletas = await Rota.find({});
RotasCompletas = RotasCompletas.map(r => ({ ...r.toObject(), _id: r._id.toString() }));

// Obter IDs das Unidades inseridas (como strings)
const IDUnidadesDocs = await Unidade.find({}, { _id: 1 });
const IDUnidades = IDUnidadesDocs.map(u => u._id.toString());


// Obter IDs dos Grupos inseridos (como strings)
const IDGruposDocs = await Grupo.find({}, { _id: 1 });
const IDGrupos = IDGruposDocs.map(g => g._id.toString());

// Usuário fixo com acesso total a todas as unidades
const usuarioFixoAcessoTotalTodasUnidades = {
  nome: 'Dev oliveira',
  email: 'dev@gmail.com',
  senha: senhaPura, // senha em formato puro
  ativo: true,
  link_foto: await getRandomImageFromFolder(),
  permissoes: RotasCompletas,
  grupos: IDGrupos,
  unidades: IDUnidades,
};
usuariosFixos.push(usuarioFixoAcessoTotalTodasUnidades);

// Usuário fixo para acesso no APP com acesso total
const usuarioAPPFixoAcessoTotalTodasUnidades = {
  nome: 'APP de oliveira',
  email: 'app@gmail.com',
  senha: senhaPura,
  ativo: true,
  link_foto: 'c862414f-6caa-468c-adf9-2290e6c7cea2.jpg',
  permissoes: RotasCompletas,
  grupos: IDGrupos,
  unidades: IDUnidades,
};
usuariosFixos.push(usuarioAPPFixoAcessoTotalTodasUnidades);

// Usuário fixo com acesso limitado a uma unidade
const usuarioFixoLimitadoAUmaUnidade = {
  nome: 'Dev2 oliveira',
  email: 'dev2@gmail.com',
  senha: senhaPura,
  ativo: true,
  link_foto: '9538345f-6f9d-4670-af78-dfeb25503eb0.jpg',
  permissoes: RotasCompletas,
  grupos: IDGrupos,
  unidades: [getUnidadeAleatoria()._id.toString()],
};
usuariosFixos.push(usuarioFixoLimitadoAUmaUnidade);

// Validação dos dados dos usuários fixos via DTO
const usuariosFixosDTO = await Promise.all(
  usuariosFixos.map(userData => UsuarioCreateDTO.create(userData))
);

console.log('Usuários fixos:', usuariosFixosDTO.senha);

await Usuario.collection.insertMany(usuariosFixosDTO);
console.log(usuariosFixosDTO.length + ' Usuários fixos inseridos!');

// Seed de usuários aleatórios
const usuarios = [];
const provedores = ['gmail.com', 'hotmail.com', 'outlook.com', 'yahoo.com'];

async function seedUsuario(qtdusuarios) {
  for (let i = 0; i < qtdusuarios; i++) {
    const primeiroNome = globalFakeMapping.nome();
    const sobrenome = faker.name.lastName();
    const nomeCompleto = `${primeiroNome} ${sobrenome} ${faker.name.lastName()}`;
    // Utilizando faker.internet.email para garantir um email válido
    const email = faker.internet.email(primeiroNome, sobrenome).toLowerCase();

    const seedUsuarioObj = {
      nome: nomeCompleto,
      email: email,
      senha: senhaPura,
      ativo: globalFakeMapping.ativo(),
      link_foto: await getRandomImageFromFolder(),
      permissoes: rotas.map(r => ({ ...r.toObject(), _id: r._id.toString() })),
      grupos: [getGrupoAleatorio()._id.toString()],
      unidades: [getUnidadeAleatoria()._id.toString()],
    };
    usuarios.push(seedUsuarioObj);
  }
  return usuarios;
}

await seedUsuario(200);
const usuariosDTO = await Promise.all(
  usuarios.map(userData => UsuarioCreateDTO.create(userData))
);
await Usuario.collection.insertMany(usuariosDTO);
console.log(usuariosDTO.length + ' Usuários inseridos!');

// -------------------- Inserir dados para refeições --------------------
await cursoSeed();

await turmaSeed();
//await Turma.deleteMany({});

await estudanteSeed();
//await Estudante.deleteMany({});

await projetoSeed();
await estagioSeed();


// -------------------- Finalizando --------------------

await DbConect.desconectar();
process.exit(0);

===== ./seeds/seeds.js =====


===== # =====


===== separador =====


===== legível =====

import "dotenv/config";
import mongoose from "mongoose";

// Se você usa @faker-js/faker:
import { faker } from "@faker-js/faker";

// Se quiser faker em pt-BR, pode usar:
// import { faker } from "@faker-js/faker/locale/pt_BR";

// Dependências
import fs from "fs";
import path from "path";
import bcrypt from "bcryptjs";
import { randomBytes as _randomBytes } from "crypto";

// Conexão com banco
import DbConect from "../config/DbConnect.js";

// Models principais
import Grupo from "../models/Grupo.js";
import Rota from "../models/Rota.js";
import Unidade from "../models/Unidade.js";
import Usuario from "../models/Usuario.js";
import Curso from "../models/Curso.js";
import Turma from "../models/Turma.js";
import Estudante from "../models/Estudante.js";
import Projeto from "../models/Projeto.js";
import Estagio from "../models/Estagio.js";
import Refeicao from "../models/Refeicao.js";
import RefeicaoTurma from "../models/RefeicaoTurma.js";

// DTO de Usuário (caso seja necessário)
import UsuarioCreateDTO from "../dtos/usuario/UsuarioCreateDTO.js";

// Seu mapeador “globalFakeMapping” (se estiver usando)
import globalFakeMapping from "./globalFakeMapping.js";

// ----------------------------------------------------------------------------
// 1) Conectar ao banco de dados
// ----------------------------------------------------------------------------
await DbConect.conectar();

// ----------------------------------------------------------------------------
// 2) Funções auxiliares
// ----------------------------------------------------------------------------
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

async function getRandomImageFromFolder() {
  const directoryPath = "./src/seeds/rostos";
  const files = fs.readdirSync(directoryPath);
  const randomIndex = getRandomInt(files.length);
  return path.join(directoryPath, files[randomIndex]);
}

// Senha pura de teste
const senhaPura = "ABab@123456";

// ----------------------------------------------------------------------------
// 3) SEED de Unidades, Rotas, Grupos, Usuários
// ----------------------------------------------------------------------------
async function seedUnidades() {
  // Remove
  await Unidade.deleteMany();

  const unidades_array = ["Matriz", "Filial 1", "Filial 2", "Filial 3", "Filial 4", "Filial 5"];
  const unidades = [];

  // Cria todas as unidades listadas
  unidades_array.forEach((nome) => {
    unidades.push({
      nome,
      localidade: globalFakeMapping.localidade() + " - " + faker.address.state(),
      ativo: globalFakeMapping.ativo(),
    });
  });

  // (Opcional) Gera outra unidade “Matriz” se quiser duplicar
  unidades.push({
    nome: "Matriz",
    localidade: "São Paulo - SP",
    ativo: true,
  });

  const result = await Unidade.collection.insertMany(unidades);
  console.log(Object.keys(result.insertedIds).length + " Unidades inseridas!");

  // Retorna do banco para ter _id populado
  return Unidade.find();
}

async function seedRotas() {
  // Remove
  await Rota.deleteMany();

  const rotas_array = [
    "rotas",
    "rotas:id",
    "grupos",
    "grupos:id",
    "unidades",
    "unidades:id",
    "usuarios",
    "usuarios:id",
  ];

  const rotas = rotas_array.map((rota) => ({
    rota,
    dominio: "localhost",
    ativo: true,
    buscar: true,
    enviar: true,
    substituir: true,
    modificar: true,
    excluir: true,
  }));

  const result = await Rota.collection.insertMany(rotas);
  console.log(Object.keys(result.insertedIds).length + " Rotas inseridas!");

  return Rota.find();
}

async function seedGrupos(unidades, rotas) {
  // Remove
  await Grupo.deleteMany();

  // Exemplo de nomes
  const grupos_array = ["Gerente", "Supervisor", "Operador", "Vendedor", "Padrão"];
  const grupos = [];

  // Grupo fixo com acesso total
  const grupoAdministrador = {
    nome: "Administrador",
    descricao: "Grupo com acesso total a todas as unidades e rotas",
    ativo: true,
    unidades: unidades.map((u) => u._id.toString()),
    permissoes: rotas.map((r) => ({ ...r.toObject(), _id: r._id.toString() })),
  };
  grupos.push(grupoAdministrador);

  // Demais grupos
  for (let i = 0; i < grupos_array.length; i++) {
    grupos.push({
      nome: grupos_array[i],
      descricao: globalFakeMapping.descricao(),
      ativo: true,
      unidades: [unidades[getRandomInt(unidades.length)]._id.toString()],
      permissoes: rotas.map((r) => ({ ...r.toObject(), _id: r._id.toString() })),
    });
  }

  const result = await Grupo.collection.insertMany(grupos);
  console.log(Object.keys(result.insertedIds).length + " Grupos inseridos!");

  return Grupo.find();
}

async function seedUsuarios(unidades, rotas, grupos) {
  // Remove
  await Usuario.deleteMany();

  // Rotas completas
  const rotasCompletas = rotas.map((r) => ({ ...r.toObject(), _id: r._id.toString() }));
  const IDUnidades = unidades.map((u) => u._id.toString());
  const IDGrupos = grupos.map((g) => g._id.toString());

  const usuariosFixos = [
    {
      nome: "Dev oliveira",
      email: "dev@gmail.com",
      senha: senhaPura,
      ativo: true,
      link_foto: await getRandomImageFromFolder(),
      permissoes: rotasCompletas,
      grupos: IDGrupos,
      unidades: IDUnidades,
    },
    {
      nome: "APP de oliveira",
      email: "app@gmail.com",
      senha: senhaPura,
      ativo: true,
      link_foto: "c862414f-6caa-468c-adf9-2290e6c7cea2.jpg",
      permissoes: rotasCompletas,
      grupos: IDGrupos,
      unidades: IDUnidades,
    },
    {
      nome: "Dev2 oliveira",
      email: "dev2@gmail.com",
      senha: senhaPura,
      ativo: true,
      link_foto: "9538345f-6f9d-4670-af78-dfeb25503eb0.jpg",
      permissoes: rotasCompletas,
      grupos: IDGrupos,
      unidades: [unidades[getRandomInt(unidades.length)]._id.toString()],
    },
  ];

  const usuariosFixosDTO = await Promise.all(
    usuariosFixos.map((u) => UsuarioCreateDTO.create(u))
  );
  await Usuario.collection.insertMany(usuariosFixosDTO);
  console.log(usuariosFixosDTO.length + " Usuários fixos inseridos!");

  // Agora cria aleatórios
  const usuariosAleatorios = [];
  for (let i = 0; i < 200; i++) {
    const primeiroNome = globalFakeMapping.nome(); 
    const sobrenome = faker.person.lastName();
    const nomeCompleto = `${primeiroNome} ${sobrenome} ${faker.person.lastName()}`;
    const email = faker.internet.email(primeiroNome, sobrenome).toLowerCase();

    usuariosAleatorios.push({
      nome: nomeCompleto,
      email,
      senha: senhaPura,
      ativo: globalFakeMapping.ativo(),
      link_foto: await getRandomImageFromFolder(),
      permissoes: rotasCompletas,
      grupos: [grupos[getRandomInt(grupos.length)]._id.toString()],
      unidades: [unidades[getRandomInt(unidades.length)]._id.toString()],
    });
  }

  const usuariosAleatoriosDTO = await Promise.all(
    usuariosAleatorios.map((u) => UsuarioCreateDTO.create(u))
  );
  await Usuario.collection.insertMany(usuariosAleatoriosDTO);
  console.log(usuariosAleatoriosDTO.length + " Usuários aleatórios inseridos!");
}

// ----------------------------------------------------------------------------
// 4) SEED de Curso, Turma, Estudante, Projeto, Estágio
// ----------------------------------------------------------------------------
async function seedCursos() {
  await Curso.deleteMany();

  const infoMock = {
    nome: "Informática",
    contra_turnos: { segunda: false, terca: false, quarta: true, quinta: false, sexta: false, sabado: false, domingo: false },
    codigo: "0303",
  };
  const edifMock = {
    nome: "Edificações",
    contra_turnos: { segunda: false, terca: true, quarta: false, quinta: false, sexta: false, sabado: false, domingo: false },
    codigo: "0301",
  };
  const eletroMock = {
    nome: "Eletromecânica",
    contra_turnos: { segunda: true, terca: false, quarta: false, quinta: false, sexta: false, sabado: false, domingo: false },
    codigo: "0302",
  };
  const adsMock = {
    nome: "ADS",
    contra_turnos: { segunda: true, terca: false, quarta: false, quinta: false, sexta: false, sabado: false, domingo: false },
    codigo: "0314",
  };

  await Curso.create(infoMock);
  await Curso.create(edifMock);
  await Curso.create(eletroMock);
  await Curso.create(adsMock);

  console.log("Cursos adicionados com sucesso!");
}

async function seedTurmas() {
  await Turma.deleteMany();

  const turmaDescrioes = [
    "Informática 1A", "Informática 2A", "Informática 3A",
    "Informática 1B", "Informática 2B", "Informática 3B",
    "Edificações 1A", "Edificações 2A", "Edificações 3A",
    "Edificações 1B", "Edificações 2B", "Edificações 3B",
    "Eletromecânica 1A", "Eletromecânica 2A", "Eletromecânica 3A",
    "Eletromecânica 1B", "Eletromecânica 2B", "Eletromecânica 3B",
  ];
  const turmaCodigos = [
    "20241.1.0303.1M","20241.2.0303.1M","20241.3.0303.1M",
    "20241.1.0303.1D","20241.2.0303.1D","20241.3.0303.1D",
    "20241.1.0301.1M","20241.2.0301.1M","20241.3.0301.1M",
    "20241.1.0301.1D","20241.2.0301.1D","20241.3.0301.1D",
    "20241.1.0302.1M","20241.2.0302.1M","20241.3.0302.1M",
    "20241.1.0302.1D","20241.2.0302.1D","20241.3.0302.1D",
  ];

  const cursos = await Curso.find({});
  const info = cursos.find((c) => c.nome === "Informática");
  const edif = cursos.find((c) => c.nome === "Edificações");
  const eletro = cursos.find((c) => c.nome === "Eletromecânica");

  for (let i = 0; i < turmaDescrioes.length; i++) {
    const descricao = turmaDescrioes[i];
    let cursoId = null;
    if (descricao.includes("Informática")) cursoId = info?._id;
    else if (descricao.includes("Edificações")) cursoId = edif?._id;
    else cursoId = eletro?._id;

    await Turma.create({
      codigo_suap: turmaCodigos[i],
      descricao,
      curso: cursoId,
    });
  }
  console.log("Turmas adicionadas com sucesso!");
}

async function seedEstudantes() {
  await Estudante.deleteMany();

  const turmas = await Turma.find({});
  for (let i = 0; i < 100; i++) {
    const randomTurma = turmas[getRandomInt(turmas.length)];
    const matricula = faker.string.numeric(13);

    await Estudante.create({
      _id: matricula,
      matricula,
      nome: faker.person.fullName(),
      turma: randomTurma?._id,
      ativo: true,
    });
  }
  console.log("Estudantes gerados com sucesso!");
}

async function seedProjetos() {
  await Projeto.deleteMany();

  // Precisamos de 50 estudantes
  const estudantes = await Estudante.find({}).limit(50);

  for (let i = 0; i < 10; i++) {
    const estudantesProjeto = estudantes.slice(i * 5, (i + 1) * 5);
    await Projeto.create({
      nome: `Projeto ${faker.hacker.noun()}`,
      data_inicio: faker.date.recent(),
      data_termino: faker.date.future(),
      estudantes: estudantesProjeto.map((e) => e._id),
      turnos: {
        segunda: faker.datatype.boolean(),
        terca: faker.datatype.boolean(),
        quarta: faker.datatype.boolean(),
        quinta: faker.datatype.boolean(),
        sexta: faker.datatype.boolean(),
        sabado: faker.datatype.boolean(),
        domingo: faker.datatype.boolean(),
      },
      status: "Em andamento",
    });
  }
  console.log("Projetos adicionados com sucesso!");
}

async function seedEstagios() {
  await Estagio.deleteMany();

  // 5 estágios
  const estudantes = await Estudante.find({}).limit(5);
  for (let i = 0; i < 5; i++) {
    const estudante = estudantes[i];
    await Estagio.create({
      descricao: "Estágio na CGTI do IFRO campus Vilhena",
      data_inicio: faker.date.recent(),
      data_termino: faker.date.future(),
      estudante: estudante?._id,
      turnos: {
        segunda: faker.datatype.boolean(),
        terca: faker.datatype.boolean(),
        quarta: faker.datatype.boolean(),
        quinta: faker.datatype.boolean(),
        sexta: faker.datatype.boolean(),
        sabado: faker.datatype.boolean(),
        domingo: faker.datatype.boolean(),
      },
      status: "Em andamento",
    });
  }
  console.log("Estágios adicionados com sucesso!");
}

// ----------------------------------------------------------------------------
// 5) SEED de Refeicao e RefeicaoTurma (1000 cada)
// ----------------------------------------------------------------------------

async function seedRefeicoes() {
  // Remove tudo
  await Refeicao.deleteMany();

  // Buscar estudantes e usuários para referenciar
  const estudantes = await Estudante.find({});
  const usuarios = await Usuario.find({});

  // Possíveis tipos de refeição
  const tipos = ["Café da Manhã", "Almoço", "Jantar", "Lanche", "Ceia"];

  const listaRefeicoes = [];
  for (let i = 0; i < 1000; i++) {
    // Random estudante
    const estudanteRandom = estudantes[getRandomInt(estudantes.length)];
    // Random user
    const usuarioRandom = usuarios[getRandomInt(usuarios.length)];
    // Random tipo
    const tipoRefeicao = tipos[getRandomInt(tipos.length)];

    const doc = {
      estudante: estudanteRandom._id,
      data: faker.date.recent({ days: 30 }), // data aleatória nos últimos 30 dias
      tipoRefeicao,
      usuarioRegistrou: usuarioRandom._id,
    };
    listaRefeicoes.push(doc);
  }

  await Refeicao.collection.insertMany(listaRefeicoes);
  console.log(listaRefeicoes.length + " Refeicoes inseridas!");
}

async function seedRefeicoesTurma() {
  // Remove
  await RefeicaoTurma.deleteMany();

  // Buscar turmas
  const turmas = await Turma.find({});
  const listaRT = [];

  for (let i = 0; i < 1000; i++) {
    const turmaRandom = turmas[getRandomInt(turmas.length)];

    const doc = {
      turma: turmaRandom._id,
      data_liberado: faker.date.future(), // Exemplo: data futura
      descricao: faker.lorem.sentence(),
    };
    listaRT.push(doc);
  }

  await RefeicaoTurma.collection.insertMany(listaRT);
  console.log(listaRT.length + " RefeicoesTurma inseridas!");
}

// ----------------------------------------------------------------------------
// 6) Execução final (ordem de chamada)
// ----------------------------------------------------------------------------
async function main() {
  try {
    // 1) Entidades de acesso
    const unidades = await seedUnidades();
    const rotas = await seedRotas();
    const grupos = await seedGrupos(unidades, rotas);
    await seedUsuarios(unidades, rotas, grupos);

    // 2) Entidades “Meals”
    await seedCursos();
    await seedTurmas();
    await seedEstudantes();
    await seedProjetos();
    await seedEstagios();

    // 3) Refeicoes e RefeicoesTurma
    await seedRefeicoes();
    await seedRefeicoesTurma();

    console.log(">>> SEED FINALIZADO COM SUCESSO! <<<");
  } catch (err) {
    console.error("Erro ao executar SEED:", err);
  } finally {
    mongoose.connection.close();
    process.exit(0);
  }
}

// Executa tudo
main();

===== ./seeds/seedX/seedGenerators.js =====


===== # =====


===== separador =====


===== legível =====

// /src/seeds/seedX/seedGenerators.js

import bcrypt from 'bcryptjs';
import faker from 'faker-br';
import fs from 'fs';
import path from 'path';

// Função para gerar senha criptografada
export function gerarSenhaHash() {
    return bcrypt.hashSync('ABab@123456', 8);
}

// Função para gerar número inteiro aleatório
export function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

// Função para retornar uma imagem aleatória da pasta 'rostos'
export function getRandomImageFromFolder() {
    const directoryPath = './src/seeds/rostos';
    const files = fs.readdirSync(directoryPath);
    const randomIndex = getRandomInt(files.length);
    return path.join(files[randomIndex]);
}

// FUNÇÕES DE CRIAÇÃO DE OBJETOS

// Criação de Unidade
export function criarUnidade({ nome, localidade, ativo = true }) {
    return { nome, localidade, ativo };
}

// Criação de Rota
export function criarRota({ rota, dominio = 'localhost', ativo = true, buscar = true, enviar = true, substituir = true, modificar = true, excluir = true }) {
    return { rota, dominio, ativo, buscar, enviar, substituir, modificar, excluir };
}

// Criação de Grupo
export function criarGrupo({ nome, descricao, ativo = true, unidades = [], permissoes = [] }) {
    return { nome, descricao, ativo, unidades, permissoes };
}

// Criação de Usuário
export function criarUsuario({ nome, email, senha, ativo = true, link_foto, permissoes = [], grupos = [], unidades = [] }) {
    return { nome, email, senha, ativo, link_foto, permissoes, grupos, unidades };
}

// Função auxiliar para gerar email fake
export function gerarEmailFake() {
    const provedores = ['gmail.com', 'hotmail.com', 'outlook.com', 'yahoo.com'];
    const nome = faker.name.firstName();
    const nome_meio = faker.name.lastName();
    const sobrenome = faker.name.lastName();
    const email = `${nome}.${sobrenome}${getRandomInt(9999999999)}+fake@${provedores[getRandomInt(provedores.length)]}`;
    return email.toLowerCase();
}

===== ./seeds/seedX/seedx.js =====


===== # =====


===== separador =====


===== legível =====


// /src/seeds/seedX/seedx.js


import faker from 'faker-br';
import DbConect from '../config/DbConnect.js';
import Grupo from '../models/Grupo.js';
import Rota from '../models/Rota.js';
import Unidade from '../models/Unidade.js';
import Usuario from '../models/Usuario.js';
import {
  gerarSenhaHash,
  getRandomInt,
  getRandomImageFromFolder,
  criarUnidade,
  criarRota,
  criarGrupo,
  criarUsuario,
  gerarEmailFake
} from './seedGenerators.js';

// Senha padrão
const senhaCriptografada = gerarSenhaHash();

// --- Seed de Unidades ---
await DbConect.conectar();

await Unidade.deleteMany();

const unidades_array = ['Matriz', 'Filial 1', 'Filial 2', 'Filial 3', 'Filial 4', 'Filial 5'];

const unidades = unidades_array.map((nome, i) => {
  return criarUnidade({
    nome,
    localidade: `${faker.address.city()} - ${faker.address.state()}`,
    ativo: faker.random.boolean()
  });
});

// Unidade fixa com acesso total
const unidadeAcessoTotal = criarUnidade({
  nome: 'Matriz',
  localidade: 'São Paulo - SP',
  ativo: true
});
unidades.push(unidadeAcessoTotal);

const unidadesInseridas = await Unidade.collection.insertMany(unidades);
console.log(unidadesInseridas.length + ' Unidades inseridas!');

// --- Seed de Rotas ---
await Rota.deleteMany();

const rotas_array = [
  'rotas',
  'rotas:id',
  'grupos',
  'grupos:id',
  'unidades',
  'unidades:id',
  'usuarios',
  'usuarios:id'
];

const rotas = rotas_array.map(rotaNome => {
  return criarRota({ rota: rotaNome });
});

const rotasInseridas = await Rota.collection.insertMany(rotas);
console.log(rotasInseridas.length + ' Rotas inseridas!');

// --- Seed de Grupos ---
await Grupo.deleteMany();

const grupos_array = ['Gerente', 'Supervisor', 'Operador', 'Vendedor', 'Padrão'];
const grupos = [];



// Grupo Administrador com acesso total a todas as unidades e rotas
const grupoAdm = criarGrupo({
  nome: 'Administrador',
  descricao: 'Grupo com acesso total a todas as unidades e rotas',
  ativo: true,
  // Para evitar problemas com _id undefined, considere que as inserções ainda não retornaram os _id
  // Aqui, assumimos que as referências serão preenchidas após as inserções ou você pode utilizar um método que gere os IDs previamente.
  unidades: unidades.map(u => u._id),
  permissoes: rotas.map(r => ({ _id: r._id, ...r }))
});
grupos.push(grupoAdm);

// Outros grupos
grupos_array.forEach(grupoNome => {
  const grupo = criarGrupo({
    nome: grupoNome,
    descricao: faker.lorem.sentence(),
    ativo: true,
    unidades: [unidades[getRandomInt(unidades.length)]._id],
    permissoes: rotas.map(r => ({ _id: r._id, ...r }))
  });
  grupos.push(grupo);
});

const gruposInseridos = await Grupo.collection.insertMany(grupos);
console.log(gruposInseridos.length + ' Grupos inseridos!');

// --- Seed de Usuários ---
await Usuario.deleteMany();

const usuariosFixos = [];

// Obter todas as rotas (para permissões)
const RotasCompletas = await Rota.find({});

// Obter IDs das unidades e grupos
const IDUnidades = await Unidade.find({}, { _id: 1 });
const IDGrupos = await Grupo.find({}, { _id: 1 });

// Usuário com acesso total
const usuarioTotal = criarUsuario({
  nome: 'Dev oliveira',
  email: 'dev@gmail.com',
  senha: senhaCriptografada,
  ativo: true,
  link_foto: getRandomImageFromFolder(),
  permissoes: RotasCompletas,
  grupos: IDGrupos.map(g => g._id),
  unidades: IDUnidades.map(u => u._id)
});
usuariosFixos.push(usuarioTotal);

// Outro usuário para APP
const usuarioApp = criarUsuario({
  nome: 'APP de oliveira',
  email: 'app@gmail.com',
  senha: senhaCriptografada,
  ativo: true,
  link_foto: 'c862414f-6caa-468c-adf9-2290e6c7cea2.jpg',
  permissoes: RotasCompletas,
  grupos: IDGrupos.map(g => g._id),
  unidades: IDUnidades.map(u => u._id)
});
usuariosFixos.push(usuarioApp);

// Usuário com acesso limitado
const usuarioLimitado = criarUsuario({
  nome: 'Dev2 oliveira',
  email: 'dev2@gmail.com',
  senha: senhaCriptografada,
  ativo: true,
  link_foto: '9538345f-6f9d-4670-af78-dfeb25503eb0.jpg',
  permissoes: RotasCompletas,
  grupos: IDGrupos.map(g => g._id),
  unidades: [unidades[getRandomInt(unidades.length)]._id]
});
usuariosFixos.push(usuarioLimitado);

await Usuario.collection.insertMany(usuariosFixos);
console.log(usuariosFixos.length + ' Usuários fixos inseridos!');

const usuarios = [];

// Seed de usuários aleatórios
for (let i = 0; i < 200; i++) {
  const nome = faker.name.firstName();
  const nome_meio = faker.name.lastName();
  const sobrenome = faker.name.lastName();
  const email = gerarEmailFake();
  const usuario = criarUsuario({
    nome: `${nome} ${nome_meio} ${sobrenome}`,
    email,
    senha: senhaCriptografada,
    ativo: faker.random.boolean(),
    link_foto: getRandomImageFromFolder(),
    permissoes: rotas.map(r => ({ _id: r._id, ...r })),
    grupos: [grupos[getRandomInt(grupos.length)]._id],
    unidades: [unidades[getRandomInt(unidades.length)]._id]
  });
  usuarios.push(usuario);
}

const usuariosInseridos = await Usuario.collection.insertMany(usuarios);
console.log(usuariosInseridos.length + ' Usuários inseridos!');

// Desconectar do banco
await DbConect.desconectar();
process.exit(0);

===== ./services/AuthService.js =====


===== # =====


===== separador =====


===== legível =====

// /src/services/AuthService.js

import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';
import tokenUtil from '../utils/TokenUtil.js';
import { v4 as uuid } from 'uuid';

import UsuarioRepository from '../repositories/UsuarioRepository.js';
import AuthRepository from '../repositories/AuthRepository.js';

class AuthService {
    constructor({ tokenUtil: injectedTokenUtil, usuarioRepository, authRepository } = {}) {
        // Se nada for injetado, usa a instância importada
        this.TokenUtil = injectedTokenUtil || tokenUtil;
        this.usuarioRepository = usuarioRepository || new UsuarioRepository();
        this.repository = authRepository || new AuthRepository();
    }

    async carregatokens(id, token) {
        const data = await this.usuarioRepository.buscarPorId(id, { includeTokens: true });
        return { data };
    }

    async revoke(id) {
        const data = await this.repository.removeToken(id);
        return { data };
    }

    async logout(id, token) {
        const data = await this.repository.removeToken(id);
        return { data };
    }

    async login(body) {
        console.log('Estou no logar em AuthService');

        // Buscar o usuário pelo email
        const userEncontrado = await this.usuarioRepository.buscarPorEmail(body.email);
        if (!userEncontrado) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'notFound',
                field: 'Email',
                details: [],
                customMessage: messages.error.unauthorized('Senha ou Email')
            });
        }

        // Validar a senha
        const senhaValida = await bcrypt.compare(body.senha, userEncontrado.senha);
        if (!senhaValida) {
            throw new CustomError({
                statusCode: 401,
                errorType: 'unauthorized',
                field: 'Senha',
                details: [],
                customMessage: messages.error.unauthorized('Senha ou Email')
            });
        }

        // Gerar novo access token utilizando a instância injetada
        const accesstoken = await this.TokenUtil.generateAccessToken(userEncontrado._id);

        // Buscar o usuário com os tokens já armazenados
        const userComTokens = await this.usuarioRepository.buscarPorId(userEncontrado._id, true);
        let refreshtoken = userComTokens.refreshtoken;
        console.log("refresh token no banco", refreshtoken);

        if (refreshtoken) {
            try {
                jwt.verify(refreshtoken, process.env.JWT_SECRET);
            } catch (error) {
                if (error.name === 'TokenExpiredError' || error.name === 'JsonWebTokenError') {
                    refreshtoken = await this.TokenUtil.generateRefreshToken(userEncontrado._id);
                } else {
                    throw new CustomError({
                        statusCode: 500,
                        errorType: 'serverError',
                        field: 'Token',
                        details: [],
                        customMessage: messages.error.unauthorized('falha na geração do token')
                    });
                }
            }
        } else {
            // Se o refresh token não existe, gera um novo
            refreshtoken = await this.TokenUtil.generateRefreshToken(userEncontrado._id);
        }

        console.log("refresh token gerado", refreshtoken);

        // Armazenar os tokens atualizados
        await this.repository.armazenarTokens(userEncontrado._id, accesstoken, refreshtoken);

        // Buscar novamente o usuário e remover a senha
        const userLogado = await this.usuarioRepository.buscarPorEmail(body.email);
        delete userLogado.senha;
        const userObjeto = userLogado.toObject();

        // Retornar o usuário com os tokens
        return { user: { accesstoken, refreshtoken, ...userObjeto } };
    }


    async recuperaSenha(body) {
        console.log('Estou no logar em RecuperaSenhaService');
        const userEncontrado = await this.usuarioRepository.buscarPorEmail(body.email);

        if (!userEncontrado) {
            throw new CustomError({
                statusCode: HttpStatusCodes.NOT_FOUND.code,
                field: 'Email',
                details: [],
                customMessage: HttpStatusCodes.NOT_FOUND.message
            });
        }

        return { message: "Solicitação de recuperação de senha recebida, um email será enviado com as instruções para recuperação de senha" };
    }

    async refresh(id, token) {
        const userEncontrado = await this.usuarioRepository.buscarPorId(id, { includeTokens: true });

        if (!userEncontrado) {
            throw new CustomError({
                statusCode: HttpStatusCodes.NOT_FOUND.code,
                field: 'Token',
                details: [],
                customMessage: HttpStatusCodes.NOT_FOUND.message
            });
        }

        console.log("refresh token no banco", userEncontrado.refreshtoken);
        console.log("refresh token recebido", token);

        if (userEncontrado.refreshtoken !== token) {
            console.log('Token inválido');
            throw new CustomError({
                statusCode: HttpStatusCodes.UNAUTHORIZED.code,
                errorType: 'invalidToken',
                field: 'Token',
                details: [],
                customMessage: messages.error.unauthorized('Token')
            });
        } else {
            console.log('Token válido');
        }

        // Gerar novo access token utilizando a instância injetada
        const accesstoken = await this.TokenUtil.generateAccessToken(id);

        /**
         * Se SINGLE_SESSION_REFRESH_TOKEN for true, gera um novo refresh token
         * Senão, mantém o token armazenado
         */
        let refreshtoken = '';
        if (process.env.SINGLE_SESSION_REFRESH_TOKEN === 'true') {
            refreshtoken = await this.TokenUtil.generateRefreshToken(id);
        } else {
            refreshtoken = userEncontrado.refreshtoken;
        }

        await this.repository.armazenarTokens(id, accesstoken, refreshtoken);

        // Atualiza o usuário com os novos tokens
        const userLogado = await this.usuarioRepository.buscarPorId(id, { includeTokens: true });
        delete userLogado.senha;
        const userObjeto = userLogado.toObject();

        const userComTokens = {
            accesstoken,
            refreshtoken,
            ...userObjeto
        };

        return { user: userComTokens };
    }
}

export default AuthService;

===== ./services/CursoService.js =====


===== # =====


===== separador =====


===== legível =====

// src/services/CursoService.js

import CursoRepository from '../repositories/CursoRepository.js';

class CursoService {
    constructor() {
        this.repository = new CursoRepository();
    }

    async listar(req) {
        console.log('Estou no listar em CursoService');
        const data = await this.repository.listar(req);
        return data;
    }

    async criar(dados) {
        return await this.repository.criar(dados);
    }

    async atualizar(id, dados) {
        return await this.repository.atualizar(id, dados);
    }

    async deletar(id) {
        return await this.repository.deletar(id);
    }
}

export default CursoService;

===== ./services/EstudanteService.js =====


===== # =====


===== separador =====


===== legível =====

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import Estudante from "../models/Estudante.js";
import Turma from "../models/Turma.js";
import Curso from "../models/Curso.js";
import CsvToJson from "convert-csv-to-json";

class EstudanteService {
  //! usar esse cabecalho "id;turma;aluno;matricula;situacao", o delimitador pode mudar
  static async importEstudantesTeste(filename, delimiter = ",") {
    // Pegar o local do arquivo csv
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const csvPath = path.join(__dirname, "..", "..", "uploads", `${filename}`);

    const estudantesJson =
      CsvToJson.fieldDelimiter(delimiter).getJsonFromCsv(csvPath);

    // fazer dessa forma diminui o tempo de resposta
    const estudantesArr = []; // Array de estudantes para fazer o BulkSave no final e não ter que salvar a cada iteração de estudante
    const turmasExistentesArr = []; //Array de turmas existentes para evitar ter que fazer a query de encontrar turma a cada estudante
    
    try {
      for (let i = 0; i < estudantesJson.length; i++) {
        const estudante = estudantesJson[i];

        await this.#handleEstudante(estudante, estudantesArr, turmasExistentesArr);
      }

      Estudante.bulkSave(estudantesArr, {timestamps: false, session: null, w:1, wtimeout:null, j:true});

      //Apagar o arquivo csv
      fs.unlinkSync(csvPath);
    } catch (error) {
      //Apagar o arquivo csv
      fs.unlinkSync(csvPath);

      throw error;
    }
  }

  // eu acho que talvez eu tenha complicado usando métodos privado aqui, mas faz lógica na minha cabeça

  static async #handleEstudante(estudante, estudArr, turmaExistArr) {

    let turmaDoc = turmaExistArr.find((turma)=> turma.codigo_suap == estudante.turma); 

    if(!turmaDoc){
      turmaDoc = await Turma.findOne({
        codigo_suap: { $regex: `${estudante.turma}` },
      });
      if(turmaDoc) turmaExistArr.push(turmaDoc);
    }

    if (!turmaDoc) {
      turmaDoc = await this.#createTurmaOfCode(estudante.turma);
      turmaExistArr.push(turmaDoc);
    }

    let estudanteDoc = await Estudante.findOne({
      matricula: { $regex: `${estudante.matricula}` },
    });

    if (!estudanteDoc) {
      
      const newEstudante = Estudante({
        _id: estudante.matricula,
        nome: estudante.aluno,
        matricula: estudante.matricula,
        turma: turmaDoc._id,
        ativo: true,
      })
      estudArr.push(newEstudante);
    } else {
      estudanteDoc.ativo = true;
      estudanteDoc.turma = turmaDoc._id;
      estudArr.push(estudanteDoc);
    }
  }

  static async #createTurmaOfCode(codigoTurma) {
    const [ano, serie, codigoCurso, periodo] = codigoTurma.split(".");

    const cursoDoc = await Curso.findOne({
      codigo: { $regex: `${codigoCurso}` },
    });

    if (!cursoDoc) {
      throw new Error(
        `Código ${codigoCurso} de curso não encontrado! Certifique se de que existe um curso com esse cógigo.`
      );
    }

    const newTurma = {
      codigo_suap: codigoTurma,
      curso: cursoDoc._id,
      descricao: `Turma de ${ano} - Curso de ${cursoDoc.nome} - ${serie} série - ${periodo} `,
    };

    const turmaCriada = await Turma.create(newTurma)
      .then((turma) => turma.populate("curso"))
      .then((turma) => turma); //Fazer isso para retornar a turma populada;

    return turmaCriada;
  }

  
}

export default EstudanteService;

===== ./services/GrupoService.js =====


===== # =====


===== separador =====


===== legível =====

// src/services/GrupoService.js

import mongoose from 'mongoose';
import GrupoRepository from '../repositories/GrupoRepository.js';
import GrupoFilterBuilder from '../repositories/filters/GrupoFilterBuilder.js'; // Importação adicionada
import { CustomError, messages } from '../utils/helpers/index.js';
import { PermissoesArraySchema } from '../utils/validators/schemas/zod/PermissaoValidation.js';
import { GrupoQuerySchema, GrupoIdSchema } from '../utils/validators/schemas/zod/querys/GrupoQuerySchema.js';
import { GrupoSchema, GrupoUpdateSchema } from '../utils/validators/schemas/zod/GrupoSchema.js';

class GrupoService {
    constructor() {
        // Instancia o GrupoFilterBuilder
        const grupoFilterBuilder = new GrupoFilterBuilder();

        // Injeta o GrupoFilterBuilder no GrupoRepository
        this.repository = new GrupoRepository({
            grupoFilterBuilder
        });
    }

    /**
     * Validação nesta aplicação segue o seguinte artigo:
     * https://docs.google.com/document/d/1m2Ns1rIxpUzG5kRsgkbaQFdm7od0e7HSHfaSrrwegmM/edit?usp=sharing
     */

    /**
     * Lista grupos. Se um ID é fornecido, retorna um grupo.
     * Caso contrário, retorna todos os grupos com suporte a filtros e paginação.
     */
    async listar(req) {
        console.log('Estou no listar em GrupoService');
        const data = await this.repository.listar(req);
        console.log('Estou retornando os dados em GrupoService');
        return data;
    }

    /**
     * Cria um novo grupo após validação dos dados.
     */
    async criar(parsedData) {
        console.log('Estou no criar em GrupoService');

        // Realiza validações compartilhadas
        await this.validateGroupName(parsedData.nome);
        await this.validatePermissions(parsedData.permissoes);

        // Chama o repositório para criar o grupo
        const data = await this.repository.criar(parsedData);
        return data;
    }

    /**
     * Atualiza um grupo existente após validação dos dados.
     */
    async atualizar(parsedData, id) {
        console.log('Estou no atualizar em GrupoService');

        // Garante que o grupo exista
        await this.ensureGroupExists(id);

        // Realiza validações compartilhadas
        await this.validateGroupName(parsedData.nome, id);
        await this.validatePermissions(parsedData.permissoes);

        // Chama o repositório para atualizar o grupo
        const data = await this.repository.atualizar(id, parsedData);
        return data;
    }

    /**
     * Deleta um grupo existente.
     */
    async deletar(id) {
        console.log('Estou no deletar em GrupoService');

        // Verificar se o grupo existe
        await this.ensureGroupExists(id);

        // Verificar se o grupo está associado a algum usuário
        const usuariosAssociados = await this.repository.verificarUsuariosAssociados(id);

        if (usuariosAssociados) {
            throw new CustomError({
                statusCode: 400,
                errorType: 'resourceConflict',
                field: 'Grupo',
                details: [],
                customMessage: messages.error.resourceConflict('Grupo', 'Usuários associados'),
            });
        }

        // Chamar o repositório para deletar o grupo
        const data = await this.repository.deletar(id);
        return data;
    }

    //-------------------------------------------------------------------------------------------------
    /**
     * MÉTODOS AUXILIARES
     */

    /**
     * Valida a unicidade do nome do grupo.
     */
    async validateGroupName(nome, id = null) {
        const grupoExistente = await this.repository.buscarPorNome(nome, id);
        if (grupoExistente) {
            throw new CustomError({
                statusCode: 400,
                errorType: 'validationError',
                field: 'nome',
                details: [{ path: 'nome', message: 'Nome já está em uso.' }],
                customMessage: 'Nome já está em uso.',
            });
        }
    }

    /**
     * Valida o array de permissões.
     */
    async validatePermissions(permissoes) {
        if (!permissoes) {
            return [];
        }

        if (permissoes.length > 0) {
            PermissoesArraySchema.parse(permissoes);
        }

        const permissoesExistentes = await this.repository.buscarPorPermissao(permissoes);
        if (permissoesExistentes.length !== permissoes.length) {
            throw new CustomError({
                statusCode: 400,
                errorType: 'validationError',
                field: 'permissoes',
                details: [{ path: 'permissoes', message: 'Permissões inválidas.' }],
                customMessage: 'Permissões inválidas.',
            });
        }

        // Atualiza o array de permissões removendo as permissões inválidas
        return permissoesExistentes;
    }

    /**
     * Garante que o grupo existe.
     */
    async ensureGroupExists(id) {
        const grupoExistente = await this.repository.buscarPorId(id);
        if (!grupoExistente) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Grupo',
                details: [],
                customMessage: messages.error.resourceNotFound('Grupo'),
            });
        }
    }
}

export default GrupoService;

===== ./services/PermissionService.js =====


===== # =====


===== separador =====


===== legível =====

// services/PermissionService.js

import Usuario from "../models/Usuario.js";
import Grupo from "../models/Grupo.js";
import Rota from '../models/Rota.js';
import UsuarioRepository from '../repositories/UsuarioRepository.js';
import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';

class PermissionService {
    constructor() {
        this.repository = new UsuarioRepository();
        this.Usuario = Usuario;
        this.Grupo = Grupo;
        this.Rota = Rota;
        this.messages = messages;        
    }

    async hasPermission(userId, rota, dominio, metodo) {
        try {
            const usuario = await this.repository.buscarPorId(userId, { grupos: true });
            if (!usuario) {
                throw new CustomError({
                    statusCode: 404,
                    errorType: 'resourceNotFound',
                    field: 'Usuário',
                    details: [],
                    customMessage: messages.error.resourceNotFound('Usuário')
                });
            }

            let permissoes = usuario.permissoes || [];

            for (const grupo of usuario.grupos) {
                permissoes = permissoes.concat(grupo.permissoes || []);
            }

            const permissoesUnicas = [];
            const combinacoes = new Set();

            permissoes.forEach(permissao => {
                const chave = `${permissao.rota}_${permissao.dominio}`;
                if (!combinacoes.has(chave)) {
                    combinacoes.add(chave);
                    permissoesUnicas.push(permissao);
                }
            });

            const hasPermissao = permissoesUnicas.some(permissao => {
                return (
                    permissao.rota === rota &&
                    permissao.dominio === dominio &&
                    permissao.ativo &&
                    permissao[metodo] 
                );
            });

            return hasPermissao;
        } catch (error) {
            console.error("Erro ao verificar permissões:", error);
            return false;
        }
    }
}

export default PermissionService;

===== ./services/RefeicaoService.js =====


===== # =====


===== separador =====


===== legível =====

import Refeicao from "../models/Refeicao.js";
import Estudante from "../models/Estudante.js";
import RefeicaoTurma from "../models/RefeicaoTurma.js";
import Projetos from "../models/Projeto.js";
import Estagio from "../models/Estagio.js";
import { endOfDay, startOfDay, format } from "date-fns";

class RefeicaoService {
  static registrar = async (matricula, usuario) => {
    const dataAtual = new Date();
    const semana = [
      "domingo",
      "segunda",
      "terca",
      "quarta",
      "quinta",
      "sexta",
      "sabado",
    ];
    const diaSemana = dataAtual.getDay(); // Domingo - Sabado : 0 - 6

    const estudante = await Estudante.findById(matricula).populate({
      path: "turma",
      populate: { path: "curso" },
    });

    if (!estudante) {
      throw new Error("Estudante não encontrado");
    }

    if(!estudante.ativo){
      throw new Error("Estudante não está ativo!");
    }

    let tipoRefeicao;
    let podeComer;

    if (estudante.turma.curso.contra_turnos[semana[diaSemana]]) {
      tipoRefeicao = "Contra turno";
      podeComer = estudante.turma.curso.contra_turnos[semana[diaSemana]];
    }

    if (!podeComer) {
      //Se ele não pode comer pelo turno do curso dele,procura o turno do projeto
      const projeto = await Projetos.find({ estudantes: matricula });
      for (let i = 0; i < projeto.length; i++) {
        //Caso tenha mais de um projeto
        if (
          projeto[i].data_inicio <= dataAtual &&
          projeto[i].data_termino >= dataAtual
        ) {
          if (projeto[i].turnos[semana[diaSemana]]) {
            podeComer = true;
            tipoRefeicao = "Projeto";
            break;
          }
        }
      }
    }
    if (!podeComer) {
      const estagio = await Estagio.find({ estudante: matricula });
      for (let i = 0; i < estagio.length; i++) {
        if (
          estagio[i].data_inicio <= dataAtual &&
          estagio[i].data_termino >= dataAtual
        ) {
          if (estagio[i].turnos[semana[diaSemana]]) {
            podeComer = true;
            tipoRefeicao = "Estágio";
            break;
          }
        }
      }
    }
    if (!podeComer) {
      const refeicaoTurma = await RefeicaoTurma.find({
        turma: estudante.turma._id,
      });

      for (let i = 0; i < refeicaoTurma.length; i++) {
        if (
          format(refeicaoTurma[i].data_liberado, "yyyy/MM/dd") ==
          format(dataAtual, "yyyy/MM/dd")
        ) {
          podeComer = true;
          tipoRefeicao = "Turma";
          break;
        }
      }
    }

    //Não tem refeição se já tiver uma refeição registrada no dia de hoje
    if (podeComer) {
      const refeicao = await Refeicao.findOne({
        "estudante.matricula": matricula,
        data: {
          $gte: startOfDay(dataAtual),
          $lt: endOfDay(dataAtual),
        },
      });
      if (refeicao) {
        throw new Error("O estudante já teve refeição hoje!");
      }
    }

    if (!podeComer) {
      throw new Error("O estudante não pode ter refeição hoje!");
    }

    await Refeicao.create({
      estudante: {
        nome: estudante.nome,
        matricula: estudante.matricula,
        curso: estudante.turma.curso.nome,
        turma: estudante.turma.descricao,
      },
      tipoRefeicao: tipoRefeicao,
      data: dataAtual,
      usuarioRegistrou: usuario,
    });
  };

  static relatorio = async (dataInicio, dataTermino, filtros) => {

    const mongooseFilters = {};

    for(const [key, value] of Object.entries(filtros)) {
      if(key == "email") {
        mongooseFilters["usuarioRegistrou.email"] = { $regex: new RegExp(value, "i") };
        continue;
      }

      if(key == "turma") {
        mongooseFilters["estudante.turma"] = { $regex: new RegExp(value, "i") };
        continue;
      }

      if(key == "curso") {
        mongooseFilters["estudante.curso"] = { $regex: new RegExp(value, "i") };
        continue;
      }

      //O resto é tratado como filtro(acho que é apenas o tipoRefeicao);
      if(value) {
        mongooseFilters[key] = { $regex: new RegExp(value, "i") };
      }
    }

    const total = async () => {
      const total = await Refeicao.where({
        data: {
          $gte: startOfDay(dataInicio),
          $lt: endOfDay(dataTermino),
        },
        ...mongooseFilters
      }).countDocuments();
      return { totalRefeicoes: total };
    };

    const contraTurno = async () => {
      const contraTurno = await Refeicao.where({
        data: {
          $gte: startOfDay(dataInicio),
          $lt: endOfDay(dataTermino),
        },
        tipoRefeicao: "Contra turno",
      }).countDocuments();
      return { contraTurno: contraTurno };
    };

    const projeto = async () => {
      const projeto = await Refeicao.where({
        data: {
          $gte: startOfDay(dataInicio),
          $lt: endOfDay(dataTermino),
        },
        tipoRefeicao: "Projeto",
      }).countDocuments();
      return { projeto: projeto };
    };

    const estagio = async () => {
      const estagio = await Refeicao.where({
        data: {
          $gte: startOfDay(dataInicio),
          $lt: endOfDay(dataTermino),
        },
        tipoRefeicao: "Estágio",
      }).countDocuments();
      return { estagio: estagio };
    };

    const turma = async () => {
      const turma = await Refeicao.where({
        data: {
          $gte: startOfDay(dataInicio),
          $lt: endOfDay(dataTermino),
        },
        tipoRefeicao: "Turma",
      }).countDocuments();
      return { turma: turma };
    };

    const refeicoesFind = async () => {
      const refeicoes = await Refeicao.find({
        data: {
          $gte: startOfDay(dataInicio),
          $lt: endOfDay(dataTermino),
        },
        ...mongooseFilters
      });
      return { refeicoes: refeicoes };
    };

    // Utilizando Promise.all para executar as consultas de forma paralela
    const relatorio = await Promise.all([
      total(),
      contraTurno(),
      projeto(),
      estagio(),
      turma(),
      refeicoesFind(),
    ])
      .then((values) => {
        const { refeicoes, ...quantidade } = Object.assign({}, ...values);
        return Object.assign(
          { dataInicio: dataInicio, dataTermino: dataTermino },
          { quantidade: quantidade },
          { refeicoes: refeicoes }
        );
      })
      .catch((error) => {
        throw error;
      });
    return relatorio;
  };

  static totalHoje = async () => {
    const total = await Refeicao.where({
      data: {
        $gte: startOfDay(new Date()),
        $lt: endOfDay(new Date()),
      },
    }).countDocuments();

    return total;
  };
}

export default RefeicaoService;

===== ./services/RotaService.js =====


===== # =====


===== separador =====


===== legível =====

// src/services/RotaService.js

import RotaRepository from '../repositories/RotaRepository.js';

class RotaService {
    constructor() {
        this.repository = new RotaRepository();
    }

    /**
     * Validação nesta aplicação segue o seguinte artigo:
     * https://docs.google.com/document/d/1m2Ns1rIxpUzG5kRsgkbaQFdm7od0e7HSHfaSrrwegmM/edit?usp=sharing
     */

    /**
     * Lista rotas. Se um ID é fornecido, retorna uma rota.
     * Caso contrário, retorna todas as rotas com suporte a filtros e paginação.
     */

    async listar(req) {
        console.log('Estou no listar em RotaService');
        const data = await this.repository.listar(req);
        console.log('Estou retornando os dados em RotaService');
        return data;
    }

    async criar(req) {
        console.log('Estou no criar em RotaService');
        return await this.repository.criar(req);
    }


    async atualizar(parsedData, id) {
        console.log('Estou no atualizar em RotaService');

        // Garante que a rota exista
        await this.ensureRouteExists(id);

        // Chamada para atualizar a rotas
        const data = await this.repository.atualizar(id, parsedData);
        return data;
    }

    async deletar(req) {
        console.log('Estou no deletar em RotaService');
        return await deletar(this.repository.deletar.bind(this.repository), req);
    }

    /**
     * Garante que a rota exista.
     */
    async ensureRouteExists(id) {
        const data = await this.repository.buscarPorId(id);
        if (!data) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Rota',
                details: [],
                customMessage: messages.error.resourceNotFound('Rota'),
            });
        }
    }

}

export default RotaService;

===== ./services/TurmaService.js =====


===== # =====


===== separador =====


===== legível =====

// src/services/TurmaService.js

import TurmaRepository from '../repositories/TurmaRepository.js';

class TurmaService {
  constructor() {
    this.repository = new TurmaRepository();
  }

  // GET /turmas ou /turmas/:id
  async listar(req) {
    console.log('Estou no listar em TurmaService');
    const data = await this.repository.listar(req);
    return data;
  }

  // POST /turmas
  async criar(dados) {
    console.log('Estou no criar em TurmaService');
    const data = await this.repository.criar(dados);
    return data;
  }

  // GET /turmas/:id
  async buscarPorId(id) {
    console.log('Estou no buscarPorId em TurmaService');
    const data = await this.repository.buscarPorId(id);
    return data;
  }

  // PUT /turmas/:id
  async atualizar(id, dados) {
    console.log('Estou no atualizar em TurmaService');
    const data = await this.repository.atualizar(id, dados);
    return data;
  }

  // DELETE /turmas/:id
  async deletar(id) {
    console.log('Estou no deletar em TurmaService');
    const data = await this.repository.deletar(id);
    return data;
  }
}

export default TurmaService;

===== ./services/UnidadeService.js =====


===== # =====


===== separador =====


===== legível =====

// src/services/UnidadeService.js

import UnidadeRepository from '../repositories/UnidadeRepository.js';
import {
    CommonResponse,
    CustomError,
    HttpStatusCodes,
    errorHandler,
    messages,
    StatusService,
    asyncWrapper,
} from '../utils/helpers/index.js';
import { UnidadeQuerySchema, UnidadeIdSchema } from '../utils/validators/schemas/zod/querys/UnidadeQuerySchema.js';
import { UnidadeSchema, UnidadeUpdateSchema } from '../utils/validators/schemas/zod/UnidadeSchema.js';

class UnidadeService {
    constructor() {
        this.repository = new UnidadeRepository();
    }

    /**
     * Lista as unidades. Recebe um objeto _req_ (por exemplo, com query params)
     */
    async listar(req) {
        console.log('Estou no listar em UnidadeService');
        const data = await this.repository.listar(req);
        return data;
    }

    /**
     * Cria uma unidade, após verificar se já existe (nome + localidade) e validar os dados.
     */
    async criar(req) {
        console.log('Estou no criar em UnidadeService');

        // Verifica se já existe uma unidade com o mesmo nome e localidade
        const unidadeExistente = await this.repository.buscarPorNome(req.body.nome, req.body.localidade);
        if (unidadeExistente) {
            throw new CustomError({
                statusCode: 400,
                errorType: 'validationError',
                field: 'nome',
                details: [],
                customMessage: messages.validation.generic.resourceAlreadyExists('Nome'),
            });
        }

        // Validação dos dados usando o schema do Zod
        const unidadeValidada = await UnidadeSchema.parseAsync(req.body);

        // Cria a unidade no repositório
        const data = await this.repository.criar(unidadeValidada);
        return data;
    }

    /**
     * Atualiza uma unidade com base no ID passado em req.params
     */
    async atualizar(req) {
        console.log('Estou no atualizar em UnidadeService');

        const id = req.params.id;

        // Se o ID não for informado, lança erro
        if (!id) {
            throw new CustomError({
                statusCode: 400,
                errorType: 'validationError',
                field: 'id',
                details: [],
                customMessage: messages.validation.generic.fieldIsRequired('ID'),
            });
        }

        // Inclui o id nos dados para validação
        const dadosAtualizacao = { ...req.body, id };

        // Validação dos dados de atualização
        const unidadeValida = await UnidadeUpdateSchema.parseAsync(dadosAtualizacao);

        // Atualiza a unidade no repositório
        const data = await this.repository.atualizar(id, unidadeValida);
        return data;
    }

    /**
     * Deleta uma unidade com base no ID.
     *
     * Antes de deletar, garante que:
     *   - A unidade existe.
     *   - Não há usuários associados.
     */
    async deletar(id) {
        console.log('Estou no deletar em UnidadeService');

        // Garante que a unidade existe (caso contrário, lança erro)
        await this.ensureUnitExists(id);

        // Verifica se a unidade (ou grupo) está associada a algum usuário
        const usuariosAssociados = await this.repository.verificarUsuariosAssociados(id);

        if (usuariosAssociados) {
            throw new CustomError({
                statusCode: 400,
                errorType: 'resourceConflict',
                field: 'Grupo',
                details: [],
                customMessage: messages.error.resourceConflict('Grupo', 'Usuários associados'),
            });
        }

        // Deleta a unidade
        const data = await this.repository.deletar(id);
        return data;
    }

    /**
     * Garante que a unidade existe; caso contrário, lança um erro.
     */
    async ensureUnitExists(id) {
        const unidadeExistente = await this.repository.buscarPorId(id);
        if (!unidadeExistente) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Unidade',
                details: [],
                customMessage: messages.error.resourceNotFound('Unidade'),
            });
        }
    }
}

export default UnidadeService;

===== ./services/UsuarioService.js =====


===== # =====


===== separador =====


===== legível =====

// /src/services/UsuarioService.js
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
import UsuarioRepository from '../repositories/UsuarioRepository.js';
import { PermissoesArraySchema } from '../utils/validators/schemas/zod/PermissaoValidation.js';
import { UsuarioSchema, UsuarioUpdateSchema } from '../utils/validators/schemas/zod/UsuarioSchema.js';
import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';
import AuthHelper from '../utils/AuthHelper.js';

class UsuarioService {
    constructor() {
        this.repository = new UsuarioRepository();
    }

    /**
     * Lista usuários. Se um objeto de request é fornecido (com query, por exemplo),
     * retorna os usuários conforme os filtros.
     */
    async listar(req) {
        console.log('Estou no listar em UsuarioService');
        const data = await this.repository.listar(req);
        console.log('Estou retornando os dados em UsuarioService');
        return data;
    }

    /**
     * Cria um novo usuário após validação dos dados.
     */
    async criar(parsedData) {
        console.log('Estou no criar em UsuarioService');

        // Valida a unicidade do email
        await this.validateEmail(parsedData.email);

        console.log('Estou validando o schema em UsuarioService');

        // Valida e processa o array de permissões
        parsedData.permissoes = await this.validatePermissions(parsedData.permissoes);

        console.log('Estou processando o schema em UsuarioService' + parsedData);

        // Chama o repositório para criar o usuário
        const data = await this.repository.criar(parsedData);

        return data;
    }

    /**
     * Atualiza um usuário existente.
     * Atenção: É proibido alterar o email. No serviço o objeto sempre chegará sem, pois o controller impedirá.
     */
    async atualizar(id, parsedData) {
        console.log('Estou no atualizar em UsuarioService');

        /**
          * REGRA DE NEGÓCIO
        */

        if (!parsedData.ativo) {
            // gerar um novo objeto com tokens nulos se o user estiver sendo desativado
            parsedData.accesstoken = null
            parsedData.refreshtoken = null
        }

        // Senha nunca deve ser atualizada
        delete parsedData.senha;
        delete parsedData.email;

        // Garante que o usuário existe
        await this.ensureUserExists(id);

        // Se forem informadas permissões, valida-as
        if (parsedData.permissoes) {
            parsedData.permissoes = await this.validatePermissions(parsedData.permissoes);
        }
                 
        const data = await this.repository.atualizar(id, parsedData);
        return data;
    }

    /**
     * Deleta um usuário existente.
     */
    async deletar(id) {
        console.log('Estou no deletar em UsuarioService');

        // Garante que o usuário existe
        await this.ensureUserExists(id);

        const data = await this.repository.deletar(id);
        return data;
    }

    /**
     * Adiciona permissões a um usuário.
     */
    async adicionarPermissoes(req) {
        const parsedPermissoes = PermissoesArraySchema.parse(req.body.permissoes);
        const result = await this.repository.adicionarPermissoes(req.params.id, parsedPermissoes);
        return result;
    }

    /**
     * Remove uma permissão de um usuário.
     */
    async removerPermissao(usuarioId, permissaoId) {
        const result = await this.repository.removerPermissao(usuarioId, permissaoId);
        return result;
    }

    /**
     * Atualiza as permissões de um usuário.
     */
    async atualizarPermissoes(usuarioId, permissoesData) {
        const parsedData = PermissoesArraySchema.parse(permissoesData);
        const result = await this.repository.atualizarPermissoes(usuarioId, parsedData);
        return result;
    }

    ////////////////////////////////////////////////////////////////////////////////
    // MÉTODOS AUXILIARES
    ////////////////////////////////////////////////////////////////////////////////

    /**
     * Valida a unicidade do email.
     */
    async validateEmail(email, id = null) {
        const usuarioExistente = await this.repository.buscarPorEmail(email, id);
        if (usuarioExistente) {
            throw new CustomError({
                statusCode: HttpStatusCodes.BAD_REQUEST.code,
                errorType: 'validationError',
                field: 'email',
                details: [{ path: 'email', message: 'Email já está em uso.' }],
                customMessage: 'Email já está em uso.',
            });
        }
    }

    /**
     * Valida o array de permissões.
     */
    async validatePermissions(permissoes) {
        // Se permissoes não for um array, define como array vazio
        if (!Array.isArray(permissoes)) {
            permissoes = [];
        }

        if (permissoes.length > 0) {
            PermissoesArraySchema.parse(permissoes);
        }

        const permissoesExistentes = await this.repository.buscarPorPermissao(permissoes);

        if (permissoesExistentes.length !== permissoes.length) {
            throw new CustomError({
                statusCode: 400,
                errorType: 'validationError',
                field: 'permissoes',
                details: [{ path: 'permissoes', message: 'Permissões inválidas.' }],
                customMessage: 'Permissões inválidas.',
            });
        }

        return permissoesExistentes;
    }

    /**
     * Garante que o usuário existe.
     */
    async ensureUserExists(id) {
        const usuarioExistente = await this.repository.buscarPorId(id);
        if (!usuarioExistente) {
            throw new CustomError({
                statusCode: 404,
                errorType: 'resourceNotFound',
                field: 'Usuário',
                details: [],
                customMessage: messages.error.resourceNotFound('Usuário'),
            });
        }
        return usuarioExistente;
    }
}

export default UsuarioService;

===== ./tests/unit/controllers/UsuarioController.test.js =====


===== # =====


===== separador =====


===== legível =====

// =================================================================
// Mocks que precisam ser definidos ANTES de quaisquer outros imports
// =================================================================

// Atualize o mock do sharp para incluir as propriedades faltantes.
jest.mock('sharp', () => {
    // Função que simula o encadeamento do resize e toBuffer
    const resizeToBufferMock = jest.fn(() => Promise.resolve(Buffer.from('resized image')));
    const resizeMock = jest.fn(() => ({
      toBuffer: resizeToBufferMock,
    }));
  
    // Função principal do sharp
    const sharpMock = jest.fn(() => ({
      resize: resizeMock,
    }));
  
    // Adiciona as propriedades necessárias para a configuração da imagem
    sharpMock.fit = { cover: 'cover' };
    sharpMock.strategy = { entropy: 'entropy' };
  
    return sharpMock;
  });
  
  // Mock do mongoose, simulando Schema e Types
  jest.mock('mongoose', () => {
    class Schema {
      constructor(definition, options) {
        this.definition = definition;
        this.options = options;
        this.index = jest.fn();
        this.plugin = jest.fn();
      }
    }
    Schema.prototype.pre = jest.fn();
    Schema.Types = { ObjectId: 'ObjectId' };
  
    return {
      Schema,
      model: jest.fn(() => ({})),
      connect: jest.fn(),
      connection: {
        on: jest.fn(),
        once: jest.fn(),
        close: jest.fn()
      }
    };
  });
  
  // Mock do uuid
  jest.mock('uuid', () => ({
    v4: jest.fn(() => 'fixed-uuid')
  }));
  
  // Mock dos helpers - IMPORTANTE: usar o mesmo caminho relativo do controller
  jest.mock('../../../utils/helpers/index.js', () => {
    return {
      CommonResponse: {
        success: jest.fn(),
        created: jest.fn()
      },
      CustomError: jest.fn((opts) => {
        const err = new Error(opts.customMessage);
        err.statusCode = opts.statusCode;
        err.errorType = opts.errorType;
        err.field = opts.field;
        err.details = opts.details;
        return err;
      }),
      HttpStatusCodes: {
        BAD_REQUEST: { code: 400 },
        NOT_FOUND: { code: 404 }
      },
      errorHandler: jest.fn(),
      messages: {},
      StatusService: {},
      asyncWrapper: jest.fn()
    };
  });
  
  // Mocks dos schemas Zod
  jest.mock('../../../utils/validators/schemas/zod/UsuarioSchema.js', () => {
    return {
      UsuarioSchema: { parse: jest.fn() },
      UsuarioUpdateSchema: { parse: jest.fn() }
    };
  });
  
  jest.mock('../../../utils/validators/schemas/zod/querys/UsuarioQuerySchema.js', () => {
    return {
      UsuarioQuerySchema: { parse: jest.fn() },
      UsuarioIdSchema: { parse: jest.fn() }
    };
  });
  
  // =================================================================
  // Agora, importe os módulos que serão testados
  // =================================================================
  import sharp from 'sharp';
  import path from 'path';
  import fs from 'fs';
  import { v4 as uuidv4 } from 'uuid';
  
  import UsuarioController from '../../../controllers/UsuarioController.js';
  import UsuarioService from '../../../services/UsuarioService.js';
  
  import {
    CommonResponse,
    CustomError,
    HttpStatusCodes
  } from '../../../utils/helpers/index.js';
  
  import {
    UsuarioSchema,
    UsuarioUpdateSchema
  } from '../../../utils/validators/schemas/zod/UsuarioSchema.js';
  
  import {
    UsuarioQuerySchema,
    UsuarioIdSchema
  } from '../../../utils/validators/schemas/zod/querys/UsuarioQuerySchema.js';
  
  // =================================================================
  // Testes para UsuarioController
  // =================================================================
  describe('UsuarioController', () => {
    let controller, req, res, next;
  
    beforeEach(() => {
      controller = new UsuarioController();
      res = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn(),
        setHeader: jest.fn(),
        sendFile: jest.fn()
      };
      req = { params: {}, query: {}, body: {}, files: {} };
      next = jest.fn();
  
      // Limpa os mocks
      CommonResponse.success.mockClear();
      CommonResponse.created.mockClear();
      UsuarioSchema.parse.mockClear();
      UsuarioUpdateSchema.parse.mockClear();
      UsuarioQuerySchema.parse.mockClear();
      UsuarioIdSchema.parse.mockClear();
  
      // Mocks do Service
      controller.service.listar = jest.fn();
      controller.service.criar = jest.fn();
      controller.service.atualizar = jest.fn();
      controller.service.deletar = jest.fn();
    });
  
    // ============================
    // Testes para o método listar
    // ============================
    describe('listar', () => {
      it('should list users and return response via CommonResponse.success when no id and empty query', async () => {
        const data = [{ id: 1, name: 'Test User' }];
        controller.service.listar.mockResolvedValue(data);
        req.params = {};
        req.query = {};
  
        await controller.listar(req, res);
        expect(controller.service.listar).toHaveBeenCalledWith(req);
        expect(CommonResponse.success).toHaveBeenCalledWith(res, data);
      });
  
      it('should call UsuarioIdSchema.parse when id is provided', async () => {
        req.params = { id: 'test-id' };
        req.query = {}; // query vazia
        const data = { id: 'test-id', name: 'Test' };
        controller.service.listar.mockResolvedValue(data);
  
        await controller.listar(req, res);
        expect(UsuarioIdSchema.parse).toHaveBeenCalledWith('test-id');
        expect(CommonResponse.success).toHaveBeenCalledWith(res, data);
      });
  
      it('should call UsuarioQuerySchema.parse when query is provided', async () => {
        req.params = {};
        req.query = { search: 'Test' };
        const data = [{ id: 1, name: 'Test User' }];
        controller.service.listar.mockResolvedValue(data);
  
        await controller.listar(req, res);
        expect(UsuarioQuerySchema.parse).toHaveBeenCalledWith(req.query);
        expect(CommonResponse.success).toHaveBeenCalledWith(res, data);
      });
  
      it('should validate both id and query if provided', async () => {
        req.params = { id: 'test-id' };
        req.query = { search: 'foo' };
        const data = { id: 'test-id', name: 'Test User' };
        controller.service.listar.mockResolvedValue(data);
  
        await controller.listar(req, res);
        expect(UsuarioIdSchema.parse).toHaveBeenCalledWith('test-id');
        expect(UsuarioQuerySchema.parse).toHaveBeenCalledWith(req.query);
        expect(CommonResponse.success).toHaveBeenCalledWith(res, data);
      });
  
      it('should log message in listar', async () => {
        const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
        req.params = {};
        req.query = {};
        controller.service.listar.mockResolvedValue([]);
        await controller.listar(req, res);
        expect(logSpy).toHaveBeenCalledWith('Estou no listar em UsuarioController');
        logSpy.mockRestore();
      });
    });
  
    // ============================
    // Testes para o método criar
    // ============================
    describe('criar', () => {
      it('should create a user and return response with 201', async () => {
        const userInput = { name: 'New User' };
        req.body = userInput;
        UsuarioSchema.parse.mockReturnValue(userInput);
  
        const createdData = { id: 2, ...userInput };
        controller.service.criar.mockResolvedValue(createdData);
  
        await controller.criar(req, res);
        expect(UsuarioSchema.parse).toHaveBeenCalledWith(req.body);
        expect(controller.service.criar).toHaveBeenCalledWith(userInput);
        expect(CommonResponse.created).toHaveBeenCalledWith(res, createdData);
      });
  
      it('should log message in criar', async () => {
        const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
        req.body = { name: 'New User' };
        UsuarioSchema.parse.mockReturnValue(req.body);
        const createdData = { id: 2, name: 'New User' };
        controller.service.criar.mockResolvedValue(createdData);
        await controller.criar(req, res);
        expect(logSpy).toHaveBeenCalledWith('Estou no criar em UsuarioController');
        logSpy.mockRestore();
      });
    });
  
    // ============================
    // Testes para o método atualizar
    // ============================
    describe('atualizar', () => {
      it('should update an existing user and return response via CommonResponse.success', async () => {
        const userUpdate = { name: 'Updated User' };
        req.params = { id: '67a55e30c516c13964c800c2' };
        req.body = userUpdate;
  
        UsuarioUpdateSchema.parse.mockReturnValue(userUpdate);
  
        const updatedData = { id: '67a55e30c516c13964c800c2', ...userUpdate };
        controller.service.atualizar.mockResolvedValue(updatedData);
  
        await controller.atualizar(req, res);
  
        expect(UsuarioUpdateSchema.parse).toHaveBeenCalledWith(req.body);
        expect(controller.service.atualizar).toHaveBeenCalledWith(
          '67a55e30c516c13964c800c2',
          userUpdate
        );
        expect(CommonResponse.success).toHaveBeenCalledWith(res, updatedData);
      });
  
      it('should log message in atualizar', async () => {
        const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
        req.params = { id: 'test-id' };
        req.body = { name: 'Updated User' };
        UsuarioUpdateSchema.parse.mockReturnValue(req.body);
        const updatedData = { id: 'test-id', name: 'Updated User' };
        controller.service.atualizar.mockResolvedValue(updatedData);
        await controller.atualizar(req, res);
        expect(logSpy).toHaveBeenCalledWith('Estou no atualizar em UsuarioController');
        logSpy.mockRestore();
      });
  
      it('should throw error in atualizar when id is missing', async () => {
        req.params = {}; // Sem id
        // Configura o mock para lançar erro se id for undefined
        UsuarioIdSchema.parse.mockImplementationOnce(() => { throw new Error("Invalid id"); });
        await expect(controller.atualizar(req, res)).rejects.toThrow("Invalid id");
      });
    });
  
    // ============================
    // Testes para o método deletar
    // ============================
    describe('deletar', () => {
      it('should delete a user and return response via CommonResponse.success', async () => {
        req.params = { id: '67a55e30c516c13964c800c2' };
        const deletionResult = { deleted: true };
        controller.service.deletar.mockResolvedValue(deletionResult);
  
        await controller.deletar(req, res);
        expect(controller.service.deletar).toHaveBeenCalledWith('67a55e30c516c13964c800c2');
        expect(CommonResponse.success).toHaveBeenCalledWith(
          res,
          deletionResult,
          200,
          'Usuário excluído com sucesso.'
        );
      });
  
      it('should throw an error when id is missing', async () => {
        req.params = {};
        await expect(controller.deletar(req, res)).rejects.toThrow(
          'ID do usuário é obrigatório para deletar.'
        );
      });
  
      it('should log message in deletar', async () => {
        const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
        req.params = { id: 'test-id' };
        const deletionResult = { deleted: true };
        controller.service.deletar.mockResolvedValue(deletionResult);
        await controller.deletar(req, res);
        expect(logSpy).toHaveBeenCalledWith('Estou no deletar em UsuarioController');
        logSpy.mockRestore();
      });
    });
  
    // ============================
    // Testes para o método fotoUpload
    // ============================
    describe('fotoUpload', () => {
      beforeEach(() => {
        req.params = { id: '67a55e30c516c13964c800c2' };
      });
  
      it('should upload a photo, update the user and return success response (uploads dir exists)', async () => {
        const fakeFile = {
          name: 'photo.jpg',
          data: Buffer.from('fake image data'),
          size: 1024,
          md5: 'fake-md5'
        };
        req.files = { file: fakeFile };
  
        // Validação dos dados para atualização da foto
        UsuarioUpdateSchema.parse.mockReturnValue({ link_foto: 'fixed-uuid.jpg' });
  
        // Mocks do sharp
        const toBufferMock = jest.fn().mockResolvedValue(Buffer.from('resized image'));
        const resizeMock = jest.fn().mockReturnValue({ toBuffer: toBufferMock });
        sharp.mockImplementation(() => ({ resize: resizeMock }));
  
        // Simula que o diretório de uploads já existe
        jest.spyOn(fs, 'existsSync').mockReturnValue(true);
        jest.spyOn(fs.promises, 'writeFile').mockResolvedValue();
  
        const updatedData = {
          id: '67a55e30c516c13964c800c2',
          link_foto: 'fixed-uuid.jpg'
        };
        controller.service.atualizar.mockResolvedValue(updatedData);
  
        await controller.fotoUpload(req, res, next);
  
        expect(CommonResponse.success).toHaveBeenCalledWith(
          res,
          expect.objectContaining({
            message: expect.any(String),
            dados: { link_foto: expect.any(String) },
            metadados: expect.any(Object)
          })
        );
        expect(controller.service.atualizar).toHaveBeenCalled();
      });
  
      it('should create uploads directory if it does not exist', async () => {
        const fakeFile = {
          name: 'photo.png',
          data: Buffer.from('image data'),
          size: 500,
          md5: 'dummy-md5'
        };
        req.files = { file: fakeFile };
  
        UsuarioUpdateSchema.parse.mockReturnValue({ link_foto: 'fixed-uuid.png' });
  
        const toBufferMock = jest.fn().mockResolvedValue(Buffer.from('resized image'));
        const resizeMock = jest.fn().mockReturnValue({ toBuffer: toBufferMock });
        sharp.mockImplementation(() => ({ resize: resizeMock }));
  
        // Simula que o diretório de uploads NÃO existe
        const existsSpy = jest.spyOn(fs, 'existsSync').mockReturnValue(false);
        const mkdirSpy = jest.spyOn(fs, 'mkdirSync').mockImplementation(() => {});
  
        jest.spyOn(fs.promises, 'writeFile').mockResolvedValue();
  
        const updatedData = {
          id: '67a55e30c516c13964c800c2',
          link_foto: 'fixed-uuid.png'
        };
        controller.service.atualizar.mockResolvedValue(updatedData);
  
        await controller.fotoUpload(req, res, next);
  
        expect(mkdirSpy).toHaveBeenCalled(); // Verifica se o diretório foi criado
        expect(CommonResponse.success).toHaveBeenCalled();
  
        existsSpy.mockRestore();
        mkdirSpy.mockRestore();
      });
  
      describe('error cases', () => {
        it('should call next with error when no file is provided', async () => {
          req.files = {};
          await controller.fotoUpload(req, res, next);
          expect(next).toHaveBeenCalled();
        });
  
        it('should call next with error when file extension is invalid', async () => {
          req.files = {
            file: {
              name: 'malware.exe',
              data: Buffer.from('data'),
              size: 100,
              md5: 'fake-md5'
            }
          };
          await controller.fotoUpload(req, res, next);
          expect(next).toHaveBeenCalled();
        });
      });
    });
  
    // ============================
    // Testes para o método getFoto
    // ============================
    describe('getFoto', () => {
      it('should retrieve and send the photo file', async () => {
        req.params = { id: '67a55e30c516c13964c800c2' };
        const fakeUser = { link_foto: 'photo.png' };
        controller.service.listar.mockResolvedValue(fakeUser);
  
        await controller.getFoto(req, res, next);
        expect(res.setHeader).toHaveBeenCalledWith('Content-Type', 'image/png');
        expect(res.sendFile).toHaveBeenCalled();
      });
  
      it('should set content type to application/octet-stream for unknown extension', async () => {
        req.params = { id: 'some-id' };
        const fakeUser = { link_foto: 'photo.unknown' };
        controller.service.listar.mockResolvedValue(fakeUser);
  
        await controller.getFoto(req, res, next);
        expect(res.setHeader).toHaveBeenCalledWith('Content-Type', 'application/octet-stream');
        expect(res.sendFile).toHaveBeenCalled();
      });
  
      it('should call next with error if user does not have a photo link_foto', async () => {
        req.params = { id: '67a55e30c516c13964c800c2' };
        const fakeUser = { link_foto: null };
        controller.service.listar.mockResolvedValue(fakeUser);
  
        await controller.getFoto(req, res, next);
        expect(next).toHaveBeenCalled();
      });
  
      it('should log message in getFoto', async () => {
        const logSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
        req.params = { id: 'test-id' };
        const fakeUser = { link_foto: 'photo.png' };
        controller.service.listar.mockResolvedValue(fakeUser);
        await controller.getFoto(req, res, next);
        expect(logSpy).toHaveBeenCalledWith('Estou no getFoto em UsuarioController');
        logSpy.mockRestore();
      });
    });
  });
  
===== ./tests/unit/middleware/asyncWrapper.test.js =====


===== # =====


===== separador =====


===== legível =====

import asyncWrapper from '../../../middlewares/asyncWrapper';

describe('asyncWrapper', () => {
    let req, res, next;

    beforeEach(() => {
        req = {};
        res = {};
        next = jest.fn();
    });

    it('should call the handler function', async () => {
        const handler = jest.fn().mockResolvedValue('success');
        const wrappedHandler = asyncWrapper(handler);

        await wrappedHandler(req, res, next);

        expect(handler).toHaveBeenCalledWith(req, res, next);
    });

    it('should call next with error if handler throws', async () => {
        const error = new Error('Test error');
        const handler = jest.fn().mockRejectedValue(error);
        const wrappedHandler = asyncWrapper(handler);

        await wrappedHandler(req, res, next);

        expect(next).toHaveBeenCalledWith(error);
    });

    it('should not call next if handler resolves', async () => {
        const handler = jest.fn().mockResolvedValue('success');
        const wrappedHandler = asyncWrapper(handler);

        await wrappedHandler(req, res, next);

        expect(next).not.toHaveBeenCalled();
    });
});
===== ./tests/unit/middleware/AuthMiddleware.test.js =====


===== # =====


===== separador =====


===== legível =====

import jwt from 'jsonwebtoken';
import AuthMiddleware from '../../../middlewares/AuthMiddleware.js';
import AuthenticationError from '../../../utils/errors/AuthenticationError.js';
import TokenExpiredError from '../../../utils/errors/TokenExpiredError.js';
import { CustomError } from '../../../utils/helpers/index.js';
import AuthService from '../../../services/AuthService.js';

describe('AuthMiddleware', () => {
    let req, res, next, authServiceOriginal;

    beforeEach(() => {
        req = {
            headers: {}
        };
        res = {};

        // Mock da função next
        next = jest.fn();

        // Salva a implementação original de carregatokens
        authServiceOriginal = AuthService.prototype.carregatokens;

        // Mock da função carregatokens
        AuthService.prototype.carregatokens = jest.fn();
    });

    afterEach(() => {
        // Restaura a função carregatokens original
        AuthService.prototype.carregatokens = authServiceOriginal;

        // Restaura jwt.verify e outros mocks
        jest.restoreAllMocks();
    });

    it('deve lançar AuthenticationError se nenhum cabeçalho de autorização estiver presente', async () => {
        await AuthMiddleware(req, res, next);
        expect(next).toHaveBeenCalledTimes(1);
        const error = next.mock.calls[0][0];
        expect(error).toBeInstanceOf(AuthenticationError);
        expect(error.message).toBe("O token de autenticação não existe!");
    });

    it('deve lançar AuthenticationError se o formato do cabeçalho de autorização for inválido', async () => {
        req.headers.authorization = 'InvalidToken';
        await AuthMiddleware(req, res, next);
        expect(next).toHaveBeenCalledTimes(1);
        const error = next.mock.calls[0][0];
        expect(error).toBeInstanceOf(AuthenticationError);
        expect(error.message).toBe("Formato do token de autenticação inválido!");
    });

    it('deve lançar AuthenticationError se o JWT for inválido', async () => {
        req.headers.authorization = 'Bearer invalidtoken';

        // Mock de jwt.verify para chamar o callback com um erro de token inválido
        jest.spyOn(jwt, 'verify').mockImplementation((token, secret, callback) => {
            callback(new jwt.JsonWebTokenError('invalid token'), null);
        });

        await AuthMiddleware(req, res, next);
        expect(next).toHaveBeenCalledTimes(1);
        const error = next.mock.calls[0][0];
        expect(error).toBeInstanceOf(AuthenticationError);
        expect(error.message).toBe("Token JWT inválido!");
    });

    it('deve lançar TokenExpiredError se o JWT estiver expirado', async () => {
        req.headers.authorization = 'Bearer expiredtoken';

        // Mock de jwt.verify para chamar o callback com um erro de token expirado
        jest.spyOn(jwt, 'verify').mockImplementation((token, secret, callback) => {
            callback(new jwt.TokenExpiredError('jwt expired', new Date()), null);
        });

        await AuthMiddleware(req, res, next);
        expect(next).toHaveBeenCalledTimes(1);
        const error = next.mock.calls[0][0];
        expect(error).toBeInstanceOf(TokenExpiredError);
        expect(error.message).toBe("O token JWT está expirado!");
    });

    it('deve lançar CustomError se o refreshtoken for inválido', async () => {
        req.headers.authorization = 'Bearer validtoken';

        // Mock de jwt.verify para chamar o callback com um payload válido
        jest.spyOn(jwt, 'verify').mockImplementation((token, secret, callback) => {
            callback(null, { id: 'userId' });
        });

        // Mock da função carregatokens para retornar refreshtoken nulo
        AuthService.prototype.carregatokens.mockResolvedValue({
            data: { refreshtoken: null }
        });

        await AuthMiddleware(req, res, next);
        expect(next).toHaveBeenCalledTimes(1);
        const error = next.mock.calls[0][0];
        expect(error).toBeInstanceOf(CustomError);
        expect(error.customMessage).toBe('Refresh token inválido, autentique novamente!');
    });

    it('deve anexar user_id à requisição e chamar next se o token for válido', async () => {
        req.headers.authorization = 'Bearer validtoken';

        // Mock de jwt.verify para chamar o callback com um payload válido
        jest.spyOn(jwt, 'verify').mockImplementation((token, secret, callback) => {
            callback(null, { id: 'userId' });
        });

        // Mock da função carregatokens para retornar um refreshtoken válido
        AuthService.prototype.carregatokens.mockResolvedValue({
            data: { refreshtoken: 'validrefreshtoken' }
        });

        await AuthMiddleware(req, res, next);
        expect(req.user_id).toBe('userId');
        expect(next).toHaveBeenCalledTimes(1);
        expect(next).toHaveBeenCalledWith();
    });

    // Novo teste para cobrir erros inesperados
    it('deve passar erros inesperados para o errorHandler', async () => {
        req.headers.authorization = 'Bearer validtoken';

        // Mock de jwt.verify para chamar o callback com um payload válido
        jest.spyOn(jwt, 'verify').mockImplementation((token, secret, callback) => {
            callback(null, { id: 'userId' });
        });

        // Mock da função carregatokens para lançar um erro inesperado
        const unexpectedError = new Error('Erro inesperado');
        AuthService.prototype.carregatokens.mockRejectedValue(unexpectedError);

        await AuthMiddleware(req, res, next);
        expect(next).toHaveBeenCalledTimes(1);
        const error = next.mock.calls[0][0];
        expect(error).toBe(unexpectedError);
    });

    // Novo teste para cobrir a linha 39
    it('deve lançar TokenExpiredError se a decodificação do token retornar null', async () => {
        req.headers.authorization = 'Bearer validtoken';

        // Mock de jwt.verify para chamar o callback com null
        jest.spyOn(jwt, 'verify').mockImplementation((token, secret, callback) => {
            callback(null, null); // Simula decodificação retornando null
        });

        await AuthMiddleware(req, res, next);
        expect(next).toHaveBeenCalledTimes(1);
        const error = next.mock.calls[0][0];
        expect(error).toBeInstanceOf(TokenExpiredError);
        expect(error.message).toBe("O token JWT está expirado!");
    });
});

===== ./tests/unit/middleware/AuthPermission.test.js =====


===== # =====


===== separador =====


===== legível =====

import jwt from 'jsonwebtoken';
import PermissionService from '../../../services/PermissionService.js';
import Rota from '../../../models/Rota.js';
import authPermission from '../../../middlewares/AuthPermission.js';
import { CustomError, errorHandler, messages } from '../utils/helpers/index.js';


// Mock dos módulos externos
jest.mock('jsonwebtoken');
jest.mock('../../../models/Rota.js');
jest.mock('../../../services/PermissionService.js', () => ({
  hasPermission: jest.fn(),
}));

describe('Middleware authPermission', () => {
    let req, res, next;

    beforeEach(() => {
        req = {
            headers: {},
            url: '',
            method: '',
        };

        res = {
            status: jest.fn().mockReturnThis(),
            json: jest.fn().mockReturnThis(),
        };

        next = jest.fn();

        // Limpar todas as chamadas anteriores dos mocks
        jest.clearAllMocks();
    });

    afterEach(() => {
        // Restaurar implementações originais, se necessário
        jest.restoreAllMocks();
    });

    it('deve retornar erro se o cabeçalho de autorização não estiver presente', async () => {
        await authPermission(req, res, next);

        expect(next).not.toHaveBeenCalled();
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ 
            message: messages.error.resourceNotFound('Token')
        }));
    });

    it('deve retornar erro se o token for inválido', async () => {
        req.headers.authorization = 'Bearer invalidtoken';
        jwt.verify.mockImplementation(() => { 
            throw new Error('invalid token'); 
        });

        await authPermission(req, res, next);

        expect(next).not.toHaveBeenCalled();
        expect(res.status).toHaveBeenCalledWith(401);
        expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ 
            message: 'Token de autenticação inválido ou expirado.' 
        }));
    });

    it('deve retornar erro se a rota não for encontrada no banco de dados', async () => {
        req.headers.authorization = 'Bearer validtoken';
        req.url = '/api/usuarios';
        req.method = 'GET';

        jwt.verify.mockReturnValue({ id: 'userId' });
        Rota.findOne.mockResolvedValue(null);

        await authPermission(req, res, next);

        expect(next).not.toHaveBeenCalled();
        expect(res.status).toHaveBeenCalledWith(404);
        expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ 
            message: 'Rota não encontrada.' 
        }));
    });

    it('deve retornar erro se o método HTTP não for suportado', async () => {
        req.headers.authorization = 'Bearer validtoken';
        req.url = '/api/usuarios';
        req.method = 'INVALID';

        jwt.verify.mockReturnValue({ id: 'userId' });

        await authPermission(req, res, next);

        expect(next).not.toHaveBeenCalled();
        expect(res.status).toHaveBeenCalledWith(405);
        expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ 
            message: 'Método HTTP não suportado.' 
        }));
    });

    it('deve retornar erro se a rota estiver inativa ou não suportar o método', async () => {
        req.headers.authorization = 'Bearer validtoken';
        req.url = '/api/usuarios';
        req.method = 'GET';

        jwt.verify.mockReturnValue({ id: 'userId' });
        Rota.findOne.mockResolvedValue({ ativo: false, buscar: false });

        await authPermission(req, res, next);

        expect(next).not.toHaveBeenCalled();
        expect(res.status).toHaveBeenCalledWith(403);
        expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ 
            message: 'Ação não permitida nesta rota.' 
        }));
    });

    it('deve retornar erro se o usuário não tiver permissão', async () => {
        req.headers.authorization = 'Bearer validtoken';
        req.url = '/api/usuarios';
        req.method = 'GET';

        jwt.verify.mockReturnValue({ id: 'userId' });
        Rota.findOne.mockResolvedValue({ ativo: true, buscar: true });
        PermissionService.hasPermission.mockResolvedValue(false);

        await authPermission(req, res, next);

        expect(next).not.toHaveBeenCalled();
        expect(res.status).toHaveBeenCalledWith(403);
        expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ 
            message: 'Você não tem permissão para realizar esta ação.' 
        }));
    });

    it('deve chamar next se o usuário tiver permissão', async () => {
        req.headers.authorization = 'Bearer validtoken';
        req.url = '/api/usuarios';
        req.method = 'GET';

        jwt.verify.mockReturnValue({ id: 'userId' });
        Rota.findOne.mockResolvedValue({ ativo: true, buscar: true });
        PermissionService.hasPermission.mockResolvedValue(true);

        await authPermission(req, res, next);

        expect(next).toHaveBeenCalled();
        expect(req.user).toEqual({ id: 'userId' });
    });
});

===== ./tests/unit/models/Grupo.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/models/Grupo.test.js
import mongoose from 'mongoose';
import Grupo from '../../../../src/models/Grupo.js';
import { MongoMemoryServer } from 'mongodb-memory-server';

let mongoServer;

// Configuração antes de todos os testes
beforeAll(async () => {
    mongoServer = await MongoMemoryServer.create();
    const uri = mongoServer.getUri();

    await mongoose.connect(uri);
});

// Limpeza após todos os testes
afterAll(async () => {
    await mongoose.disconnect();
    await mongoServer.stop();
});

// Limpeza após cada teste para garantir isolamento
afterEach(async () => {
    jest.clearAllMocks();
    await Grupo.deleteMany({});
});

describe('Grupo Model', () => {
    it('deve criar um Grupo com dados válidos', async () => {
        const grupoData = {
            nome: 'Grupo Teste',
            descricao: 'Descrição do Grupo Teste',
            ativo: true,
            unidades: [],
            permissoes: [
                {
                    rota: 'usuarios',
                    dominio: 'http://localhost:3000',
                    ativo: true,
                    buscar: true,
                    enviar: true,
                    substituir: true,
                    modificar: true,
                    excluir: true,
                },
            ],
        };

        const grupo = new Grupo(grupoData);
        const savedGrupo = await grupo.save();

        expect(savedGrupo.nome).toBe(grupoData.nome);
        expect(savedGrupo.descricao).toBe(grupoData.descricao);
        expect(savedGrupo.ativo).toBe(grupoData.ativo);
        expect(savedGrupo.permissoes.length).toBe(1);
        expect(savedGrupo.permissoes[0].rota).toBe(grupoData.permissoes[0].rota);
    });

    it('não deve criar um Grupo com rota + domínio duplicados em permissões', async () => {
        const grupoData = {
            nome: 'Grupo Teste Duplicado',
            descricao: 'Descrição do Grupo Teste Duplicado',
            ativo: true,
            unidades: [],
            permissoes: [
                {
                    rota: 'usuarios',
                    dominio: 'http://localhost:3000',
                    ativo: true,
                    buscar: true,
                    enviar: true,
                    substituir: true,
                    modificar: true,
                    excluir: true,
                },
                {
                    rota: 'usuarios',
                    dominio: 'http://localhost:3000',
                    ativo: true,
                    buscar: true,
                    enviar: true,
                    substituir: true,
                    modificar: true,
                    excluir: true,
                },
            ],
        };

        const grupo = new Grupo(grupoData);
        let error;

        try {
            await grupo.save();
        } catch (err) {
            error = err;
        }

        expect(error).toBeInstanceOf(Error);
        expect(error.message).toBe('Permissões duplicadas encontradas: rota + domínio devem ser únicos dentro de cada grupo.');
    });

    it('deve paginar os resultados corretamente', async () => {
        // Inserir múltiplos grupos para testar a paginação
        const grupos = [];
        for (let i = 1; i <= 15; i++) {
            grupos.push({
                nome: `Grupo ${i}`,
                descricao: `Descrição do Grupo ${i}`,
                ativo: true,
                unidades: [],
                permissoes: [
                    {
                        rota: `rota${i}`,
                        dominio: `http://localhost:${3000 + i}`,
                        ativo: true,
                        buscar: true,
                        enviar: true,
                        substituir: true,
                        modificar: true,
                        excluir: true,
                    },
                ],
            });
        }
        await Grupo.insertMany(grupos);

        const options = {
            page: 2,
            limit: 5,
        };

        const result = await Grupo.paginate({}, options);

        expect(result.docs.length).toBe(5);
        expect(result.page).toBe(2);
        expect(result.limit).toBe(5);
        expect(result.totalDocs).toBe(15);
        expect(result.totalPages).toBe(3);
    });
});

===== ./tests/unit/models/Rota.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/models/Rota.test.js
import mongoose from 'mongoose';
import { MongoMemoryServer } from 'mongodb-memory-server';
import Rota from '../../../../src/models/Rota';
import mongoosePaginate from 'mongoose-paginate-v2';

describe('Modelo Rota', () => {
    let mongoServer;
    let rota;

    // Aumenta o tempo limite padrão do Jest (opcional)
    jest.setTimeout(10000); // 10 segundos

    beforeAll(async () => {
        mongoServer = await MongoMemoryServer.create();
        const uri = mongoServer.getUri();

        await mongoose.connect(uri, {

        });
    });

    afterAll(async () => {
        await mongoose.disconnect();
        await mongoServer.stop();
    });

    beforeEach(() => {
        rota = new Rota({
            rota: 'test-route',
            dominio: 'test-domain'
        });
    });

    afterEach(async () => {
        // Limpa todos os dados após cada teste
        await Rota.deleteMany({});
    });

    it('deve ser inválido se "rota" estiver vazio', async () => {
        rota.rota = '';
        await expect(rota.validate()).rejects.toThrow();
        try {
            await rota.validate();
        } catch (error) {
            expect(error.errors.rota).toBeDefined();
        }
    });

    it('deve ser inválido se "dominio" estiver vazio', async () => {
        rota.dominio = '';
        await expect(rota.validate()).rejects.toThrow();
        try {
            await rota.validate();
        } catch (error) {
            expect(error.errors.dominio).toBeDefined();
        }
    });

    it('deve ter valores padrão para os campos booleanos', () => {
        expect(rota.ativo).toBe(true);
        expect(rota.buscar).toBe(true);
        expect(rota.enviar).toBe(true);
        expect(rota.substituir).toBe(true);
        expect(rota.modificar).toBe(true);
        expect(rota.excluir).toBe(true);
    });

    it('deve converter "rota" para minúsculas antes de salvar', async () => {
        rota.rota = 'Test-Route';
        const savedRota = await rota.save();
        expect(savedRota.rota).toBe('test-route');
    });

    it('deve remover espaços em branco de "rota" antes de salvar', async () => {
        rota.rota = '  test-route  ';
        const savedRota = await rota.save();
        expect(savedRota.rota).toBe('test-route');
    });

    it('deve criar um índice único para "rota" e "dominio"', async () => {
        await rota.save();

        const duplicateRota = new Rota({
            rota: 'test-route',
            dominio: 'test-domain'
        });

        await expect(duplicateRota.save()).rejects.toThrow();
    });

    it('deve utilizar o plugin mongoose-paginate-v2', () => {
        // Verifica se o método 'paginate' existe no modelo
        expect(typeof Rota.paginate).toBe('function');
    });

    it('deve ter timestamps', () => {
        expect(Rota.schema.options.timestamps).toBe(true);
    });
});

===== ./tests/unit/models/Unidade.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/models/Unidade.test.js
import mongoose from 'mongoose';
import Unidade from '../../../models/Unidade';
import mongoosePaginate from 'mongoose-paginate-v2';
import { MongoMemoryServer } from 'mongodb-memory-server';

let mongoServer;

// Configuração antes de todos os testes
beforeAll(async () => {
    mongoServer = await MongoMemoryServer.create();
    const uri = mongoServer.getUri();

    await mongoose.connect(uri, {
        // As opções useNewUrlParser e useUnifiedTopology são desnecessárias no Mongoose 6+
    });
});

// Limpeza após todos os testes
afterAll(async () => {
    await mongoose.disconnect();
    await mongoServer.stop();
});

// Limpeza após cada teste para garantir isolamento
afterEach(async () => {
    jest.clearAllMocks();
    // Remove todos os documentos para garantir que os testes sejam isolados
    await Unidade.deleteMany({});
});

describe('Unidade Model', () => {
    it('should be invalid if nome is empty', async () => {
        const unidade = new Unidade();

        await expect(unidade.validate()).rejects.toThrow(mongoose.ValidationError);
        await expect(unidade.validate()).rejects.toHaveProperty('errors.nome');
    });

    it('should be invalid if localidade is empty', async () => {
        const unidade = new Unidade({ nome: 'Unidade Teste' });

        await expect(unidade.validate()).rejects.toThrow(mongoose.ValidationError);
        await expect(unidade.validate()).rejects.toHaveProperty('errors.localidade');
    });

    it('should have default value of ativo as true', () => {
        const unidade = new Unidade({ nome: 'Unidade Teste', localidade: 'Localidade Teste' });
        expect(unidade.ativo).toBe(true);
    });

    it('should trim nome and localidade fields', async () => {
        const unidade = new Unidade({
            nome: '  Unidade Teste  ',
            localidade: '  Localidade Teste  '
        });

        const savedUnidade = await unidade.save();

        expect(savedUnidade.nome).toBe('Unidade Teste');
        expect(savedUnidade.localidade).toBe('Localidade Teste');
    });

    it('should have timestamps', async () => {
        const unidade = new Unidade({ nome: 'Unidade Teste', localidade: 'Localidade Teste' });
        const savedUnidade = await unidade.save();

        expect(savedUnidade.createdAt).toBeDefined();
        expect(savedUnidade.updatedAt).toBeDefined();
    });

    it('should have a composite index on nome and localidade', () => {
        const indexes = Unidade.schema.indexes();
        const compositeIndex = indexes.find(
            index =>
                Object.keys(index[0]).length === 2 &&
                index[0].nome === 1 &&
                index[0].localidade === 1 &&
                index[1].unique === true
        );

        expect(compositeIndex).toBeDefined();
    });

});

===== ./tests/unit/models/Usuario.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/models/Usuario.test.js
import mongoose from 'mongoose';
import Usuario from '../../../../src/models/Usuario.js';
import { MongoMemoryServer } from 'mongodb-memory-server';

// src/tests/unit/models/Usuario.test.js

let mongoServer;

// Configuração antes de todos os testes
beforeAll(async () => {
    mongoServer = await MongoMemoryServer.create();
    const uri = mongoServer.getUri();

    await mongoose.connect(uri, {
        // Opções de conexão não são necessárias no Mongoose 6+
    });
});

// Limpeza após todos os testes
afterAll(async () => {
    await mongoose.disconnect();
    await mongoServer.stop();
});

// Limpeza após cada teste para garantir isolamento
afterEach(async () => {
    jest.clearAllMocks();
    await Usuario.deleteMany({});
});

describe('Modelo de Usuário', () => {
    it('deve criar um usuário com dados válidos', async () => {
        const userData = {
            nome: 'Test User',
            email: 'test@example.com',
            senha: 'password123',
            link_foto: 'http://example.com/photo.jpg',
            ativo: true,
            permissoes: [
                {
                    rota: 'usuarios',
                    dominio: 'http://localhost:3000',
                    ativo: true,
                    buscar: true,
                    enviar: true,
                    substituir: true,
                    modificar: true,
                    excluir: true
                }
            ]
        };

        const user = new Usuario(userData);
        await user.save();

        const savedUser = await Usuario.findById(user._id).select('-senha'); // Busca o usuário sem o campo senha

        expect(savedUser.nome).toBe(userData.nome);
        expect(savedUser.email).toBe(userData.email);
        expect(savedUser.senha).toBeUndefined(); // Verificação para confirmar que senha não está presente
        expect(savedUser.link_foto).toBe(userData.link_foto);
        expect(savedUser.ativo).toBe(userData.ativo);
        expect(savedUser.permissoes.length).toBe(1);
        expect(savedUser.permissoes[0].rota).toBe(userData.permissoes[0].rota);
    });

    it('não deve criar um usuário com email duplicado', async () => {
        const userData = {
            nome: 'Test User',
            email: 'duplicate@example.com',
            senha: 'password123'
        };

        const user1 = new Usuario(userData);
        await user1.save();

        const user2 = new Usuario(userData);
        await expect(user2.save()).rejects.toThrowErrorMatchingSnapshot();
    });

    it('não deve criar um usuário com rota e domínio duplicados em permissões', async () => {
        const userData = {
            nome: 'Test User',
            email: 'test2@example.com',
            senha: 'password123',
            permissoes: [
                {
                    rota: 'usuarios',
                    dominio: 'http://localhost:3000',
                    ativo: true,
                    buscar: true,
                    enviar: true,
                    substituir: true,
                    modificar: true,
                    excluir: true
                },
                {
                    rota: 'usuarios',
                    dominio: 'http://localhost:3000',
                    ativo: true,
                    buscar: true,
                    enviar: true,
                    substituir: true,
                    modificar: true,
                    excluir: true
                }
            ]
        };

        const user = new Usuario(userData);
        await expect(user.save()).rejects.toThrowError('Permissões duplicadas encontradas: rota + domínio devem ser únicos dentro de cada usuário.');
    });

    it('deve criar um usuário com múltiplas permissões válidas', async () => {
        const userData = {
            nome: 'Test User',
            email: 'test3@example.com',
            senha: 'password123',
            permissoes: [
                {
                    rota: 'usuarios',
                    dominio: 'http://localhost:3000',
                    ativo: true,
                    buscar: true,
                    enviar: true,
                    substituir: true,
                    modificar: true,
                    excluir: true
                },
                {
                    rota: 'grupos',
                    dominio: 'http://localhost:3000',
                    ativo: true,
                    buscar: true,
                    enviar: true,
                    substituir: true,
                    modificar: true,
                    excluir: true
                }
            ]
        };

        const user = new Usuario(userData);
        await user.save();

        const savedUser = await Usuario.findById(user._id).select('-senha');

        expect(savedUser.permissoes.length).toBe(2);
        expect(savedUser.permissoes[0].rota).toBe(userData.permissoes[0].rota);
        expect(savedUser.permissoes[1].rota).toBe(userData.permissoes[1].rota);
    });

    it('deve criar um usuário com unidades e grupos válidos', async () => {
        const unidadeId = new mongoose.Types.ObjectId();
        const grupoId = new mongoose.Types.ObjectId();

        const userData = {
            nome: 'Test User',
            email: 'test4@example.com',
            senha: 'password123',
            unidades: [unidadeId],
            grupos: [grupoId]
        };

        const user = new Usuario(userData);
        await user.save();

        const savedUser = await Usuario.findById(user._id).select('-senha');

        expect(savedUser.unidades.length).toBe(1);
        expect(savedUser.unidades[0].toString()).toBe(unidadeId.toString());
        expect(savedUser.grupos.length).toBe(1);
        expect(savedUser.grupos[0].toString()).toBe(grupoId.toString());
    });
});


===== ./tests/unit/repository/AuthRepository.test.js =====


===== # =====


===== separador =====


===== legível =====

// AuthRepository.test.js
import mongoose from 'mongoose';
import AuthRepository from '../../../repositories/AuthRepository.js';
import UsuarioModel from '../../../models/Usuario.js';
import { CustomError, messages } from '../../../utils/helpers/index.js';

// Mockando o modelo de Usuário
jest.mock('../../../models/Usuario.js');

describe('AuthRepository', () => {
  let authRepository;

  beforeEach(() => {
    authRepository = new AuthRepository();
    jest.clearAllMocks(); // Limpa os mocks antes de cada teste
  });

  describe('armazenarTokens', () => {
    it('deve armazenar accesstoken e refreshtoken no banco de dados', async () => {
      const id = new mongoose.Types.ObjectId();
      const accesstoken = 'accesstoken';
      const refreshtoken = 'refreshtoken';
      const documento = {
        save: jest.fn().mockResolvedValue({ accesstoken: accesstoken, refreshtoken: refreshtoken }),
      };

      // Configurando o mock para retornar o documento diretamente quando findById for chamado com o id específico
      UsuarioModel.findById.mockResolvedValue(documento);

      const result = await authRepository.armazenarTokens(id, accesstoken, refreshtoken);

      expect(result.accesstoken).toBe(accesstoken);
      expect(result.refreshtoken).toBe(refreshtoken);
      expect(UsuarioModel.findById).toHaveBeenCalledWith(id);
      expect(documento.save).toHaveBeenCalled();
    });

    it('deve lançar um CustomError se o usuário não for encontrado', async () => {
      const id = new mongoose.Types.ObjectId();
      UsuarioModel.findById.mockResolvedValue(null);

      await expect(authRepository.armazenarTokens(id, 'accesstoken', 'refreshtoken')).rejects.toMatchObject({
        name: 'CustomError',
        statusCode: 404,
        customMessage: messages.error.resourceNotFound('Usuário'),
      });

      expect(UsuarioModel.findById).toHaveBeenCalledWith(id);
    });
  });

  describe('removeToken', () => {
    it('deve remover accesstoken e refreshtoken do usuário', async () => {
      const id = new mongoose.Types.ObjectId();
      const updatedUser = { accesstoken: null, refreshtoken: null };

      // Configurando o mock para retornar o usuário atualizado com exec()
      UsuarioModel.findByIdAndUpdate.mockReturnValue({
        exec: jest.fn().mockResolvedValue(updatedUser),
      });

      const result = await authRepository.removeToken(id);

      expect(result.accesstoken).toBeNull();
      expect(result.refreshtoken).toBeNull();
      expect(UsuarioModel.findByIdAndUpdate).toHaveBeenCalledWith(
        id,
        { accesstoken: null, refreshtoken: null },
        { new: true }
      );
    });

    it('deve lançar um CustomError se o usuário não for encontrado', async () => {
      const id = new mongoose.Types.ObjectId();
      UsuarioModel.findByIdAndUpdate.mockReturnValue({
        exec: jest.fn().mockResolvedValue(null),
      });

      await expect(authRepository.removeToken(id)).rejects.toMatchObject({
        name: 'CustomError',
        statusCode: 404,
        customMessage: messages.error.resourceNotFound('Usuário'),
      });

      expect(UsuarioModel.findByIdAndUpdate).toHaveBeenCalledWith(
        id,
        { accesstoken: null, refreshtoken: null },
        { new: true }
      );
    });
  });
});

===== ./tests/unit/repository/filters/GrupoFilterBuilder.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/repository/filters/GrupoFilterBuilder.test.js

import GrupoFilterBuilder from '../../../../filters/GrupoFilterBuilder.js';
import UnidadeRepository from '../../../../repositories/UnidadeRepository.js';

// Mock the UnidadeRepository
jest.mock('../../../../repositories/UnidadeRepository.js', () => {
    return jest.fn().mockImplementation(() => {
        return {
            buscarPorNome: jest.fn(),
        };
    });
});

describe('GrupoFilterBuilder', () => {
    let grupoFilterBuilder;
    let mockUnidadeRepository;

    beforeEach(() => {
        // Clear all previous mock calls and implementations
        jest.clearAllMocks();

        // Instantiate GrupoFilterBuilder
        grupoFilterBuilder = new GrupoFilterBuilder();

        // Get the mocked UnidadeRepository instance
        mockUnidadeRepository = UnidadeRepository.mock.instances[0];
    });

    // Test comNome
    describe('comNome', () => {
        it('deve adicionar filtro de nome se fornecido', () => {
            grupoFilterBuilder.comNome('Grupo1');
            expect(grupoFilterBuilder.filtros.nome).toEqual({ $regex: 'Grupo1', $options: 'i' });
            expect(grupoFilterBuilder.comNome).toHaveBeenCalledWith('Grupo1');
        });

        it('não deve adicionar filtro de nome se não fornecido', () => {
            grupoFilterBuilder.comNome('');
            expect(grupoFilterBuilder.filtros.nome).toBeUndefined();
            expect(grupoFilterBuilder.comNome).toHaveBeenCalledWith('');
        });
    });

    // Test comDescricao
    describe('comDescricao', () => {
        it('deve adicionar filtro de descrição se fornecido', () => {
            grupoFilterBuilder.comDescricao('Descricao1');
            expect(grupoFilterBuilder.filtros.descricao).toEqual({ $regex: 'Descricao1', $options: 'i' });
            expect(grupoFilterBuilder.comDescricao).toHaveBeenCalledWith('Descricao1');
        });

        it('não deve adicionar filtro de descrição se não fornecido', () => {
            grupoFilterBuilder.comDescricao('');
            expect(grupoFilterBuilder.filtros.descricao).toBeUndefined();
            expect(grupoFilterBuilder.comDescricao).toHaveBeenCalledWith('');
        });
    });

    // Test comAtivo
    describe('comAtivo', () => {
        it('deve adicionar filtro ativo como true', () => {
            grupoFilterBuilder.comAtivo('true');
            expect(grupoFilterBuilder.filtros.ativo).toBe(true);
            expect(grupoFilterBuilder.comAtivo).toHaveBeenCalledWith('true');
        });

        it('deve adicionar filtro ativo como false', () => {
            grupoFilterBuilder.comAtivo('false');
            expect(grupoFilterBuilder.filtros.ativo).toBe(false);
            expect(grupoFilterBuilder.comAtivo).toHaveBeenCalledWith('false');
        });

        it('não deve alterar filtro ativo se valor inválido', () => {
            grupoFilterBuilder.filtros.ativo = true; // Initial value
            grupoFilterBuilder.comAtivo('maybe');
            expect(grupoFilterBuilder.filtros.ativo).toBe(true); // No change
            expect(grupoFilterBuilder.comAtivo).toHaveBeenCalledWith('maybe');
        });
    });

    // Test comUnidade
    describe('comUnidade', () => {
        it('deve adicionar filtro unidades se unidade encontrada', async () => {
            mockUnidadeRepository.buscarPorNome.mockResolvedValue([
                { _id: 'unidade1' },
                { _id: 'unidade2' },
            ]);

            await grupoFilterBuilder.comUnidade('Unidade1');

            expect(mockUnidadeRepository.buscarPorNome).toHaveBeenCalledWith('Unidade1');
            expect(grupoFilterBuilder.filtros.unidades).toEqual({ $in: ['unidade1', 'unidade2'] });
        });

        it('deve adicionar filtro unidades como array vazio se unidade não encontrada', async () => {
            mockUnidadeRepository.buscarPorNome.mockResolvedValue(null);

            await grupoFilterBuilder.comUnidade('UnidadeX');

            expect(mockUnidadeRepository.buscarPorNome).toHaveBeenCalledWith('UnidadeX');
            expect(grupoFilterBuilder.filtros.unidades).toEqual({ $in: [] });
        });

        it('não deve adicionar filtro unidades se unidade não fornecida', async () => {
            await grupoFilterBuilder.comUnidade(undefined);

            expect(mockUnidadeRepository.buscarPorNome).not.toHaveBeenCalled();
            expect(grupoFilterBuilder.filtros.unidades).toBeUndefined();
        });
    });

    // Test escapeRegex
    describe('escapeRegex', () => {
        it('deve escapar caracteres especiais em texto', () => {
            const texto = 'Grupo.*?+[]()';
            const textoEscapado = grupoFilterBuilder.escapeRegex(texto);
            expect(textoEscapado).toBe('Grupo\\.\\*\\?\\+\\[\\]\\(\\)');
        });
    });

    // Test build
    describe('build', () => {
        it('deve retornar os filtros construídos', () => {
            grupoFilterBuilder.filtros = {
                nome: { $regex: 'Grupo1', $options: 'i' },
                descricao: { $regex: 'Descricao1', $options: 'i' },
                ativo: true,
                unidades: { $in: ['unidade1'] },
            };
            const filtros = grupoFilterBuilder.build();
            expect(filtros).toEqual(grupoFilterBuilder.filtros);
        });
    });
});

===== ./tests/unit/repository/filters/UnidadeFilterBuilder.test.js =====


===== # =====


===== separador =====


===== legível =====

import assert from 'assert';
import UnidadeFilterBuilder from '../../../../../src/repositories/filters/UnidadeFilterBuilder.js';

describe('UnidadeFilterBuilder', () => {
    let builder;

    beforeEach(() => {
        builder = new UnidadeFilterBuilder();
    });

    it('deve inicializar com filtros vazios', () => {
        const filtros = builder.build();
        assert.deepStrictEqual(filtros, {}, 'Os filtros devem estar vazios');
    });

    it('deve adicionar filtro de nome quando comNome é chamado com um nome', () => {
        const name = 'testName';
        builder.comNome(name);
        const filtros = builder.build();
        assert.ok(filtros.hasOwnProperty('nome'), 'Deve possuir a propriedade "nome"');
        assert.deepStrictEqual(filtros.nome, { $regex: name, $options: 'i' }, 'O filtro "nome" deve estar correto');
    });

    it('não deve adicionar filtro de nome quando comNome é chamado com um nome vazio', () => {
        builder.comNome('');
        const filtros = builder.build();
        assert.ok(!filtros.hasOwnProperty('nome'), 'Não deve possuir a propriedade "nome"');
    });

    it('deve adicionar filtro de localidade quando comLocalidade é chamado com uma localidade', () => {
        const localidade = 'testLocalidade';
        builder.comLocalidade(localidade);
        const filtros = builder.build();
        assert.ok(filtros.hasOwnProperty('localidade'), 'Deve possuir a propriedade "localidade"');
        assert.deepStrictEqual(filtros.localidade, { $regex: localidade, $options: 'i' }, 'O filtro "localidade" deve estar correto');
    });

    it('não deve adicionar filtro de localidade quando comLocalidade é chamado com uma localidade vazia', () => {
        builder.comLocalidade('');
        const filtros = builder.build();
        assert.ok(!filtros.hasOwnProperty('localidade'), 'Não deve possuir a propriedade "localidade"');
    });

    it('deve adicionar filtro de ativo quando comAtivo é chamado com "true"', () => {
        builder.comAtivo('true');
        const filtros = builder.build();
        assert.strictEqual(filtros.ativo, true, 'O filtro "ativo" deve ser true');
    });

    it('deve adicionar filtro de ativo quando comAtivo é chamado com "false"', () => {
        builder.comAtivo('false');
        const filtros = builder.build();
        assert.strictEqual(filtros.ativo, false, 'O filtro "ativo" deve ser false');
    });

    it('não deve adicionar filtro de ativo quando comAtivo é chamado com um valor inválido', () => {
        builder.comAtivo('invalid');
        const filtros = builder.build();
        assert.ok(!filtros.hasOwnProperty('ativo'), 'Não deve possuir a propriedade "ativo"');
    });
});

===== ./tests/unit/repository/filters/UsuarioFilterBuilder.test.js =====


===== # =====


===== separador =====


===== legível =====


// Se quiser mockar totalmente os Models para evitar abrir conexões Mongoose:
jest.mock('../../../../models/Grupo.js', () => ({}));
jest.mock('../../../../models/Unidade.js', () => ({}));
jest.mock('../../../../models/Usuario.js', () => ({}));
// Caso algum outro model (ex.: Rota.js) seja carregado indiretamente e inicie conexão:
jest.mock('../../../../models/Rota.js', () => ({}));

import mongoose from 'mongoose'; // Importa para que possamos desconectar ao final, se necessário
import UsuarioFilterBuilder from '../../../../repositories/filters/UsuarioFilterBuilder.js';

describe('UsuarioFilterBuilder (Jest)', () => {
    let builder;

    beforeEach(() => {
        builder = new UsuarioFilterBuilder();
    });

    afterEach(() => {
        // Reseta todos os mocks/spies do Jest após cada teste
        jest.clearAllMocks();
    });

    describe('comNome', () => {
        test('deve setar filtro de nome quando comNome é chamado', () => {
            builder.comNome('John');
            const filtros = builder.build();

            expect(filtros).toHaveProperty('nome');
            expect(filtros.nome).toEqual({ $regex: 'John', $options: 'i' });
        });

        test('não deve setar filtro de nome se for vazio ou undefined', () => {
            builder.comNome('');
            builder.comNome(undefined);
            const filtros = builder.build();
            expect(filtros).not.toHaveProperty('nome');
        });
    });

    describe('comEmail', () => {
        test('deve setar filtro de email quando comEmail é chamado', () => {
            builder.comEmail('teste@example.com');
            const filtros = builder.build();

            expect(filtros).toHaveProperty('email');
            expect(filtros.email).toEqual({ $regex: 'teste@example.com', $options: 'i' });
        });

        test('não deve setar filtro de email se for vazio ou undefined', () => {
            builder.comEmail('');
            builder.comEmail(undefined);
            const filtros = builder.build();
            expect(filtros).not.toHaveProperty('email');
        });
    });

    describe('comAtivo', () => {
        test('deve setar ativo como true quando valor é "true"', () => {
            builder.comAtivo('true');
            const filtros = builder.build();
            expect(filtros).toHaveProperty('ativo', true);
        });

        test('deve setar ativo como false quando valor é "false"', () => {
            builder.comAtivo('false');
            const filtros = builder.build();
            expect(filtros).toHaveProperty('ativo', false);
        });

        test('não deve setar ativo quando valor é inválido', () => {
            builder.comAtivo('invalido');
            const filtros = builder.build();
            expect(filtros).not.toHaveProperty('ativo');
        });

        test('não deve setar ativo quando valor é undefined', () => {
            builder.comAtivo(undefined);
            const filtros = builder.build();
            expect(filtros).not.toHaveProperty('ativo');
        });
    });

    describe('comGrupo', () => {
        test('deve setar filtro de grupos com 1 grupo encontrado', async () => {
            // Espionar o método "buscarPorNome" da instância real
            jest
                .spyOn(builder.grupoRepository, 'buscarPorNome')
                .mockResolvedValueOnce({ _id: 'group1' });

            await builder.comGrupo('admin');
            const filtros = builder.build();

            expect(builder.grupoRepository.buscarPorNome).toHaveBeenCalledWith('admin');
            expect(filtros).toHaveProperty('grupos');
            expect(filtros.grupos).toEqual({ $in: ['group1'] });
        });

        test('deve setar filtro de grupos com array quando vários grupos são encontrados', async () => {
            jest
                .spyOn(builder.grupoRepository, 'buscarPorNome')
                .mockResolvedValueOnce([{ _id: 'group1' }, { _id: 'group2' }]);

            await builder.comGrupo('user');
            const filtros = builder.build();

            expect(builder.grupoRepository.buscarPorNome).toHaveBeenCalledWith('user');
            expect(filtros).toHaveProperty('grupos', { $in: ['group1', 'group2'] });
        });

        test('deve setar filtro de grupos vazio quando nenhum grupo for encontrado', async () => {
            jest.spyOn(builder.grupoRepository, 'buscarPorNome').mockResolvedValueOnce(null);

            await builder.comGrupo('desconhecido');
            const filtros = builder.build();

            expect(builder.grupoRepository.buscarPorNome).toHaveBeenCalledWith('desconhecido');
            expect(filtros).toHaveProperty('grupos', { $in: [] });
        });

        test('não deve modificar os filtros se grupo for falsy', async () => {
            // Passando um valor falsy (ex.: null)
            await builder.comGrupo(null);
            const filtros = builder.build();
            expect(filtros).not.toHaveProperty('grupos');
        });
    });

    describe('comUnidade', () => {
        test('deve setar filtro de unidades com 1 unidade encontrada', async () => {
            jest
                .spyOn(builder.unidadeRepository, 'buscarPorNome')
                .mockResolvedValueOnce({ _id: 'unit1' });

            await builder.comUnidade('central');
            const filtros = builder.build();

            expect(builder.unidadeRepository.buscarPorNome).toHaveBeenCalledWith('central');
            expect(filtros).toHaveProperty('unidades', { $in: ['unit1'] });
        });

        test('deve setar filtro de unidades com array quando várias unidades são encontradas', async () => {
            jest
                .spyOn(builder.unidadeRepository, 'buscarPorNome')
                .mockResolvedValueOnce([{ _id: 'unit1' }, { _id: 'unit2' }]);

            await builder.comUnidade('office');
            const filtros = builder.build();

            expect(builder.unidadeRepository.buscarPorNome).toHaveBeenCalledWith('office');
            expect(filtros).toHaveProperty('unidades', { $in: ['unit1', 'unit2'] });
        });

        test('deve setar filtro de unidades vazio quando nenhuma unidade for encontrada', async () => {
            jest.spyOn(builder.unidadeRepository, 'buscarPorNome').mockResolvedValueOnce(null);

            await builder.comUnidade('desconhecida');
            const filtros = builder.build();

            expect(builder.unidadeRepository.buscarPorNome).toHaveBeenCalledWith('desconhecida');
            expect(filtros).toHaveProperty('unidades', { $in: [] });
        });

        test('não deve modificar os filtros se unidade for falsy', async () => {
            await builder.comUnidade('');
            const filtros = builder.build();
            expect(filtros).not.toHaveProperty('unidades');
        });
    });

    describe('escapeRegex', () => {
        test('deve escapar caracteres especiais corretamente', () => {
            const input = 'a+b(c)';
            const escaped = builder.escapeRegex(input);
            expect(escaped).toBe('a\\+b\\(c\\)');
        });

        test('deve retornar string vazia quando passada string vazia', () => {
            const escaped = builder.escapeRegex('');
            expect(escaped).toBe('');
        });
    });

    test('deve permitir encadeamento de filtros', async () => {
        // Espionar os métodos de busca
        jest.spyOn(builder.grupoRepository, 'buscarPorNome').mockResolvedValueOnce({ _id: 'group1' });
        jest.spyOn(builder.unidadeRepository, 'buscarPorNome').mockResolvedValueOnce({ _id: 'unit1' });

        // Métodos síncronos encadeados
        builder.comNome('John')
            .comEmail('john@example.com')
            .comAtivo('true');

        // Aguarde cada método assíncrono separadamente
        await builder.comGrupo('admin');
        await builder.comUnidade('central');

        const filtros = builder.build();

        expect(filtros.nome).toEqual({ $regex: 'John', $options: 'i' });
        expect(filtros.email).toEqual({ $regex: 'john@example.com', $options: 'i' });
        expect(filtros.ativo).toBe(true);
        expect(filtros.grupos).toEqual({ $in: ['group1'] });
        expect(filtros.unidades).toEqual({ $in: ['unit1'] });
    });

    // Após todos os testes, desconectamos o Mongoose para evitar handles abertos
    afterAll(async () => {
        await mongoose.disconnect();
    });
});

===== ./tests/unit/repository/GrupoRepository.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/repository/GrupoRepository.test.js

// 1. Importações Necessárias
import GrupoRepository from '../../../repositories/GrupoRepository.js';
import { CustomError, messages } from '../../../utils/helpers/index.js';
import UsuarioModel from '../../../models/Usuario.js';

// 2. Mock das Dependências
jest.mock('../../../models/Usuario.js', () => ({
    findOne: jest.fn(),
}));

// 3. Definição dos Métodos Mockados para `GrupoModel` e Outros Modelos
const mockFindOne = jest.fn();
const mockFindById = jest.fn();
const mockPaginate = jest.fn();
const mockFindByIdAndUpdate = jest.fn();
const mockFindByIdAndDelete = jest.fn();
const mockFind = jest.fn();

// Mock para `GrupoModel` como uma função construtora
const mockSave = jest.fn();
const mockGrupoModel = jest.fn().mockImplementation(() => ({
    save: mockSave,
}));

// Atribuição dos métodos estáticos ao `mockGrupoModel`
mockGrupoModel.findOne = mockFindOne;
mockGrupoModel.findById = mockFindById;
mockGrupoModel.paginate = mockPaginate;
mockGrupoModel.findByIdAndUpdate = mockFindByIdAndUpdate;
mockGrupoModel.findByIdAndDelete = mockFindByIdAndDelete;

// Mock para `UnidadeModel`
const mockUnidadeModel = {
    // Adicione métodos mockados se necessário
};

// Mock para `RotaModel`
const mockRotaModel = {
    find: mockFind,
};

// 4. Início da Suíte de Testes
describe('GrupoRepository', () => {
    let grupoRepository;
    let mockGrupoFilterBuilder;

    beforeEach(() => {
        // Limpar todas as chamadas e implementações anteriores dos mocks
        jest.clearAllMocks();

        // Inicializar um novo `mockGrupoFilterBuilder` antes de cada teste
        mockGrupoFilterBuilder = {
            comNome: jest.fn().mockReturnThis(),
            comDescricao: jest.fn().mockReturnThis(),
            comAtivo: jest.fn().mockReturnThis(),
            comUnidade: jest.fn().mockReturnThis(),
            build: jest.fn().mockReturnValue({
                nome: { $regex: 'Grupo1', $options: 'i' },
                descricao: { $regex: 'Descricao1', $options: 'i' },
                ativo: true,
                unidades: { $in: ['unidade1'] },
            }),
        };

        // Instanciar o `GrupoRepository` com os modelos e o filter builder mockados
        grupoRepository = new GrupoRepository({
            grupoModel: mockGrupoModel,
            unidadeModel: mockUnidadeModel,
            rotaModel: mockRotaModel,
            usuarioModel: UsuarioModel, // Injeção do `UsuarioModel` mockado
            grupoFilterBuilder: mockGrupoFilterBuilder,
        });
    });

    afterEach(() => {
        jest.restoreAllMocks();
    });

    // 5. Testes para `obterParesRotaDominioUnicos`
    describe('obterParesRotaDominioUnicos', () => {
        it('deve retornar pares únicos de rota e domínio', async () => {
            const permissoes = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
            ];
            const result = await grupoRepository.obterParesRotaDominioUnicos(permissoes);
            expect(result).toEqual([
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
            ]);
        });
    });

    // 6. Testes para `obterPermissoesDuplicadas`
    describe('obterPermissoesDuplicadas', () => {
        it('deve retornar permissões duplicadas', async () => {
            const permissoes = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
            ];
            const combinacoesRecebidas = ['rota1_dominio1', 'rota2_dominio2'];
            const result = grupoRepository.obterPermissoesDuplicadas(permissoes, combinacoesRecebidas);
            expect(result).toEqual([{ rota: 'rota1', dominio: 'dominio1' }]);
        });
    });

    // 7. Testes para `buscarPorNome`
    describe('buscarPorNome', () => {
        it('deve retornar o grupo pelo nome', async () => {
            const nome = 'Grupo1';
            const grupo = { nome: 'Grupo1' };
            mockFindOne.mockResolvedValue(grupo);

            const result = await grupoRepository.buscarPorNome(nome);
            expect(result).toEqual(grupo);
            expect(mockFindOne).toHaveBeenCalledWith({ nome });
        });

        it('deve retornar o grupo pelo nome excluindo um ID específico', async () => {
            const nome = 'Grupo1';
            const idIgnorado = '123';
            const grupo = { nome: 'Grupo1' };
            mockFindOne.mockResolvedValue(grupo);

            const result = await grupoRepository.buscarPorNome(nome, idIgnorado);
            expect(result).toEqual(grupo);
            expect(mockFindOne).toHaveBeenCalledWith({ nome, _id: { $ne: idIgnorado } });
        });

        it('deve retornar null se nenhum grupo for encontrado pelo nome', async () => {
            const nome = 'GrupoInexistente';
            mockFindOne.mockResolvedValue(null);

            const result = await grupoRepository.buscarPorNome(nome);
            expect(result).toBeNull();
            expect(mockFindOne).toHaveBeenCalledWith({ nome });
        });
    });

    // 8. Testes para `buscarPorId`
    describe('buscarPorId', () => {
        it('deve retornar o grupo pelo ID', async () => {
            const id = '123';
            const grupo = { _id: id, nome: 'Grupo1' };
            mockFindById.mockResolvedValue(grupo);

            const result = await grupoRepository.buscarPorId(id);
            expect(result).toEqual(grupo);
            expect(mockFindById).toHaveBeenCalledWith(id);
        });

        it('deve lançar erro se o grupo não for encontrado', async () => {
            const id = '123';
            mockFindById.mockResolvedValue(null);

            await expect(grupoRepository.buscarPorId(id)).rejects.toThrow('Grupo não encontrado(a).');
            await expect(grupoRepository.buscarPorId(id)).rejects.toHaveProperty('statusCode', 404);
            await expect(grupoRepository.buscarPorId(id)).rejects.toHaveProperty('errorType', 'resourceNotFound');
        });
    });

    // 9. Testes para `buscarPorPermissao`
    describe('buscarPorPermissao', () => {
        it('deve retornar rotas por permissões', async () => {
            const permissoes = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
            ];
            const rotas = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
            ];
            mockFind.mockResolvedValue(rotas);

            const result = await grupoRepository.buscarPorPermissao(permissoes);
            expect(result).toEqual(rotas);
            expect(mockFind).toHaveBeenCalledWith({
                $or: [
                    { rota: 'rota1', dominio: 'dominio1' },
                    { rota: 'rota2', dominio: 'dominio2' },
                ],
            });
        });

        it('deve retornar um array vazio se nenhuma rota for encontrada', async () => {
            const permissoes = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
            ];
            const rotas = [];
            mockFind.mockResolvedValue(rotas);

            const result = await grupoRepository.buscarPorPermissao(permissoes);
            expect(result).toEqual([]);
            expect(mockFind).toHaveBeenCalledWith({
                $or: [
                    { rota: 'rota1', dominio: 'dominio1' },
                    { rota: 'rota2', dominio: 'dominio2' },
                ],
            });
        });
    });

    // 10. Testes para `listar`
    describe('listar', () => {
        it('deve listar grupos com filtros', async () => {
            const req = {
                params: {},
                query: {
                    nome: 'Grupo1',
                    descricao: 'Descricao1',
                    ativo: 'true',
                    unidade: 'unidade1',
                    page: 1,
                    limite: 10,
                },
            };
            const grupos = { docs: [{ nome: 'Grupo1' }], totalDocs: 1, limit: 10, page: 1, totalPages: 1 };

            mockPaginate.mockResolvedValue(grupos);

            const result = await grupoRepository.listar(req);
            expect(result).toEqual(grupos);
            expect(mockGrupoFilterBuilder.comNome).toHaveBeenCalledWith('Grupo1');
            expect(mockGrupoFilterBuilder.comDescricao).toHaveBeenCalledWith('Descricao1');
            expect(mockGrupoFilterBuilder.comAtivo).toHaveBeenCalledWith('true');
            expect(mockGrupoFilterBuilder.comUnidade).toHaveBeenCalledWith('unidade1');
            expect(mockGrupoFilterBuilder.build).toHaveBeenCalled();
            expect(mockPaginate).toHaveBeenCalledWith(
                {
                    nome: { $regex: 'Grupo1', $options: 'i' },
                    descricao: { $regex: 'Descricao1', $options: 'i' },
                    ativo: true,
                    unidades: { $in: ['unidade1'] },
                },
                {
                    page: 1,
                    limit: 10,
                    populate: ['permissoes', 'unidades'],
                    sort: { nome: 1 },
                }
            );
        });

        it('deve lançar erro interno se filterBuilder.build não for uma função', async () => {
            const req = {
                params: {},
                query: {
                    nome: 'Grupo1',
                    descricao: 'Descricao1',
                    ativo: 'true',
                    page: 1,
                    limite: 10,
                },
            };

            // Simule que 'build' não é uma função
            mockGrupoFilterBuilder.build = 'not a function';

            await expect(grupoRepository.listar(req)).rejects.toThrow(/Erro interno no servidor/);
            await expect(grupoRepository.listar(req)).rejects.toHaveProperty('statusCode', 500);
            await expect(grupoRepository.listar(req)).rejects.toHaveProperty('errorType', 'internalServerError');
        });

        it('deve lidar com valores de ativo diferentes de "true" e "false"', async () => {
            const req = {
                params: {},
                query: {
                    nome: 'Grupo1',
                    descricao: 'Descricao1',
                    ativo: 'maybe', // Valor inválido para 'ativo'
                    unidade: 'unidade1',
                    page: 1,
                    limite: 10,
                },
            };
            const grupos = { docs: [{ nome: 'Grupo1' }], totalDocs: 1, limit: 10, page: 1, totalPages: 1 };

            // Mock do método 'build' para refletir que 'ativo' não está definido devido ao valor inválido
            mockGrupoFilterBuilder.build.mockReturnValue({
                nome: { $regex: 'Grupo1', $options: 'i' },
                descricao: { $regex: 'Descricao1', $options: 'i' },
                unidades: { $in: ['unidade1'] },
            });

            mockPaginate.mockResolvedValue(grupos);

            const result = await grupoRepository.listar(req);
            expect(result).toEqual(grupos);
            expect(mockGrupoFilterBuilder.comNome).toHaveBeenCalledWith('Grupo1');
            expect(mockGrupoFilterBuilder.comDescricao).toHaveBeenCalledWith('Descricao1');
            expect(mockGrupoFilterBuilder.comAtivo).toHaveBeenCalledWith('maybe');
            expect(mockGrupoFilterBuilder.comUnidade).toHaveBeenCalledWith('unidade1');
            expect(mockGrupoFilterBuilder.build).toHaveBeenCalled();
            expect(mockPaginate).toHaveBeenCalledWith(
                {
                    nome: { $regex: 'Grupo1', $options: 'i' },
                    descricao: { $regex: 'Descricao1', $options: 'i' },
                    unidades: { $in: ['unidade1'] },
                },
                {
                    page: 1,
                    limit: 10,
                    populate: ['permissoes', 'unidades'],
                    sort: { nome: 1 },
                }
            );
        });

        it('deve listar grupos sem unidade', async () => {
            const req = {
                params: {},
                query: {
                    nome: 'Grupo1',
                    descricao: 'Descricao1',
                    ativo: 'true',
                    // unidade não fornecida
                    page: 1,
                    limite: 10,
                },
            };
            const grupos = { docs: [{ nome: 'Grupo1' }], totalDocs: 1, limit: 10, page: 1, totalPages: 1 };

            // Mock do método 'build' para omitir 'unidades'
            mockGrupoFilterBuilder.build.mockReturnValue({
                nome: { $regex: 'Grupo1', $options: 'i' },
                descricao: { $regex: 'Descricao1', $options: 'i' },
                ativo: true,
            });

            mockPaginate.mockResolvedValue(grupos);

            const result = await grupoRepository.listar(req);
            expect(result).toEqual(grupos);
            expect(mockGrupoFilterBuilder.comNome).toHaveBeenCalledWith('Grupo1');
            expect(mockGrupoFilterBuilder.comDescricao).toHaveBeenCalledWith('Descricao1');
            expect(mockGrupoFilterBuilder.comAtivo).toHaveBeenCalledWith('true');
            expect(mockGrupoFilterBuilder.comUnidade).toHaveBeenCalledWith(undefined);
            expect(mockGrupoFilterBuilder.build).toHaveBeenCalled();
            expect(mockPaginate).toHaveBeenCalledWith(
                {
                    nome: { $regex: 'Grupo1', $options: 'i' },
                    descricao: { $regex: 'Descricao1', $options: 'i' },
                    ativo: true,
                },
                {
                    page: 1,
                    limit: 10,
                    populate: ['permissoes', 'unidades'],
                    sort: { nome: 1 },
                }
            );
        });

        it('deve retornar o grupo pelo ID quando o grupo existe', async () => {
            const id = '123';
            const grupo = { _id: id, nome: 'Grupo1', descricao: 'Descrição do Grupo1' };

            // Mock do método `findById` para resolver com o grupo existente
            // Deve retornar um objeto com métodos `populate` encadeados
            mockFindById.mockReturnValue({
                populate: jest.fn().mockReturnValue({
                    populate: jest.fn().mockResolvedValue(grupo),
                }),
            });

            const req = {
                params: { id },
                query: {},
            };

            const result = await grupoRepository.listar(req);
            expect(result).toEqual(grupo);
            expect(mockFindById).toHaveBeenCalledWith(id);
        });

        it('deve lançar erro 404 se o grupo não for encontrado pelo ID', async () => {
            const id = '123';

            // Mock do método `findById` para resolver com null, simulando grupo não encontrado
            mockFindById.mockReturnValue({
                populate: jest.fn().mockReturnValue({
                    populate: jest.fn().mockResolvedValue(null),
                }),
            });

            const req = {
                params: { id },
                query: {},
            };

            await expect(grupoRepository.listar(req)).rejects.toThrow('Grupo não encontrado(a).');
            await expect(grupoRepository.listar(req)).rejects.toHaveProperty('statusCode', 404);
            await expect(grupoRepository.listar(req)).rejects.toHaveProperty('errorType', 'resourceNotFound');
        });

        it('deve lançar erro interno se ocorrer um erro inesperado', async () => {
            const req = {
                params: {},
                query: {
                    nome: 'Grupo1',
                    descricao: 'Descricao1',
                    ativo: 'true',
                    unidade: 'unidade1',
                    page: 1,
                    limite: 10,
                },
            };

            // Simule que 'build' lança um erro inesperado
            mockGrupoFilterBuilder.build.mockImplementation(() => {
                throw new Error('Erro inesperado');
            });

            await expect(grupoRepository.listar(req)).rejects.toThrow(/Erro interno no servidor/);
            await expect(grupoRepository.listar(req)).rejects.toHaveProperty('statusCode', 500);
            await expect(grupoRepository.listar(req)).rejects.toHaveProperty('errorType', 'internalServerError');
        });
    });

    // 11. Testes para `criar`
    describe('criar', () => {
        it('deve criar um novo grupo', async () => {
            const parsedData = { nome: 'Grupo1', descricao: 'Descrição do Grupo1' };
            const grupoSalvo = { _id: '123', ...parsedData };

            // Mock do método `save` para resolver com o grupo salvo
            mockSave.mockResolvedValue(grupoSalvo);

            const result = await grupoRepository.criar(parsedData);
            expect(result).toEqual(grupoSalvo);
            expect(mockSave).toHaveBeenCalled();
            expect(mockGrupoModel).toHaveBeenCalledWith(parsedData);
        });

        it('deve lançar erro se ocorrer um erro ao salvar o grupo', async () => {
            const parsedData = { nome: 'Grupo1', descricao: 'Descrição do Grupo1' };

            // Mock do método `save` para rejeitar com um erro
            mockSave.mockRejectedValue(new Error('Erro ao salvar'));

            await expect(grupoRepository.criar(parsedData)).rejects.toThrow('Erro ao salvar');
            await expect(grupoRepository.criar(parsedData)).rejects.toHaveProperty('message', 'Erro ao salvar');
        });

        it('deve lançar erro de validação se os dados forem inválidos', async () => {
            const parsedData = { /* dados inválidos */ };

            // Mock do método `save` para rejeitar com um erro de validação
            mockSave.mockRejectedValue(new CustomError({
                statusCode: 400,
                errorType: 'validationError',
                field: 'Grupo',
                details: ['Nome é obrigatório'],
                customMessage: 'Nome é obrigatório',
            }));

            await expect(grupoRepository.criar(parsedData)).rejects.toThrow('Nome é obrigatório');
            await expect(grupoRepository.criar(parsedData)).rejects.toHaveProperty('statusCode', 400);
            await expect(grupoRepository.criar(parsedData)).rejects.toHaveProperty('errorType', 'validationError');
        });
    });

    // 12. Testes para `atualizar`
    describe('atualizar', () => {
        it('deve atualizar um grupo', async () => {
            const id = '123';
            const parsedData = { nome: 'Grupo1', descricao: 'Descrição atualizada' };
            const grupoAtualizado = { _id: id, ...parsedData };

            mockFindByIdAndUpdate.mockResolvedValue(grupoAtualizado);

            const result = await grupoRepository.atualizar(id, parsedData);
            expect(result).toEqual(grupoAtualizado);
            expect(mockFindByIdAndUpdate).toHaveBeenCalledWith(id, parsedData, { new: true });
        });

        it('deve lançar erro se o grupo não for encontrado', async () => {
            const id = '123';
            const parsedData = { nome: 'Grupo1', descricao: 'Descrição atualizada' };

            mockFindByIdAndUpdate.mockResolvedValue(null);

            await expect(grupoRepository.atualizar(id, parsedData)).rejects.toThrow('Grupo não encontrado(a).');
            await expect(grupoRepository.atualizar(id, parsedData)).rejects.toHaveProperty('statusCode', 404);
            await expect(grupoRepository.atualizar(id, parsedData)).rejects.toHaveProperty('errorType', 'resourceNotFound');
        });

        it('deve lançar erro interno se ocorrer um erro inesperado durante a atualização', async () => {
            const id = '123';
            const parsedData = { nome: 'Grupo1', descricao: 'Descrição atualizada' };

            mockFindByIdAndUpdate.mockRejectedValue(new Error('Erro inesperado'));

            await expect(grupoRepository.atualizar(id, parsedData)).rejects.toThrow(/Erro interno no servidor/);
            await expect(grupoRepository.atualizar(id, parsedData)).rejects.toHaveProperty('statusCode', 500);
            await expect(grupoRepository.atualizar(id, parsedData)).rejects.toHaveProperty('errorType', 'internalServerError');
        });
    });

    // 13. Testes para `deletar`
    describe('deletar', () => {
        it('deve deletar um grupo', async () => {
            const id = '123';
            const grupoDeletado = { _id: id, nome: 'Grupo1' };

            mockFindByIdAndDelete.mockResolvedValue(grupoDeletado);

            const result = await grupoRepository.deletar(id);
            expect(result).toEqual(grupoDeletado);
            expect(mockFindByIdAndDelete).toHaveBeenCalledWith(id);
        });

        it('deve lançar erro se o grupo não for encontrado', async () => {
            const id = '123';

            mockFindByIdAndDelete.mockResolvedValue(null);

            await expect(grupoRepository.deletar(id)).rejects.toThrow('Grupo não encontrado(a).');
            await expect(grupoRepository.deletar(id)).rejects.toHaveProperty('statusCode', 404);
            await expect(grupoRepository.deletar(id)).rejects.toHaveProperty('errorType', 'resourceNotFound');
        });

        it('deve lançar erro interno se ocorrer um erro inesperado durante a deleção', async () => {
            const id = '123';

            mockFindByIdAndDelete.mockRejectedValue(new Error('Erro inesperado'));

            await expect(grupoRepository.deletar(id)).rejects.toThrow(/Erro interno no servidor/);
            await expect(grupoRepository.deletar(id)).rejects.toHaveProperty('statusCode', 500);
            await expect(grupoRepository.deletar(id)).rejects.toHaveProperty('errorType', 'internalServerError');
        });
    });

    // 14. Testes para `verificarUsuariosAssociados`
    describe('verificarUsuariosAssociados', () => {
        it('deve retornar true se usuários estiverem associados ao grupo', async () => {
            const id = '123';
            const usuario = { grupos: [id] };
            UsuarioModel.findOne.mockResolvedValue(usuario);

            const result = await grupoRepository.verificarUsuariosAssociados(id);
            expect(result).toBe(true);
            expect(UsuarioModel.findOne).toHaveBeenCalledWith({ grupos: id });
        });

        it('deve retornar false se nenhum usuário estiver associado ao grupo', async () => {
            const id = '123';
            UsuarioModel.findOne.mockResolvedValue(null);

            const result = await grupoRepository.verificarUsuariosAssociados(id);
            expect(result).toBe(false);
            expect(UsuarioModel.findOne).toHaveBeenCalledWith({ grupos: id });
        });

        it('deve lançar erro se ocorrer um erro ao verificar usuários associados', async () => {
            const id = '123';

            UsuarioModel.findOne.mockRejectedValue(new Error('Erro no banco de dados'));

            await expect(grupoRepository.verificarUsuariosAssociados(id)).rejects.toThrow(/Erro interno no servidor/);
            await expect(grupoRepository.verificarUsuariosAssociados(id)).rejects.toHaveProperty('statusCode', 500);
            await expect(grupoRepository.verificarUsuariosAssociados(id)).rejects.toHaveProperty('errorType', 'internalServerError');
        });
    });
});

===== ./tests/unit/repository/UnidadeRepository.test.js =====


===== # =====


===== separador =====


===== legível =====

import assert from 'assert';
import sinon from 'sinon';
import UnidadeRepository from '../../../repositories/UnidadeRepository.js';
import UnidadeModel from '../../../models/Unidade.js';
import UnidadeFilterBuilder from '../../../repositories/filters/UnidadeFilterBuilder.js';

describe('UnidadeRepository', () => {
    let unidadeRepository;
    let sandbox;

    beforeEach(() => {
        unidadeRepository = new UnidadeRepository();
        sandbox = sinon.createSandbox();
    });

    afterEach(() => {
        sandbox.restore();
    });

    describe('listar', () => {
        it('deve listar unidades por id', async () => {
            const req = { params: { id: '123' } };
            const mockUnit = { _id: '123', nome: 'Unit 1' };
            sandbox.stub(UnidadeModel, 'findById').resolves(mockUnit);

            const result = await unidadeRepository.listar(req);

            assert.deepStrictEqual(result, mockUnit, 'O resultado deve ser igual ao mockUnit');
            assert.strictEqual(UnidadeModel.findById.calledOnceWith('123'), true, 'findById deve ser chamado uma vez com id "123"');
        });

        it('deve listar unidades com filtros', async () => {
            const req = { query: { nome: 'Unit', localidade: 'Location', ativo: 'true', page: 1, limite: 10 } };
            const mockUnits = [{ _id: '123', nome: 'Unit 1' }];
            const mockPaginate = sandbox.stub(UnidadeModel, 'paginate').resolves(mockUnits);
            const mockFilterBuilder = sandbox.stub(UnidadeFilterBuilder.prototype, 'build').returns({ nome: 'Unit', localidade: 'Location', ativo: 'true' });

            const result = await unidadeRepository.listar(req);

            assert.deepStrictEqual(result, mockUnits, 'O resultado deve ser igual a mockUnits');
            assert.strictEqual(mockPaginate.calledOnce, true, 'paginate deve ser chamado uma vez');
            assert.strictEqual(mockFilterBuilder.calledOnce, true, 'build deve ser chamado uma vez');
        });

        it('deve tratar erros', async () => {
            const req = {};
            sandbox.stub(UnidadeModel, 'paginate').throws(new Error('Error'));

            try {
                await unidadeRepository.listar(req);
                assert.fail('A chamada deveria ter lançado um erro');
            } catch (error) {
                assert.strictEqual(error.message, 'Error', 'A mensagem do erro deve ser "Error"');
            }
        });
    });

    describe('criar', () => {
        it('deve criar uma unidade', async () => {
            const dadosUnidade = { nome: 'Unit 1', localidade: 'Location 1' }; // Adicionado 'localidade'
            const mockUnit = { _id: '123', nome: 'Unit 1', localidade: 'Location 1' };
            sandbox.stub(UnidadeModel.prototype, 'save').resolves(mockUnit); // Stub do método 'save'

            const result = await unidadeRepository.criar(dadosUnidade);

            assert.deepStrictEqual(result, mockUnit, 'O resultado deve ser igual ao mockUnit');
            assert.strictEqual(UnidadeModel.prototype.save.calledOnce, true, 'save deve ser chamado uma vez');
        });

        it('deve tratar erros ao criar uma unidade', async () => {
            const dadosUnidade = { nome: 'Unit 1', localidade: 'Location 1' }; // Adicionado 'localidade'
            sandbox.stub(UnidadeModel.prototype, 'save').throws(new Error('Error')); // Stub para lançar erro

            try {
                await unidadeRepository.criar(dadosUnidade);
                assert.fail('A chamada deveria ter lançado um erro');
            } catch (error) {
                assert.strictEqual(error.message, 'Error', 'A mensagem do erro deve ser "Error"');
            }
        });
    });

    describe('atualizar', () => {
        it('deve atualizar uma unidade', async () => {
            const id = '123';
            const dadosAtualizados = { nome: 'Updated Unit' };
            const mockUnit = { _id: '123', nome: 'Updated Unit' };
            sandbox.stub(UnidadeModel, 'findByIdAndUpdate').resolves(mockUnit);

            const result = await unidadeRepository.atualizar(id, dadosAtualizados);

            assert.deepStrictEqual(result, mockUnit, 'O resultado deve ser igual ao mockUnit');
            assert.strictEqual(
                UnidadeModel.findByIdAndUpdate.calledOnceWith(id, dadosAtualizados, { new: true }),
                true,
                'findByIdAndUpdate deve ser chamado uma vez com os parâmetros corretos'
            );
        });

        it('deve tratar erros ao atualizar uma unidade', async () => {
            const id = '123';
            const dadosAtualizados = { nome: 'Updated Unit' };
            sandbox.stub(UnidadeModel, 'findByIdAndUpdate').throws(new Error('Error'));

            try {
                await unidadeRepository.atualizar(id, dadosAtualizados);
                assert.fail('A chamada deveria ter lançado um erro');
            } catch (error) {
                assert.strictEqual(error.message, 'Error', 'A mensagem do erro deve ser "Error"');
            }
        });
    });

    describe('deletar', () => {
        it('deve deletar uma unidade', async () => {
            const id = '123';
            const mockUnit = { _id: '123', nome: 'Unit 1' };
            sandbox.stub(UnidadeModel, 'findByIdAndDelete').resolves(mockUnit);

            const result = await unidadeRepository.deletar(id);

            assert.deepStrictEqual(result, mockUnit, 'O resultado deve ser igual ao mockUnit');
            assert.strictEqual(UnidadeModel.findByIdAndDelete.calledOnceWith(id), true, 'findByIdAndDelete deve ser chamado uma vez com o id correto');
        });

        it('deve tratar erros ao deletar uma unidade', async () => {
            const id = '123';
            sandbox.stub(UnidadeModel, 'findByIdAndDelete').throws(new Error('Error'));

            try {
                await unidadeRepository.deletar(id);
                assert.fail('A chamada deveria ter lançado um erro');
            } catch (error) {
                assert.strictEqual(error.message, 'Error', 'A mensagem do erro deve ser "Error"');
            }
        });
    });

    describe('buscarUnidade', () => {
        it('deve encontrar uma unidade por nome e localidade', async () => {
            const nome = 'Unit 1';
            const localidade = 'Location 1';
            const mockUnit = { _id: '123', nome: 'Unit 1', localidade: 'Location 1' };
            sandbox.stub(UnidadeModel, 'findOne').resolves(mockUnit);

            const result = await UnidadeRepository.buscarUnidade(nome, localidade);

            assert.deepStrictEqual(result, mockUnit, 'O resultado deve ser igual ao mockUnit');
            assert.strictEqual(
                UnidadeModel.findOne.calledOnceWith({ nome, localidade }),
                true,
                'findOne deve ser chamado uma vez com os parâmetros corretos'
            );
        });




    });
});

===== ./tests/unit/repository/UsuarioRepository.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/repository/UsuarioRepository.test.js

import UsuarioRepository from '../../../../src/repositories/UsuarioRepository.js';
import UsuarioModel from '../../../../src/models/Usuario.js';
import RotaModel from '../../../../src/models/Rota.js';
import { CustomError, messages } from '../../../../src/utils/helpers/index.js';

// Mock dos modelos do Mongoose
jest.mock('../../../../src/models/Usuario.js');
jest.mock('../../../../src/models/Rota.js');

// Mock do UsuarioFilterBuilder
jest.mock('../../../../src/repositories/filters/UsuarioFilterBuilder.js', () => {
    return jest.fn().mockImplementation(() => ({
        comNome: jest.fn().mockReturnThis(),
        comEmail: jest.fn().mockReturnThis(),
        comAtivo: jest.fn().mockReturnThis(),
        comGrupo: jest.fn().mockReturnThis(),
        comUnidade: jest.fn().mockReturnThis(),
        build: jest.fn()
    }));
});

// Mock de messages e CustomError
jest.mock('../../../../src/utils/helpers/index.js', () => ({
    CustomError: class extends Error {
        constructor({ statusCode, errorType, field, details, customMessage }) {
            super(customMessage);
            this.statusCode = statusCode;
            this.errorType = errorType;
            this.field = field;
            this.details = details;
        }
    },
    messages: {
        error: {
            internalServerError: (resource) => `Erro interno no ${resource}`,
            resourceNotFound: (resource) => `${resource} não encontrado`
        }
    }
}));

describe('UsuarioRepository', () => {
    let usuarioRepository;

    beforeEach(() => {
        usuarioRepository = new UsuarioRepository();
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('buscarPorEmail', () => {
        it('deve encontrar um usuário por email', async () => {
            const mockUser = { email: 'test@example.com' };
            UsuarioModel.findOne.mockResolvedValue(mockUser);

            const result = await usuarioRepository.buscarPorEmail('test@example.com');

            expect(result).toEqual(mockUser);
            expect(UsuarioModel.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
        });

        it('deve excluir um ID específico da busca', async () => {
            const mockUser = { email: 'test@example.com' };
            UsuarioModel.findOne.mockResolvedValue(mockUser);

            const result = await usuarioRepository.buscarPorEmail('test@example.com', '123');

            expect(result).toEqual(mockUser);
            expect(UsuarioModel.findOne).toHaveBeenCalledWith({ email: 'test@example.com', _id: { $ne: '123' } });
        });

        it('deve retornar null se nenhum usuário for encontrado', async () => {
            UsuarioModel.findOne.mockResolvedValue(null);

            const result = await usuarioRepository.buscarPorEmail('nonexistent@example.com');

            expect(result).toBeNull();
            expect(UsuarioModel.findOne).toHaveBeenCalledWith({ email: 'nonexistent@example.com' });
        });
    });

    describe('buscarPorId', () => {
        it('deve encontrar um usuário por ID', async () => {
            const mockUser = { _id: '123', nome: 'Test User' };
            UsuarioModel.findById.mockResolvedValue(mockUser);

            const result = await usuarioRepository.buscarPorId('123');

            expect(result).toEqual(mockUser);
            expect(UsuarioModel.findById).toHaveBeenCalledWith('123');
        });

        it('deve lançar um erro se o usuário não for encontrado', async () => {
            UsuarioModel.findById.mockResolvedValue(null);

            await expect(usuarioRepository.buscarPorId('123')).rejects.toThrow(CustomError);
            expect(UsuarioModel.findById).toHaveBeenCalledWith('123');
        });

        it('deve encontrar um usuário por ID com tokens incluídos', async () => {
            const mockUserWithTokens = { 
                _id: '123', 
                nome: 'Test User', 
                refreshtoken: 'refresh123', 
                accesstoken: 'access123' 
            };
            UsuarioModel.findById.mockReturnValue({
                select: jest.fn().mockResolvedValue(mockUserWithTokens)
            });

            const result = await usuarioRepository.buscarPorId('123', true);

            expect(result).toEqual(mockUserWithTokens);
            expect(UsuarioModel.findById).toHaveBeenCalledWith('123');
            expect(UsuarioModel.findById().select).toHaveBeenCalledWith('+refreshtoken +accesstoken');
        });
    });

    describe('buscarPorPermissao', () => {
        it('deve encontrar permissões por rota e domínio', async () => {
            const mockPermissions = [{ rota: 'rota1', dominio: 'dominio1' }];
            RotaModel.find.mockResolvedValue(mockPermissions);

            const result = await usuarioRepository.buscarPorPermissao([{ rota: 'rota1', dominio: 'dominio1' }]);

            expect(result).toEqual(mockPermissions);
            expect(RotaModel.find).toHaveBeenCalledWith({ $or: [{ rota: 'rota1', dominio: 'dominio1' }] });
        });

        it('deve retornar um array vazio se nenhuma rota for encontrada', async () => {
            const mockPermissions = [];
            RotaModel.find.mockResolvedValue(mockPermissions);

            const result = await usuarioRepository.buscarPorPermissao([{ rota: 'rotaInexistente', dominio: 'dominioInexistente' }]);

            expect(result).toEqual([]);
            expect(RotaModel.find).toHaveBeenCalledWith({ $or: [{ rota: 'rotaInexistente', dominio: 'dominioInexistente' }] });
        });

        it('deve lidar com permissões sem domínio', async () => {
            const mockPermissions = [{ rota: 'rota1', dominio: null }];
            RotaModel.find.mockResolvedValue(mockPermissions);

            const result = await usuarioRepository.buscarPorPermissao([{ rota: 'rota1' }]);

            expect(result).toEqual(mockPermissions);
            expect(RotaModel.find).toHaveBeenCalledWith({ $or: [{ rota: 'rota1', dominio: null }] });
        });
    });

    describe('listar', () => {
        it('deve listar usuários com filtros', async () => {
            const mockUsers = [{ nome: 'User1' }];
            const req = {
                query: { nome: 'User1', page: 1, limite: 10 },
                params: {}
            };
            UsuarioModel.paginate.mockResolvedValue(mockUsers);

            // Mockar UsuarioFilterBuilder.build para retornar filtros
            const mockFilters = { nome: { $regex: 'User1', $options: 'i' }, ativo: true };
            const UsuarioFilterBuilder = require('../../../../src/repositories/filters/UsuarioFilterBuilder.js');
            UsuarioFilterBuilder.mockImplementation(() => ({
                comNome: jest.fn().mockReturnThis(),
                comEmail: jest.fn().mockReturnThis(),
                comAtivo: jest.fn().mockReturnThis(),
                comGrupo: jest.fn().mockReturnThis(),
                comUnidade: jest.fn().mockReturnThis(),
                build: jest.fn().mockReturnValue(mockFilters)
            }));

            const result = await usuarioRepository.listar(req);

            expect(result).toEqual(mockUsers);
            // Verifica que paginate foi chamado com os filtros e opções corretas
            expect(UsuarioModel.paginate).toHaveBeenCalledWith(mockFilters, expect.objectContaining({
                page: 1,
                limit: 10,
                populate: expect.any(Array),
                sort: { nome: 1 },
            }));
        });

        it('deve listar um usuário por ID', async () => {
            const mockUser = { _id: '123', grupos: ['grupo1'], unidades: ['unidade1'], permissoes: ['permissao1'] };

            // Configuração do mock para encadear múltiplas chamadas de populate
            const mockPopulate3 = jest.fn().mockResolvedValue(mockUser);
            const mockPopulate2 = jest.fn().mockReturnValue({ populate: mockPopulate3 });
            const mockPopulate1 = jest.fn().mockReturnValue({ populate: mockPopulate2 });
            UsuarioModel.findById.mockReturnValue({ populate: mockPopulate1 });

            const req = { params: { id: '123' } };
            const result = await usuarioRepository.listar(req);

            expect(result).toEqual(mockUser);
            expect(UsuarioModel.findById).toHaveBeenCalledWith('123');
            expect(mockPopulate1).toHaveBeenCalledWith({
                path: 'grupos',
                populate: { path: 'unidades' }
            });
            expect(mockPopulate2).toHaveBeenCalledWith('permissoes');
            expect(mockPopulate3).toHaveBeenCalledWith('unidades');
        });

        it('deve lançar um erro se filterBuilder.build não for uma função', async () => {
            const req = {
                query: { nome: 'User1', page: 1, limite: 10 },
                params: {}
            };
            
            // Mockar o UsuarioFilterBuilder para retornar um objeto inválido
            const UsuarioFilterBuilder = require('../../../../src/repositories/filters/UsuarioFilterBuilder.js');
            UsuarioFilterBuilder.mockImplementation(() => ({
                comNome: jest.fn().mockReturnThis(),
                comEmail: jest.fn().mockReturnThis(),
                comAtivo: jest.fn().mockReturnThis(),
                comGrupo: jest.fn().mockReturnThis(),
                comUnidade: jest.fn().mockReturnThis(),
                // build não é uma função
                build: 'not a function'
            }));

            await expect(usuarioRepository.listar(req)).rejects.toThrow(CustomError);
            expect(UsuarioFilterBuilder).toHaveBeenCalled();
        });

        it('deve listar usuários com vários filtros aplicados', async () => {
            const mockUsers = [{ nome: 'User1' }, { nome: 'User2' }];
            const req = {
                query: { nome: 'User', email: 'user@example.com', ativo: 'true', grupo: 'grupo1', unidade: 'unidade1', page: 2, limite: 20 },
                params: {}
            };
            UsuarioModel.paginate.mockResolvedValue(mockUsers);

            const mockFilter = {
                nome: { $regex: 'User', $options: 'i' },
                email: 'user@example.com',
                ativo: true,
                grupo: 'grupo1',
                unidade: 'unidade1'
            };
            const UsuarioFilterBuilder = require('../../../../src/repositories/filters/UsuarioFilterBuilder.js');

            // Criação de mocks compartilhados para rastrear as chamadas
            const mockComNome = jest.fn().mockReturnThis();
            const mockComEmail = jest.fn().mockReturnThis();
            const mockComAtivo = jest.fn().mockReturnThis();
            const mockComGrupo = jest.fn().mockReturnThis();
            const mockComUnidade = jest.fn().mockReturnThis();

            UsuarioFilterBuilder.mockImplementation(() => ({
                comNome: mockComNome,
                comEmail: mockComEmail,
                comAtivo: mockComAtivo,
                comGrupo: mockComGrupo,
                comUnidade: mockComUnidade,
                build: jest.fn().mockReturnValue(mockFilter)
            }));

            const result = await usuarioRepository.listar(req);

            expect(result).toEqual(mockUsers);
            expect(UsuarioFilterBuilder).toHaveBeenCalled();
            expect(mockComNome).toHaveBeenCalledWith('User');
            expect(mockComEmail).toHaveBeenCalledWith('user@example.com');
            expect(mockComAtivo).toHaveBeenCalledWith('true');
            expect(mockComGrupo).toHaveBeenCalledWith('grupo1');
            expect(mockComUnidade).toHaveBeenCalledWith('unidade1');
            expect(UsuarioModel.paginate).toHaveBeenCalledWith(mockFilter, expect.objectContaining({
                page: 2,
                limit: 20,
                populate: expect.any(Array),
                sort: { nome: 1 },
            }));
        });

        // Teste para limitar 'limite' a 100
        it('deve limitar o valor de limite a 100 se um valor maior for fornecido', async () => {
            const mockUsers = [{ nome: 'User1' }, { nome: 'User2' }];
            const req = {
                query: { nome: 'User', limite: 200 }, // limite maior que 100
                params: {}
            };
            UsuarioModel.paginate.mockResolvedValue(mockUsers);

            // Mockar UsuarioFilterBuilder.build para retornar filtros
            const mockFilters = { nome: { $regex: 'User', $options: 'i' }, ativo: true };
            const UsuarioFilterBuilder = require('../../../../src/repositories/filters/UsuarioFilterBuilder.js');
            UsuarioFilterBuilder.mockImplementation(() => ({
                comNome: jest.fn().mockReturnThis(),
                comEmail: jest.fn().mockReturnThis(),
                comAtivo: jest.fn().mockReturnThis(),
                comGrupo: jest.fn().mockReturnThis(),
                comUnidade: jest.fn().mockReturnThis(),
                build: jest.fn().mockReturnValue(mockFilters)
            }));

            const result = await usuarioRepository.listar(req);

            expect(result).toEqual(mockUsers);
            expect(UsuarioModel.paginate).toHaveBeenCalledWith(mockFilters, expect.objectContaining({
                page: 1,
                limit: 100, // Deve ser limitado a 100
                populate: expect.any(Array),
                sort: { nome: 1 },
            }));
        });

        // Teste para limite inválido (não numérico)
        it('deve usar o limite padrão quando um valor inválido é fornecido', async () => {
            const mockUsers = [{ nome: 'User1' }, { nome: 'User2' }];
            const req = {
                query: { nome: 'User', limite: 'abc' }, // limite inválido
                params: {}
            };
            UsuarioModel.paginate.mockResolvedValue(mockUsers);

            // Mockar UsuarioFilterBuilder.build para retornar filtros
            const mockFilters = { nome: { $regex: 'User', $options: 'i' }, ativo: true };
            const UsuarioFilterBuilder = require('../../../../src/repositories/filters/UsuarioFilterBuilder.js');
            UsuarioFilterBuilder.mockImplementation(() => ({
                comNome: jest.fn().mockReturnThis(),
                comEmail: jest.fn().mockReturnThis(),
                comAtivo: jest.fn().mockReturnThis(),
                comGrupo: jest.fn().mockReturnThis(),
                comUnidade: jest.fn().mockReturnThis(),
                build: jest.fn().mockReturnValue(mockFilters)
            }));

            const result = await usuarioRepository.listar(req);

            expect(result).toEqual(mockUsers);
            expect(UsuarioModel.paginate).toHaveBeenCalledWith(mockFilters, expect.objectContaining({
                page: 1,
                limit: 10, // Deve usar o limite padrão de 10
                populate: expect.any(Array),
                sort: { nome: 1 },
            }));
        });

        // Teste para diferentes números de página
        it('deve paginar corretamente com diferentes números de página', async () => {
            const mockUsers = [{ nome: 'User1' }, { nome: 'User2' }];
            const req = {
                query: { nome: 'User', page: 3, limite: 20 },
                params: {}
            };
            UsuarioModel.paginate.mockResolvedValue(mockUsers);

            // Mockar UsuarioFilterBuilder.build para retornar filtros
            const mockFilters = { nome: { $regex: 'User', $options: 'i' }, ativo: true };
            const UsuarioFilterBuilder = require('../../../../src/repositories/filters/UsuarioFilterBuilder.js');
            UsuarioFilterBuilder.mockImplementation(() => ({
                comNome: jest.fn().mockReturnThis(),
                comEmail: jest.fn().mockReturnThis(),
                comAtivo: jest.fn().mockReturnThis(),
                comGrupo: jest.fn().mockReturnThis(),
                comUnidade: jest.fn().mockReturnThis(),
                build: jest.fn().mockReturnValue(mockFilters)
            }));

            const result = await usuarioRepository.listar(req);

            expect(result).toEqual(mockUsers);
            expect(UsuarioFilterBuilder).toHaveBeenCalled();
            expect(UsuarioModel.paginate).toHaveBeenCalledWith(mockFilters, expect.objectContaining({
                page: 3,
                limit: 20,
                populate: expect.any(Array),
                sort: { nome: 1 },
            }));
        });

        // Teste para listar usuários com parâmetros padrão
        it('deve listar usuários com parâmetros padrão quando nenhum filtro é fornecido', async () => {
            const mockUsers = [{ nome: 'User1' }, { nome: 'User2' }];
            const req = {
                query: {},
                params: {}
            };
            UsuarioModel.paginate.mockResolvedValue(mockUsers);
        
            // Mockar UsuarioFilterBuilder.build para retornar filtros padrão
            const mockFilters = { ativo: true };
            const UsuarioFilterBuilder = require('../../../../src/repositories/filters/UsuarioFilterBuilder.js');
            UsuarioFilterBuilder.mockImplementation(() => ({
                comNome: jest.fn().mockReturnThis(),
                comEmail: jest.fn().mockReturnThis(),
                comAtivo: jest.fn().mockReturnThis(),
                comGrupo: jest.fn().mockReturnThis(),
                comUnidade: jest.fn().mockReturnThis(),
                build: jest.fn().mockReturnValue(mockFilters)
            }));
        
            const result = await usuarioRepository.listar(req);
        
            expect(result).toEqual(mockUsers);
            expect(UsuarioModel.paginate).toHaveBeenCalledWith(mockFilters, expect.objectContaining({
                page: 1,
                limit: 10,
                populate: expect.any(Array),
                sort: { nome: 1 },
            }));
        });

        // **Novo Teste para Cobrir o Caso de Erro Quando Usuário Não é Encontrado**
        it('deve lançar um erro se o usuário não for encontrado ao listar por ID', async () => {
            // Configurar o mock para retornar um objeto com métodos populate encadeáveis que eventualmente resolvem para null
            UsuarioModel.findById.mockReturnValue({
                populate: jest.fn().mockReturnValue({
                    populate: jest.fn().mockReturnValue({
                        populate: jest.fn().mockResolvedValue(null)
                    })
                })
            });

            const req = { params: { id: '123' } };
            await expect(usuarioRepository.listar(req)).rejects.toThrow(CustomError);
            expect(UsuarioModel.findById).toHaveBeenCalledWith('123');
        });

        // **Teste Adicional Opcional: Adicionar Duplicação na Entrada para Cobrir Mais Cenários**
        it('deve retornar permissões duplicadas apenas para rota-domínio existentes (com rota3 duplicada)', async () => {
            const permissoes = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota3', dominio: 'dominio3' },
                { rota: 'rota3', dominio: 'dominio3' } // Duplicado
            ];
            const combinacoesRecebidas = [
                'rota1_dominio1',
                'rota2_dominio2',
                'rota1_dominio1',
                'rota3_dominio3',
                'rota3_dominio3' // Duplicado
            ];

            const result = await usuarioRepository.obterPermissoesDuplicadas(permissoes, combinacoesRecebidas);

            expect(result).toEqual([
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota3', dominio: 'dominio3' }
            ]);
        });
    });

    describe('criar', () => {
        it('deve criar um novo usuário', async () => {
            const mockUser = { nome: 'User1' };
            UsuarioModel.prototype.save.mockResolvedValue(mockUser);

            const result = await usuarioRepository.criar(mockUser);

            expect(result).toEqual(mockUser);
            expect(UsuarioModel.prototype.save).toHaveBeenCalled();
        });

        it('deve lançar um erro se salvar o usuário falhar', async () => {
            const mockUser = { nome: 'User1' };
            UsuarioModel.prototype.save.mockRejectedValue(new Error('Erro ao salvar'));

            await expect(usuarioRepository.criar(mockUser)).rejects.toThrow('Erro ao salvar');
            expect(UsuarioModel.prototype.save).toHaveBeenCalled();
        });

        it('deve lançar um erro se os dados do usuário estiverem incompletos', async () => {
            const mockUser = { /* dados incompletos */ };
            UsuarioModel.prototype.save.mockRejectedValue(new Error('Dados incompletos'));

            await expect(usuarioRepository.criar(mockUser)).rejects.toThrow('Dados incompletos');
            expect(UsuarioModel.prototype.save).toHaveBeenCalled();
        });
    });

    describe('atualizar', () => {
        it('deve atualizar um usuário', async () => {
            const mockUpdatedUser = { _id: '123', nome: 'Updated User' };
            const updateData = { nome: 'Updated User' };

            UsuarioModel.findByIdAndUpdate.mockReturnValue({
                exec: jest.fn().mockResolvedValue(mockUpdatedUser)
            });

            const result = await usuarioRepository.atualizar('123', updateData);

            expect(result).toEqual(mockUpdatedUser);
            expect(UsuarioModel.findByIdAndUpdate).toHaveBeenCalledWith('123', updateData, { new: true });
            expect(UsuarioModel.findByIdAndUpdate().exec).toHaveBeenCalled();
        });

        it('deve lançar um erro se o usuário não for encontrado', async () => {
            const updateData = { nome: 'Updated User' };

            UsuarioModel.findByIdAndUpdate.mockReturnValue({
                exec: jest.fn().mockResolvedValue(null)
            });

            await expect(usuarioRepository.atualizar('123', updateData)).rejects.toThrow(CustomError);
            expect(UsuarioModel.findByIdAndUpdate).toHaveBeenCalledWith('123', updateData, { new: true });
            expect(UsuarioModel.findByIdAndUpdate().exec).toHaveBeenCalled();
        });

        it('deve lançar um erro se os dados de atualização forem inválidos', async () => {
            const updateData = { /* dados inválidos */ };

            UsuarioModel.findByIdAndUpdate.mockReturnValue({
                exec: jest.fn().mockRejectedValue(new Error('Dados inválidos'))
            });

            await expect(usuarioRepository.atualizar('123', updateData)).rejects.toThrow('Dados inválidos');
            expect(UsuarioModel.findByIdAndUpdate).toHaveBeenCalledWith('123', updateData, { new: true });
            expect(UsuarioModel.findByIdAndUpdate().exec).toHaveBeenCalled();
        });
    });

    describe('deletar', () => {
        it('deve deletar um usuário', async () => {
            const mockUser = { _id: '123' };
            UsuarioModel.findByIdAndDelete.mockResolvedValue(mockUser);

            const result = await usuarioRepository.deletar('123');

            expect(result).toEqual(mockUser);
            expect(UsuarioModel.findByIdAndDelete).toHaveBeenCalledWith('123');
        });

        it('deve retornar null se o usuário não for encontrado para deletar', async () => {
            UsuarioModel.findByIdAndDelete.mockResolvedValue(null);

            const result = await usuarioRepository.deletar('123');

            expect(result).toBeNull();
            expect(UsuarioModel.findByIdAndDelete).toHaveBeenCalledWith('123');
        });

        it('deve lançar um erro se a deleção falhar', async () => {
            UsuarioModel.findByIdAndDelete.mockRejectedValue(new Error('Erro ao deletar'));

            await expect(usuarioRepository.deletar('123')).rejects.toThrow('Erro ao deletar');
            expect(UsuarioModel.findByIdAndDelete).toHaveBeenCalledWith('123');
        });
    });

    describe('obterParesRotaDominioUnicos', () => {
        it('deve retornar pares rota-domínio únicos', async () => {
            const permissoes = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
                { rota: 'rota3' } // domínio undefined
            ];

            const result = await usuarioRepository.obterParesRotaDominioUnicos(permissoes);

            expect(result).toEqual([
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
                { rota: 'rota3', dominio: null }
            ]);
        });

        it('deve retornar um array vazio quando permissoes está vazio', async () => {
            const permissoes = [];
            const result = await usuarioRepository.obterParesRotaDominioUnicos(permissoes);
            expect(result).toEqual([]);
        });

        it('deve lidar com permissões sem domínio', async () => {
            const permissoes = [
                { rota: 'rota1' },
                { rota: 'rota2', dominio: 'dominio2' }
            ];

            const result = await usuarioRepository.obterParesRotaDominioUnicos(permissoes);

            expect(result).toEqual([
                { rota: 'rota1', dominio: null },
                { rota: 'rota2', dominio: 'dominio2' }
            ]);
        });
    });

    describe('obterPermissoesDuplicadas', () => {
        it('deve retornar permissões duplicadas', async () => {
            const permissoes = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' }
            ];
            const combinacoesRecebidas = ['rota1_dominio1', 'rota1_dominio1', 'rota2_dominio2'];

            const result = await usuarioRepository.obterPermissoesDuplicadas(permissoes, combinacoesRecebidas);

            expect(result).toEqual([{ rota: 'rota1', dominio: 'dominio1' }]);
        });

        it('deve retornar um array vazio quando permissoes e combinacoesRecebidas estão vazias', async () => {
            const permissoes = [];
            const combinacoesRecebidas = [];
            const result = await usuarioRepository.obterPermissoesDuplicadas(permissoes, combinacoesRecebidas);
            expect(result).toEqual([]);
        });

        // **Teste Adicional para Cobrir Múltiplas Duplicações**
        it('deve retornar permissões duplicadas apenas para rota-domínio existentes (com rota3 duplicada)', async () => {
            const permissoes = [
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota2', dominio: 'dominio2' },
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota3', dominio: 'dominio3' },
                { rota: 'rota3', dominio: 'dominio3' } // Duplicado
            ];
            const combinacoesRecebidas = [
                'rota1_dominio1',
                'rota2_dominio2',
                'rota1_dominio1',
                'rota3_dominio3',
                'rota3_dominio3' // Duplicado
            ];

            const result = await usuarioRepository.obterPermissoesDuplicadas(permissoes, combinacoesRecebidas);

            expect(result).toEqual([
                { rota: 'rota1', dominio: 'dominio1' },
                { rota: 'rota3', dominio: 'dominio3' }
            ]);
        });
    });
});

===== ./tests/unit/services/AuthService.test.js =====


===== # =====


===== separador =====


===== legível =====

// AuthService.test.js

jest.mock('bcrypt');
jest.mock('jsonwebtoken');

jest.mock('../../../repositories/UsuarioRepository.js', () => {
    return jest.fn().mockImplementation(() => {
        return {
            buscarPorEmail: jest.fn(),
            buscarPorId: jest.fn(),
        };
    });
});

jest.mock('../../../repositories/AuthRepository.js', () => {
    return jest.fn().mockImplementation(() => {
        return {
            armazenarTokens: jest.fn(),
            removeToken: jest.fn(),
        };
    });
});

import AuthService from '../../../services/AuthService.js';
import UsuarioRepository from '../../../repositories/UsuarioRepository.js';
import AuthRepository from '../../../repositories/AuthRepository.js';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { CustomError, messages } from '../../../utils/helpers/index.js';

describe('AuthService', () => {
    let authService;
    let usuarioRepository;
    let authRepository;
    const validId = '507f1f77bcf86cd799439011'; // ObjectId válido

    beforeEach(() => {
        usuarioRepository = new UsuarioRepository();
        authRepository = new AuthRepository();
        authService = new AuthService();

        authService.usuarioRepository = usuarioRepository;
        authService.repository = authRepository; // Garantindo que logout use o mock
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('login', () => {
        it('deve lançar um erro se o usuário não for encontrado', async () => {
            usuarioRepository.buscarPorEmail.mockResolvedValue(null);

            await expect(authService.login({ email: 'test@example.com', senha: 'password' }))
                .rejects
                .toMatchObject({
                    statusCode: 404,
                    customMessage: messages.error.resourceNotFound('Email'),
                });
        });

        it('deve lançar um erro se a senha for inválida', async () => {
            const user = { _id: validId, email: 'test@example.com', senha: 'hashedpassword' };
            usuarioRepository.buscarPorEmail.mockResolvedValue(user);
            bcrypt.compare.mockResolvedValue(false);

            await expect(authService.login({ email: 'test@example.com', senha: 'password' }))
                .rejects
                .toMatchObject({
                    statusCode: 401,
                    customMessage: messages.error.unauthorized('Senha'),
                });
        });

        it('deve retornar accesstoken, refreshtoken e usuário se o login for bem-sucedido', async () => {
            const user = { _id: validId, email: 'test@example.com', senha: 'hashedpassword' };
            usuarioRepository.buscarPorEmail.mockResolvedValue(user);
            bcrypt.compare.mockResolvedValue(true);
            jwt.sign.mockReturnValue('token');
            authRepository.armazenarTokens.mockResolvedValue();

            const result = await authService.login({ email: 'test@example.com', senha: 'password' });

            expect(result).toHaveProperty('accesstoken', 'token');
            expect(result).toHaveProperty('refreshtoken', 'token');
            expect(result.user).toMatchObject({
                _id: validId,
                email: 'test@example.com',
            });
            // Agora deve passar, pois removemos completamente a chave 'senha'
            expect(result.user).not.toHaveProperty('senha');
        });
    });

    describe('logout', () => {
        it('deve remover o token e retornar dados', async () => {
            authRepository.removeToken.mockResolvedValue({ success: true });

            const result = await authService.logout(validId, 'token');

            expect(result).toHaveProperty('data');
            expect(result.data).toHaveProperty('success', true);
        });
    });

    describe('refresh', () => {
        it('deve lançar um erro se o usuário não for encontrado', async () => {
            usuarioRepository.buscarPorId.mockResolvedValue(null);

            await expect(authService.refresh(validId, 'token'))
                .rejects
                .toMatchObject({
                    statusCode: 404,
                    field: 'Token',
                });
        });

        it('deve lançar um erro se o token for inválido', async () => {
            const user = { _id: validId, refreshtoken: 'differenttoken' };
            usuarioRepository.buscarPorId.mockResolvedValue(user);

            await expect(authService.refresh(validId, 'token'))
                .rejects
                .toMatchObject({
                    statusCode: 401,
                    customMessage: messages.error.unauthorized('Token'),
                });
        });

        it('deve retornar um novo accesstoken e refreshtoken se a atualização for bem-sucedida', async () => {
            const user = { _id: validId, refreshtoken: 'token' };
            usuarioRepository.buscarPorId.mockResolvedValue(user);
            jwt.sign.mockReturnValue('newtoken');
            authRepository.armazenarTokens.mockResolvedValue();

            const result = await authService.refresh(validId, 'token');

            expect(result).toHaveProperty('accesstoken', 'newtoken');
            expect(result).toHaveProperty('refreshtoken', 'newtoken');
        });
    });

    describe('recuperaSenha', () => {
        it('deve retornar uma mensagem se o email for encontrado', async () => {
            const user = { _id: validId, email: 'test@example.com' };
            usuarioRepository.buscarPorEmail.mockResolvedValue(user);

            const result = await authService.recuperaSenha({ email: 'test@example.com' });

            expect(result).toHaveProperty(
                'message',
                'Solicição de recuperação de senha recebida, um email será enviado com as instruções para recuperação de senha'
            );
        });
    });
});

===== ./tests/unit/services/PermissionService.test.js =====


===== # =====


===== separador =====


===== legível =====

// PermissionService.test.js

// 1. Mock do módulo UsuarioRepository antes de qualquer importação
jest.mock('../../../repositories/UsuarioRepository.js');

// 2. Agora, importe os módulos após definir o mock
import PermissionService from '../../../services/PermissionService.js';
import UsuarioRepository from '../../../repositories/UsuarioRepository.js';

describe('PermissionService', () => {
    let buscarPorIdMock;
    let permissionService;

    beforeEach(() => {
        jest.resetAllMocks();
        buscarPorIdMock = jest.fn();
        UsuarioRepository.mockImplementation(() => ({
            buscarPorId: buscarPorIdMock
        }));

        // Agora podemos instanciar a classe normalmente
        permissionService = new PermissionService();
    });

    it('deve retornar true se o usuário tiver permissão', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [{ rota, dominio, ativo: true, [metodo]: true }],
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(true);
        expect(buscarPorIdMock).toHaveBeenCalledWith(userId, { grupos: true });
    });

    it('deve retornar false se o usuário não tiver permissão (método false)', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [{ rota, dominio, ativo: true, [metodo]: false }],
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
        expect(buscarPorIdMock).toHaveBeenCalledWith(userId, { grupos: true });
    });

    it('deve retornar false se o usuário não for encontrado', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        buscarPorIdMock.mockResolvedValue(null);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
        expect(buscarPorIdMock).toHaveBeenCalledWith(userId, { grupos: true });
    });

    it('deve retornar true se o usuário tiver permissão através de um grupo', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [],
            grupos: [{ permissoes: [{ rota, dominio, ativo: true, [metodo]: true }] }]
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(true);
        expect(buscarPorIdMock).toHaveBeenCalledWith(userId, { grupos: true });
    });

    it('deve retornar false se ocorrer um erro (ex: erro no banco)', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        buscarPorIdMock.mockRejectedValue(new Error('Database error'));

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
        expect(buscarPorIdMock).toHaveBeenCalledWith(userId, { grupos: true });
    });

    it('deve retornar false se a permissão existir, mas não estiver ativa, mesmo que o método seja true', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [{ rota, dominio, ativo: false, [metodo]: true }],
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
        expect(buscarPorIdMock).toHaveBeenCalledWith(userId, { grupos: true });
    });

    it('deve retornar false se a rota não corresponder', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [{ rota: 'outraRota', dominio, ativo: true, [metodo]: true }],
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
    });

    it('deve retornar false se o dominio não corresponder', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [{ rota, dominio: 'http://outrodominio.com', ativo: true, [metodo]: true }],
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
    });

    it('deve retornar false se o método não corresponder', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [{ rota, dominio, ativo: true, enviar: true }],
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
    });

    // Caso adicional: permissão existe, porém o campo do método não está definido.
    it('deve retornar false se a chave do método não estiver definida na permissão', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [{ rota, dominio, ativo: true }], // não existe [metodo]
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
    });

    // Novo teste: nenhuma permissão
    it('deve retornar false se o usuário não tiver nenhuma permissão e nenhum grupo', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [],
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
    });

    // Novo teste: permissões duplicadas (para cobrir o ramo em que combinacoes.has(chave) é true)
    it('deve ignorar permissões duplicadas', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';

        const usuario = {
            permissoes: [
                { rota, dominio, ativo: true, [metodo]: true },
                { rota, dominio, ativo: true, [metodo]: true } // permissão duplicada
            ],
            grupos: []
        };

        buscarPorIdMock.mockResolvedValue(usuario);

        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(true);
    });

    it('deve retornar false se o usuário não tiver permissoes definidas e o grupo também não tiver permissoes definidas', async () => {
        const userId = 'user1';
        const rota = 'usuarios';
        const dominio = 'http://localhost:3000';
        const metodo = 'buscar';
    
        // Usuário sem a propriedade permissoes
        // Grupo definido, mas sem a propriedade permissoes
        const usuario = {
            grupos: [{}]
        };
    
        buscarPorIdMock.mockResolvedValue(usuario);
    
        const result = await permissionService.hasPermission(userId, rota, dominio, metodo);
        expect(result).toBe(false);
        // Esse teste garante que caímos no ramo "|| []" tanto para usuario.permissoes
        // quanto para grupo.permissoes
    });
    
});

===== ./tests/unit/services/UnidadeService.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/services/UnidadeService.test.js

// ★ IMPORTANTÍSSIMO: Mock do método mongoose.model antes de qualquer importação
jest.mock('mongoose', () => {
    const actualMongoose = jest.requireActual('mongoose');
    return {
      ...actualMongoose,
      model: jest.fn(), // Evita a criação do modelo e plugins associados
    };
  });
  
  import mongoose from 'mongoose';
  import UnidadeService from '../../../services/UnidadeService.js';
  import UnidadeRepository from '../../../repositories/UnidadeRepository.js';
  import CustomError from '../../../utils/helpers/CustomError.js';
  import messages from '../../../utils/helpers/messages.js';
  import { UnidadeSchema, UnidadeUpdateSchema } from '../../../utils/validators/schemas/zod/UnidadeSchema.js';
  
  // Mock da UnidadeRepository usando Jest
  jest.mock('../../../repositories/UnidadeRepository.js');
  
  describe('UnidadeService', () => {
    let unidadeService;
    let unidadeRepositoryMock;
  
    beforeEach(() => {
      // Instancia a UnidadeRepository mockada e injeta no serviço
      unidadeRepositoryMock = new UnidadeRepository();
      unidadeService = new UnidadeService();
      unidadeService.repository = unidadeRepositoryMock;
    });
  
    afterEach(() => {
      jest.resetAllMocks();
    });
  
    // Opcional: se por acaso alguma conexão for aberta, desconectamos o mongoose
    afterAll(async () => {
      await mongoose.disconnect();
    });
  
    describe('listar', () => {
      test('deve listar unidades', async () => {
        const req = { query: {} };
        const expectedData = [{ id: 1, nome: 'Unidade 1' }];
  
        // Configura o mock para retornar os dados esperados
        unidadeRepositoryMock.listar.mockResolvedValue(expectedData);
  
        const data = await unidadeService.listar(req);
  
        expect(data).toEqual(expectedData);
        expect(unidadeRepositoryMock.listar).toHaveBeenCalledTimes(1);
        expect(unidadeRepositoryMock.listar).toHaveBeenCalledWith(req);
      });
    });
  
    describe('criar', () => {
      test('deve criar uma unidade', async () => {
        const req = { body: { nome: 'Unidade 1', localidade: 'Local 1' } };
        const validatedData = { nome: 'Unidade 1', localidade: 'Local 1' };
        const expectedData = { id: 1, nome: 'Unidade 1', localidade: 'Local 1' };
  
        // Para o sucesso, retorna null (ou falsy) para buscarPorNome
        unidadeRepositoryMock.buscarPorNome = jest.fn().mockResolvedValue(null);
        // Mock do parseAsync do schema
        UnidadeSchema.parseAsync = jest.fn().mockResolvedValue(validatedData);
        // Mock do método criar do repositório
        unidadeRepositoryMock.criar = jest.fn().mockResolvedValue(expectedData);
  
        const data = await unidadeService.criar(req);
  
        expect(data).toEqual(expectedData);
        expect(unidadeRepositoryMock.buscarPorNome).toHaveBeenCalledWith(req.body.nome, req.body.localidade);
        expect(UnidadeSchema.parseAsync).toHaveBeenCalledWith(req.body);
        expect(unidadeRepositoryMock.criar).toHaveBeenCalledWith(validatedData);
      });
  
      test('deve lançar erro se unidade já existir', async () => {
        const req = { body: { nome: 'Unidade 1', localidade: 'Local 1' } };
        const existingUnit = { id: 2, nome: 'Unidade 1', localidade: 'Local 1' };
  
        // Mock para indicar que a unidade já existe
        unidadeRepositoryMock.buscarPorNome = jest.fn().mockResolvedValue(existingUnit);
  
        await expect(unidadeService.criar(req)).rejects.toThrow(CustomError);
  
        try {
          await unidadeService.criar(req);
        } catch (error) {
          expect(error.statusCode).toBe(400);
          expect(error.errorType).toBe('validationError');
          expect(error.field).toBe('nome');
          expect(error.customMessage).toBe(messages.validation.generic.resourceAlreadyExists('Nome'));
        }
      });
    });
  
    describe('atualizar', () => {
      test('deve atualizar uma unidade', async () => {
        const req = { params: { id: 1 }, body: { nome: 'Unidade Atualizada' } };
        const validatedData = { id: 1, nome: 'Unidade Atualizada' };
        const expectedData = { id: 1, nome: 'Unidade Atualizada' };
  
        // Mock do parseAsync do schema de atualização
        UnidadeUpdateSchema.parseAsync = jest.fn().mockResolvedValue(validatedData);
        // Mock do método atualizar do repositório
        unidadeRepositoryMock.atualizar = jest.fn().mockResolvedValue(expectedData);
  
        const data = await unidadeService.atualizar(req);
  
        expect(data).toEqual(expectedData);
        expect(UnidadeUpdateSchema.parseAsync).toHaveBeenCalledWith({ ...req.body, id: req.params.id });
        expect(unidadeRepositoryMock.atualizar).toHaveBeenCalledWith(req.params.id, validatedData);
      });
  
      test('deve lançar erro se o id não for fornecido', async () => {
        const req = { params: {}, body: { nome: 'Unidade Atualizada' } };
  
        await expect(unidadeService.atualizar(req)).rejects.toThrow(CustomError);
  
        try {
          await unidadeService.atualizar(req);
        } catch (error) {
          expect(error.statusCode).toBe(400);
          expect(error.errorType).toBe('validationError');
          expect(error.field).toBe('id');
          expect(error.customMessage).toBe(messages.validation.generic.fieldIsRequired('ID'));
        }
      });
    });
  
    describe('deletar', () => {
      test('deve deletar uma unidade', async () => {
        const id = 1;
        const expectedData = { id: 1 };
  
        // Garante que a unidade existe
        unidadeRepositoryMock.buscarPorId = jest.fn().mockResolvedValue(expectedData);
        // Configura o mock para verificar que não há usuários associados
        unidadeRepositoryMock.verificarUsuariosAssociados = jest.fn().mockResolvedValue(false);
        // Mock para a deleção propriamente dita
        unidadeRepositoryMock.deletar = jest.fn().mockResolvedValue(expectedData);
  
        const data = await unidadeService.deletar(id);
  
        expect(data).toEqual(expectedData);
        expect(unidadeRepositoryMock.deletar).toHaveBeenCalledWith(id);
      });
  
      test('deve lançar erro se houver usuários associados', async () => {
        const id = 1;
        const existingUnit = { id: 1, nome: 'Unidade 1' };
  
        // Garante que a unidade existe
        unidadeRepositoryMock.buscarPorId = jest.fn().mockResolvedValue(existingUnit);
        // Configura o mock para indicar que há usuários associados
        unidadeRepositoryMock.verificarUsuariosAssociados = jest.fn().mockResolvedValue(true);
  
        await expect(unidadeService.deletar(id)).rejects.toThrow(CustomError);
  
        try {
          await unidadeService.deletar(id);
        } catch (error) {
          expect(error.statusCode).toBe(400);
          expect(error.errorType).toBe('resourceConflict');
          expect(error.field).toBe('Grupo');
          expect(error.customMessage).toBe(messages.error.resourceConflict('Grupo', 'Usuários associados'));
        }
      });
    });
  
    describe('ensureUnitExists', () => {
      test('deve lançar erro se a unidade não existir', async () => {
        const id = 1;
        // Mock para indicar que não há unidade com o ID
        unidadeRepositoryMock.buscarPorId = jest.fn().mockResolvedValue(null);
  
        await expect(unidadeService.ensureUnitExists(id)).rejects.toThrow(CustomError);
  
        try {
          await unidadeService.ensureUnitExists(id);
        } catch (error) {
          expect(error.statusCode).toBe(404);
          expect(error.errorType).toBe('resourceNotFound');
          expect(error.field).toBe('Unidade');
          expect(error.customMessage).toBe(messages.error.resourceNotFound('Unidade'));
        }
      });
  
      test('deve passar se a unidade existir', async () => {
        const id = 1;
        const existingUnit = { id: 1, nome: 'Unidade 1' };
        unidadeRepositoryMock.buscarPorId = jest.fn().mockResolvedValue(existingUnit);
  
        await expect(unidadeService.ensureUnitExists(id)).resolves.toBeUndefined();
      });
    });
  });
  
===== ./tests/unit/services/UsuarioService.test.js =====


===== # =====


===== separador =====


===== legível =====

// UsuarioService.test.js
import { jest } from '@jest/globals';
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
import UsuarioService from '../../../../src/services/UsuarioService.js';
import UsuarioRepository from '../../../../src/repositories/UsuarioRepository.js';
import CustomError from '../../../../src/utils/helpers/CustomError.js';
import { PermissoesArraySchema } from '../../../../src/utils/validators/schemas/zod/PermissaoValidation.js';

// Mock do Mongoose
jest.mock('mongoose', () => {
    const actualMongoose = jest.requireActual('mongoose');
    return {
        ...actualMongoose,
        model: jest.fn(),
    };
});

// Mock do UsuarioRepository
jest.mock('../../../../src/repositories/UsuarioRepository.js', () => {
    return jest.fn().mockImplementation(() => ({
        listar: jest.fn(),
        criar: jest.fn(),
        atualizar: jest.fn(),
        deletar: jest.fn(),
        buscarPorEmail: jest.fn(),
        buscarPorPermissao: jest.fn(),
        buscarPorId: jest.fn(),
        adicionarPermissoes: jest.fn(),
        removerPermissao: jest.fn(),
        atualizarPermissoes: jest.fn(),
    }));
});

describe('UsuarioService', () => {
    let usuarioService;
    let mockRepository;

    beforeEach(() => {
        mockRepository = new UsuarioRepository();
        usuarioService = new UsuarioService();
        usuarioService.repository = mockRepository;
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    afterAll(async () => {
        await mongoose.disconnect();
    });

    // ---------------------------------
    // listar
    // ---------------------------------
    describe('listar', () => {
        it('should list all users', async () => {
            const req = { query: {} };
            const expectedData = [{ id: 1, name: 'User1' }, { id: 2, name: 'User2' }];
            mockRepository.listar.mockResolvedValue(expectedData);

            const result = await usuarioService.listar(req);

            expect(result).toEqual(expectedData);
            expect(mockRepository.listar).toHaveBeenCalledWith(req);
        });
    });

    // ---------------------------------
    // criar
    // ---------------------------------
    describe('criar', () => {
        it('should create a new user', async () => {
            const inputData = {
                email: 'test@example.com',
                senha: 'password123',
                permissoes: [
                    { id: 'perm1', rota: '/rota1' },
                    { id: 'perm2', rota: '/rota2' },
                ],
                name: 'New User',
            };
            const hashedPassword = 'hashedPassword';

            mockRepository.buscarPorEmail.mockResolvedValue(null);
            mockRepository.buscarPorPermissao.mockResolvedValue(inputData.permissoes);
            jest.spyOn(bcrypt, 'hash').mockResolvedValue(hashedPassword);

            const expectedData = { id: 1, ...inputData, senha: hashedPassword };
            mockRepository.criar.mockResolvedValue(expectedData);

            const result = await usuarioService.criar(inputData);

            expect(mockRepository.buscarPorEmail).toHaveBeenCalledWith(inputData.email, null);
            expect(mockRepository.buscarPorPermissao).toHaveBeenCalledWith(inputData.permissoes);
            expect(result).toEqual(expectedData);
            expect(mockRepository.criar).toHaveBeenCalledWith({
                ...inputData,
                senha: hashedPassword,
                permissoes: inputData.permissoes,
            });
        });

        it('should throw error if repository returns fewer permissions than requested', async () => {
            const inputData = {
                email: 'mismatch@example.com',
                senha: 'password123',
                permissoes: [
                    { id: 'perm1', rota: '/rota1' },
                    { id: 'perm2', rota: '/rota2' },
                ],
                name: 'Mismatch User',
            };

            mockRepository.buscarPorEmail.mockResolvedValue(null);
            // Retorna somente um item, causando mismatch
            mockRepository.buscarPorPermissao.mockResolvedValue([inputData.permissoes[0]]);

            await expect(usuarioService.criar(inputData)).rejects.toThrow('Permissões inválidas.');
        });

        it('should create a new user with empty permissions array', async () => {
            const inputData = {
                email: 'empty@example.com',
                senha: 'noperms123',
                permissoes: [],
                name: 'No Perms User',
            };
            const hashedPassword = 'hashedEmpty';

            mockRepository.buscarPorEmail.mockResolvedValue(null);
            mockRepository.buscarPorPermissao.mockResolvedValue([]);
            jest.spyOn(bcrypt, 'hash').mockResolvedValue(hashedPassword);

            const expectedData = {
                id: 2,
                ...inputData,
                senha: hashedPassword,
                permissoes: [],
            };
            mockRepository.criar.mockResolvedValue(expectedData);

            const result = await usuarioService.criar(inputData);

            expect(mockRepository.buscarPorEmail).toHaveBeenCalledWith(inputData.email, null);
            expect(mockRepository.buscarPorPermissao).toHaveBeenCalledWith([]);
            expect(result).toEqual(expectedData);
            expect(mockRepository.criar).toHaveBeenCalledWith({
                ...inputData,
                senha: hashedPassword,
                permissoes: [],
            });
        });
    });

    // ---------------------------------
    // atualizar
    // ---------------------------------
    describe('atualizar', () => {
        it('should update an existing user', async () => {
            const userId = 1;
            const updateData = {
                email: 'updated@example.com',
                senha: 'newpassword',
                permissoes: [{ id: 'perm1', rota: '/rota1' }],
                name: 'Updated User',
            };

            mockRepository.buscarPorId.mockResolvedValue({ id: userId });
            mockRepository.buscarPorEmail.mockResolvedValue(null);
            mockRepository.buscarPorPermissao.mockResolvedValue(updateData.permissoes);

            const expectedData = { id: userId, ...updateData };
            mockRepository.atualizar.mockResolvedValue(expectedData);

            const result = await usuarioService.atualizar(userId, updateData);

            expect(mockRepository.buscarPorId).toHaveBeenCalledWith(userId);
            expect(mockRepository.buscarPorEmail).toHaveBeenCalledWith(updateData.email, userId);
            expect(mockRepository.buscarPorPermissao).toHaveBeenCalledWith(updateData.permissoes);
            expect(result).toEqual(expectedData);
            expect(mockRepository.atualizar).toHaveBeenCalledWith(userId, {
                ...updateData,
                permissoes: updateData.permissoes,
            });
        });

        // Teste extra para cobrir branch sem email e permissoes
        it('should update user without changing email or permissions if not provided', async () => {
            const userId = 1;
            const existingUser = {
                id: userId,
                email: 'old@example.com',
                permissoes: [{ id: 'perm1', rota: '/rota1' }],
            };
            mockRepository.buscarPorId.mockResolvedValue(existingUser);

            const updateData = { name: 'Updated Name' }; // sem email e permissoes
            const updatedUser = { ...existingUser, name: 'Updated Name' };
            mockRepository.atualizar.mockResolvedValue(updatedUser);

            const result = await usuarioService.atualizar(userId, updateData);

            // Não chamou buscarPorEmail ou buscarPorPermissao
            expect(mockRepository.buscarPorEmail).not.toHaveBeenCalled();
            expect(mockRepository.buscarPorPermissao).not.toHaveBeenCalled();

            expect(result).toEqual(updatedUser);
            expect(mockRepository.atualizar).toHaveBeenCalledWith(userId, updateData);
        });
    });

    // ---------------------------------
    // deletar
    // ---------------------------------
    describe('deletar', () => {
        it('should delete an existing user', async () => {
            const userId = 1;
            mockRepository.buscarPorId.mockResolvedValue({ id: userId });
            const expectedData = { message: 'User deleted successfully' };
            mockRepository.deletar.mockResolvedValue(expectedData);

            const result = await usuarioService.deletar(userId);

            expect(mockRepository.buscarPorId).toHaveBeenCalledWith(userId);
            expect(mockRepository.deletar).toHaveBeenCalledWith(userId);
            expect(result).toEqual(expectedData);
        });

        it('should throw an error if user does not exist when deleting', async () => {
            const userId = 999;
            mockRepository.buscarPorId.mockResolvedValue(null);

            await expect(usuarioService.deletar(userId)).rejects.toThrow('Recurso não encontrado em Usuário.');
        });
    });

    // ---------------------------------
    // adicionarPermissoes
    // ---------------------------------
    describe('adicionarPermissoes', () => {
        it('should add permissions to a user', async () => {
            const req = {
                params: { id: 1 },
                body: {
                    permissoes: [
                        { id: 'perm1', rota: '/rota1' },
                        { id: 'perm2', rota: '/rota2' },
                    ],
                },
            };

            PermissoesArraySchema.parse = jest.fn().mockReturnValue(req.body.permissoes);
            mockRepository.adicionarPermissoes.mockResolvedValue(req.body.permissoes);

            const result = await usuarioService.adicionarPermissoes(req);

            expect(PermissoesArraySchema.parse).toHaveBeenCalledWith(req.body.permissoes);
            expect(mockRepository.adicionarPermissoes).toHaveBeenCalledWith(req.params.id, req.body.permissoes);
            expect(result).toEqual(req.body.permissoes);
        });
    });

    // ---------------------------------
    // removerPermissao
    // ---------------------------------
    describe('removerPermissao', () => {
        it('should remove a permission from a user', async () => {
            const userId = 1;
            const permissaoId = 'perm1';
            const expectedData = ['perm2'];

            mockRepository.removerPermissao.mockResolvedValue(expectedData);

            const result = await usuarioService.removerPermissao(userId, permissaoId);

            expect(mockRepository.removerPermissao).toHaveBeenCalledWith(userId, permissaoId);
            expect(result).toEqual(expectedData);
        });
    });

    // ---------------------------------
    // atualizarPermissoes
    // ---------------------------------
    describe('atualizarPermissoes', () => {
        it('should update permissions of a user', async () => {
            const userId = 1;
            const permissoesData = [
                { id: 'perm1', rota: '/rota1' },
                { id: 'perm2', rota: '/rota2' },
            ];

            PermissoesArraySchema.parse = jest.fn().mockReturnValue(permissoesData);
            mockRepository.atualizarPermissoes.mockResolvedValue(permissoesData);

            const result = await usuarioService.atualizarPermissoes(userId, permissoesData);

            expect(PermissoesArraySchema.parse).toHaveBeenCalledWith(permissoesData);
            expect(mockRepository.atualizarPermissoes).toHaveBeenCalledWith(userId, permissoesData);
            expect(result).toEqual(permissoesData);
        });
    });

    // =============================
    // TESTES DIRETOS DOS MÉTODOS AUXILIARES
    // =============================
    describe('validatePermissions (direct)', () => {
        it('should return permissoesExistentes if they match exactly', async () => {
            const permsInput = [{ id: 'perm1', rota: '/rota1' }];
            mockRepository.buscarPorPermissao.mockResolvedValue(permsInput);

            const result = await usuarioService.validatePermissions(permsInput);

            expect(result).toEqual(permsInput);
            expect(mockRepository.buscarPorPermissao).toHaveBeenCalledWith(permsInput);
        });

        it('should handle empty array', async () => {
            mockRepository.buscarPorPermissao.mockResolvedValue([]);
            const result = await usuarioService.validatePermissions([]);
            expect(result).toEqual([]);
            expect(mockRepository.buscarPorPermissao).toHaveBeenCalledWith([]);
        });

        it('should convert non-array permissoes (string) to an empty array', async () => {
            const nonArrayInput = 'invalidPermissions';
            mockRepository.buscarPorPermissao.mockResolvedValue([]);

            const result = await usuarioService.validatePermissions(nonArrayInput);

            expect(result).toEqual([]);
            expect(mockRepository.buscarPorPermissao).toHaveBeenCalledWith([]);
        });

        it('should convert undefined permissoes to an empty array', async () => {
            mockRepository.buscarPorPermissao.mockResolvedValue([]);

            const result = await usuarioService.validatePermissions(undefined);

            expect(result).toEqual([]);
            expect(mockRepository.buscarPorPermissao).toHaveBeenCalledWith([]);
        });

        it('should convert null permissoes to an empty array', async () => {
            mockRepository.buscarPorPermissao.mockResolvedValue([]);

            const result = await usuarioService.validatePermissions(null);

            expect(result).toEqual([]);
            expect(mockRepository.buscarPorPermissao).toHaveBeenCalledWith([]);
        });

        it('should throw CustomError if mismatch in length', async () => {
            const permsInput = [{ id: 'perm1', rota: '/rota1' }];
            mockRepository.buscarPorPermissao.mockResolvedValue([]); // mismatch

            await expect(usuarioService.validatePermissions(permsInput)).rejects.toThrow(CustomError);
            await expect(usuarioService.validatePermissions(permsInput)).rejects.toThrow('Permissões inválidas.');
        });
    });

    describe('ensureUserExists (direct)', () => {
        it('should return the user if it exists', async () => {
            const userId = 10;
            const userMock = { id: userId, name: 'Exists' };
            mockRepository.buscarPorId.mockResolvedValue(userMock);

            const result = await usuarioService.ensureUserExists(userId);

            expect(result).toEqual(userMock);
            expect(mockRepository.buscarPorId).toHaveBeenCalledWith(userId);
        });

        it('should throw error if user does not exist', async () => {
            mockRepository.buscarPorId.mockResolvedValue(null);

            await expect(usuarioService.ensureUserExists(999)).rejects.toThrow(
                'Recurso não encontrado em Usuário.'
            );
        });
    });

    // =============================
    // TESTE DIRETO DO MÉTODO validateEmail
    // =============================
    describe('validateEmail (direct)', () => {
        it('should throw CustomError if email already exists', async () => {
            const email = 'existing@example.com';
            // Simula que o repositório encontrou um usuário com o email
            mockRepository.buscarPorEmail.mockResolvedValue({ id: 1, email });

            await expect(usuarioService.validateEmail(email)).rejects.toThrow('Email já está em uso.');
        });

        it('should not throw error if email does not exist', async () => {
            const email = 'new@example.com';
            mockRepository.buscarPorEmail.mockResolvedValue(null);

            // Como não há erro, o método resolve normalmente (retorna undefined)
            await expect(usuarioService.validateEmail(email)).resolves.toBeUndefined();
        });
    });
});

===== ./tests/unit/utils/helpers/CommonResponse.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/utils/helpers/CommonResponse.test.js

import assert from 'assert';
import CommonResponse from '../../../../../src/utils/helpers/CommonResponse.js';
import StatusService from '../../../../../src/utils/helpers/StatusService.js';

describe('CommonResponse', () => {
    let res;

    beforeEach(() => {
        res = {
            statusCalledWith: null,
            jsonCalledWith: null,
            status(code) {
                this.statusCalledWith = code;
                return this;
            },
            json(data) {
                // Utilize o método toJSON se disponível
                this.jsonCalledWith = data.toJSON ? data.toJSON() : data;
            }
        };
    });

    afterEach(() => {
        // Restaura os métodos originais do StatusService, se foram sobrescritos
        if (StatusService.getHttpCodeMessage.restore) {
            StatusService.getHttpCodeMessage.restore();
        }
        if (StatusService.getErrorMessage.restore) {
            StatusService.getErrorMessage.restore();
        }
    });

    describe('success', () => {
        it('deve retornar uma resposta de sucesso com mensagem padrão', () => {
            // Salva o método original
            const originalGetHttpCodeMessage = StatusService.getHttpCodeMessage;
            // Substitui o método por uma função mock
            StatusService.getHttpCodeMessage = () => 'OK';

            CommonResponse.success(res, { key: 'value' });

            assert.strictEqual(res.statusCalledWith, 200, 'O status HTTP deve ser 200');
            assert.deepStrictEqual(res.jsonCalledWith, {
                error: false,
                code: 200,
                message: 'OK',
                data: { key: 'value' },
                errors: []
            }, 'A resposta JSON deve corresponder ao esperado');

            // Restaura o método original
            StatusService.getHttpCodeMessage = originalGetHttpCodeMessage;
        });

        it('deve retornar uma resposta de sucesso com mensagem personalizada', () => {
            CommonResponse.success(res, { key: 'value' }, 200, 'Mensagem de Sucesso Personalizada');

            assert.strictEqual(res.statusCalledWith, 200, 'O status HTTP deve ser 200');
            assert.deepStrictEqual(res.jsonCalledWith, {
                error: false,
                code: 200,
                message: 'Mensagem de Sucesso Personalizada',
                data: { key: 'value' },
                errors: []
            }, 'A resposta JSON deve corresponder ao esperado');
        });
    });

    describe('error', () => {
        it('deve retornar uma resposta de erro com mensagem padrão', () => {
            // Salva o método original
            const originalGetErrorMessage = StatusService.getErrorMessage;
            // Substitui o método por uma função mock
            StatusService.getErrorMessage = () => 'Mensagem de Erro Padrão';

            CommonResponse.error(res, 400, 'errorType');

            assert.strictEqual(res.statusCalledWith, 400, 'O status HTTP deve ser 400');
            assert.deepStrictEqual(res.jsonCalledWith, {
                error: true,
                code: 400,
                message: 'Mensagem de Erro Padrão',
                data: null,
                errors: []
            }, 'A resposta JSON deve corresponder ao esperado');

            // Restaura o método original
            StatusService.getErrorMessage = originalGetErrorMessage;
        });

        it('deve retornar uma resposta de erro com mensagem personalizada', () => {
            CommonResponse.error(res, 400, 'errorType', null, [], 'Mensagem de Erro Personalizada');

            assert.strictEqual(res.statusCalledWith, 400, 'O status HTTP deve ser 400');
            assert.deepStrictEqual(res.jsonCalledWith, {
                error: true,
                code: 400,
                message: 'Mensagem de Erro Personalizada',
                data: null,
                errors: []
            }, 'A resposta JSON deve corresponder ao esperado');
        });
    });

    describe('created', () => {
        it('deve retornar uma resposta de criação sem mensagem personalizada', () => {
            // Mock do método getHttpCodeMessage para código 201
            const originalGetHttpCodeMessage = StatusService.getHttpCodeMessage;
            StatusService.getHttpCodeMessage = () => 'Created';

            CommonResponse.created(res, { key: 'value' });

            assert.strictEqual(res.statusCalledWith, 201, 'O status HTTP deve ser 201');
            assert.deepStrictEqual(res.jsonCalledWith, {
                error: false,
                code: 201,
                message: 'Created',
                data: { key: 'value' },
                errors: []
            }, 'A resposta JSON deve corresponder ao esperado');

            // Restaura o método original
            StatusService.getHttpCodeMessage = originalGetHttpCodeMessage;
        });

        it('deve retornar uma resposta de criação com mensagem personalizada', () => {
            CommonResponse.created(res, { key: 'value' }, 'Recurso Criado com Sucesso');

            assert.strictEqual(res.statusCalledWith, 201, 'O status HTTP deve ser 201');
            assert.deepStrictEqual(res.jsonCalledWith, {
                error: false,
                code: 201,
                message: 'Recurso Criado com Sucesso',
                data: { key: 'value' },
                errors: []
            }, 'A resposta JSON deve corresponder ao esperado');
        });
    });

    describe('serverError', () => {
        it('deve retornar uma resposta de erro de servidor com mensagem padrão', () => {
            // Salva o método original
            const originalGetErrorMessage = StatusService.getErrorMessage;
            // Substitui o método por uma função mock
            StatusService.getErrorMessage = () => 'Erro Interno do Servidor';

            CommonResponse.serverError(res);

            assert.strictEqual(res.statusCalledWith, 500, 'O status HTTP deve ser 500');
            assert.deepStrictEqual(res.jsonCalledWith, {
                error: true,
                code: 500,
                message: 'Erro Interno do Servidor',
                data: null,
                errors: []
            }, 'A resposta JSON deve corresponder ao esperado');

            // Restaura o método original
            StatusService.getErrorMessage = originalGetErrorMessage;
        });

        it('deve retornar uma resposta de erro de servidor com mensagem personalizada', () => {
            CommonResponse.serverError(res, 'Mensagem de Erro de Servidor Personalizada');

            assert.strictEqual(res.statusCalledWith, 500, 'O status HTTP deve ser 500');
            assert.deepStrictEqual(res.jsonCalledWith, {
                error: true,
                code: 500,
                message: 'Mensagem de Erro de Servidor Personalizada',
                data: null,
                errors: []
            }, 'A resposta JSON deve corresponder ao esperado');
        });
    });

    // Novo bloco de testes para a instância direta do construtor
    describe('Instanciação Direta', () => {
        it('deve criar uma instância diretamente com parâmetros mínimos', () => {
            const response = new CommonResponse(false, 200, 'OK');
            assert.deepStrictEqual(response.toJSON(), {
                error: false,
                code: 200,
                message: 'OK',
                data: null,
                errors: []
            }, 'A instância criada deve corresponder ao objeto esperado com valores padrão');
        });

        it('deve criar uma instância diretamente com todos os parâmetros', () => {
            const response = new CommonResponse(true, 400, 'Erro', { detail: 'Detalhe do erro' }, ['Erro 1', 'Erro 2']);
            assert.deepStrictEqual(response.toJSON(), {
                error: true,
                code: 400,
                message: 'Erro',
                data: { detail: 'Detalhe do erro' },
                errors: ['Erro 1', 'Erro 2']
            }, 'A instância criada deve corresponder ao objeto esperado com todos os parâmetros fornecidos');
        });
    });
});

===== ./tests/unit/utils/helpers/CustomError.test.js =====


===== # =====


===== separador =====


===== legível =====

import CustomError from '../../../../utils/helpers/CustomError.js';

describe('CustomError', () => {
    it('deve criar uma instância de CustomError com todas as propriedades', () => {
        const errorParams = {
            statusCode: 400,
            errorType: 'validationError',
            field: 'email',
            details: [{ path: 'email', message: 'Email inválido' }],
            customMessage: 'Endereço de email inválido'
        };
        const error = new CustomError(errorParams);

        if (!(error instanceof CustomError)) throw new Error('Esperado que o erro seja uma instância de CustomError');
        if (error.statusCode !== errorParams.statusCode) throw new Error('O código de status não corresponde');
        if (error.errorType !== errorParams.errorType) throw new Error('O tipo de erro não corresponde');
        if (error.field !== errorParams.field) throw new Error('O campo não corresponde');
        if (JSON.stringify(error.details) !== JSON.stringify(errorParams.details)) throw new Error('Os detalhes não correspondem');
        if (error.customMessage !== errorParams.customMessage) throw new Error('A mensagem personalizada não corresponde');
        if (!error.isOperational) throw new Error('Esperado que isOperational seja verdadeiro');
    });

    it('deve criar uma instância de CustomError com valores padrão para propriedades opcionais', () => {
        const errorParams = {
            statusCode: 404,
            errorType: 'notFound'
        };
        const error = new CustomError(errorParams);

        if (!(error instanceof CustomError)) throw new Error('Esperado que o erro seja uma instância de CustomError');
        if (error.statusCode !== errorParams.statusCode) throw new Error('O código de status não corresponde');
        if (error.errorType !== errorParams.errorType) throw new Error('O tipo de erro não corresponde');
        if (error.field !== null) throw new Error('Esperado que o campo seja nulo');
        if (JSON.stringify(error.details) !== JSON.stringify([])) throw new Error('Esperado que os detalhes sejam um array vazio');
        if (error.customMessage !== null) throw new Error('Esperado que a mensagem personalizada seja nula');
        if (!error.isOperational) throw new Error('Esperado que isOperational seja verdadeiro');
    });

    it('deve capturar o rastreamento de pilha', () => {
        const errorParams = {
            statusCode: 500,
            errorType: 'serverError',
            customMessage: 'Erro interno do servidor'
        };
        const error = new CustomError(errorParams);

        if (typeof error.stack !== 'string') throw new Error('Esperado que a pilha seja uma string');
        if (!error.stack.includes('CustomError')) throw new Error('Esperado que a pilha inclua "CustomError"');
    });
});

===== ./tests/unit/utils/helpers/errorHandler.test.js =====


===== # =====


===== separador =====


===== legível =====

import { jest } from '@jest/globals';
import { ZodError } from 'zod';
import mongoose from 'mongoose';
import errorHandler from '../../../../utils/helpers/errorHandler.js';
import CustomError from '../../../../utils/helpers/CustomError.js';
import AuthenticationError from '../../../../utils/errors/AuthenticationError.js';
import TokenExpiredError from '../../../../utils/errors/TokenExpiredError.js';
import CommonResponse from '../../../../utils/helpers/CommonResponse.js';
import logger from '../../../../utils/logger.js';

// Spy on logger (if needed)

jest.mock('../../../../utils/helpers/CommonResponse.js');

describe('errorHandler', () => {
    let req;
    let res;
    const next = jest.fn();

    beforeEach(() => {
        req = { path: '/test', requestId: 'test-req-id' };
        res = {}; // dummy, CommonResponse.error is being called instead
        CommonResponse.error.mockClear();
    });

    it('should handle ZodError and return 400 validationError', () => {
        const fakeError = new ZodError([{ path: ['field'], message: 'Invalid value' }]);
        process.env.NODE_ENV = 'development';
        errorHandler(fakeError, req, res, next);

        expect(CommonResponse.error).toHaveBeenCalledWith(
            res,
            400,
            'validationError',
            null,
            [{ path: 'field', message: 'Invalid value' }],
            'Erro de validação. 1 campo(s) inválido(s).'
        );
    });

    it('should handle MongoDB duplicate key error and return 409 duplicateEntry', () => {
        const fakeError = { code: 11000, keyValue: { email: 'test@example.com' } };
        errorHandler(fakeError, req, res, next);

        expect(CommonResponse.error).toHaveBeenCalledWith(
            res,
            409,
            'duplicateEntry',
            'email',
            [{ path: 'email', message: 'O valor "test@example.com" já está em uso.' }],
            'Entrada duplicada no campo "email".'
        );
    });

    it('should handle Mongoose ValidationError and return 400 validationError', () => {
        const fakeMongooseError = new mongoose.Error.ValidationError();
        fakeMongooseError.errors = {
            name: { path: 'name', message: 'Name is required' },
            age: { path: 'age', message: 'Age must be a number' }
        };

        errorHandler(fakeMongooseError, req, res, next);
        const detalhes = [
            { path: 'name', message: 'Name is required' },
            { path: 'age', message: 'Age must be a number' }
        ];

        expect(CommonResponse.error).toHaveBeenCalledWith(
            res,
            400,
            'validationError',
            null,
            detalhes
        );
    });

    it('should handle AuthenticationError and return its status and message', () => {
        const fakeError = new AuthenticationError('Not authenticated', 401);
        errorHandler(fakeError, req, res, next);

        expect(CommonResponse.error).toHaveBeenCalledWith(
            res,
            fakeError.statusCode,
            'authenticationError',
            null,
            [{ message: fakeError.message }],
            fakeError.message
        );
    });

    it('should handle TokenExpiredError and return its status and message', () => {
        const fakeError = new TokenExpiredError('Token expired', 401);
        errorHandler(fakeError, req, res, next);

        expect(CommonResponse.error).toHaveBeenCalledWith(
            res,
            fakeError.statusCode,
            'authenticationError',
            null,
            [{ message: fakeError.message }],
            fakeError.message
        );
    });

    it("should handle CustomError with errorType 'tokenExpired'", () => {
        const fakeError = new CustomError('Session expired', {
            errorType: 'tokenExpired',
            statusCode: 401,
            customMessage: 'Seu token expirou. Faça login novamente.'
        });
        errorHandler(fakeError, req, res, next);

        expect(CommonResponse.error).toHaveBeenCalledWith(
            res,
            401,
            'tokenExpired',
            null,
            [{ message: 'Seu token expirou. Faça login novamente.' }],
            'Seu token expirou. Faça login novamente.'
        );
    });

    it('should handle operational errors', () => {
        const fakeError = new Error('Operational failure');
        fakeError.isOperational = true;
        fakeError.statusCode = 422;
        fakeError.errorType = 'operationalError';
        fakeError.details = [{ message: 'Detail info' }];
        fakeError.customMessage = 'Operacional Falhou';
        fakeError.field = 'someField';

        errorHandler(fakeError, req, res, next);
        expect(CommonResponse.error).toHaveBeenCalledWith(
            res,
            422,
            'operationalError',
            'someField',
            [{ message: 'Detail info' }],
            'Operacional Falhou'
        );
    });

    it('should handle non-operational errors as internal errors', () => {
        const fakeError = new Error('Internal error occurred');
        process.env.NODE_ENV = 'development';
        errorHandler(fakeError, req, res, next);

        // In development, the error details include message and stack.
        const callArgs = CommonResponse.error.mock.calls[0];
        expect(callArgs[0]).toBe(res);
        expect(callArgs[1]).toBe(500);
        expect(callArgs[2]).toBe('serverError');
        // We check that details contain the error message and stack.
        expect(callArgs[4][0].message).toBe(fakeError.message);
        expect(callArgs[4][0].stack).toBeDefined();
    });
});
===== ./tests/unit/utils/helpers/index.test.js =====


===== # =====


===== separador =====


===== legível =====

// test/helpers.test.js

import assert from 'assert';
import * as Helpers from '../../../../utils/helpers/index.js';

describe('Módulo Helpers', () => {
    it('deve exportar CommonResponse', () => {
        assert.ok(Helpers.hasOwnProperty('CommonResponse'), "Helpers deve ter a propriedade 'CommonResponse'");
    });

    it('deve exportar CustomError', () => {
        assert.ok(Helpers.hasOwnProperty('CustomError'), "Helpers deve ter a propriedade 'CustomError'");
    });

    it('deve exportar HttpStatusCodes', () => {
        assert.ok(Helpers.hasOwnProperty('HttpStatusCodes'), "Helpers deve ter a propriedade 'HttpStatusCodes'");
    });

    it('deve exportar errorHandler', () => {
        assert.ok(Helpers.hasOwnProperty('errorHandler'), "Helpers deve ter a propriedade 'errorHandler'");
    });

    it('deve exportar messages', () => {
        assert.ok(Helpers.hasOwnProperty('messages'), "Helpers deve ter a propriedade 'messages'");
    });

    it('deve exportar StatusService', () => {
        assert.ok(Helpers.hasOwnProperty('StatusService'), "Helpers deve ter a propriedade 'StatusService'");
    });

    it('deve exportar asyncWrapper', () => {
        assert.ok(Helpers.hasOwnProperty('asyncWrapper'), "Helpers deve ter a propriedade 'asyncWrapper'");
    });
});

===== ./tests/unit/utils/helpers/messages.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/utils/helpers/messages.test.js

import messages from '../../../../utils/helpers/messages.js';

describe('Messages Helper', () => {
    describe('Informative Messages', () => {
        test('deve retornar mensagem de boas-vindas', () => {
            expect(messages.info.welcome).toBe("Bem-vindo à nossa aplicação!");
        });

        test('deve retornar mensagem de usuário logado', () => {
            const username = 'Gilberto';
            expect(messages.info.userLoggedIn(username)).toBe(`Usuário ${username} logado com sucesso.`);
        });
    });

    describe('Success Messages', () => {
        test('deve retornar mensagem de sucesso padrão', () => {
            expect(messages.success.default).toBe("Operação concluída com sucesso.");
        });
    });

    describe('Error Messages', () => {
        test('deve retornar mensagem de erro padrão', () => {
            expect(messages.error.default).toBe("Ocorreu um erro ao processar a solicitação.");
        });

        test('deve retornar mensagem de erro de servidor', () => {
            expect(messages.error.serverError).toBe("Erro interno do servidor. Tente novamente mais tarde.");
        });

        test('deve retornar mensagem de erro de validação', () => {
            expect(messages.error.validationError).toBe("Erro de validação. Verifique os dados fornecidos e tente novamente.");
        });

        test('deve retornar mensagem de requisição inválida', () => {
            expect(messages.error.invalidRequest).toBe("Requisição inválida. Verifique os parâmetros fornecidos.");
        });

        test('deve retornar mensagem de acesso não autorizado', () => {
            expect(messages.error.unauthorizedAccess).toBe("Acesso não autorizado. Faça login para continuar.");
        });

        test('deve retornar mensagem de URL inválida', () => {
            expect(messages.error.invalidURL).toBe("URL inválida. Verifique a URL fornecida.");
        });

        test('deve retornar mensagem de operação não suportada', () => {
            expect(messages.error.unsupportedOperation).toBe("Operação não suportada neste contexto.");
        });

        test('deve retornar mensagem de erro ao analisar os dados', () => {
            expect(messages.error.dataParsingError).toBe("Erro ao analisar os dados recebidos.");
        });

        test('deve retornar mensagem de erro ao comunicar com serviço externo', () => {
            expect(messages.error.externalServiceError).toBe("Erro ao se comunicar com um serviço externo.");
        });

        test('deve retornar mensagem de chave de API inválida', () => {
            expect(messages.error.invalidApiKey).toBe("Chave de API inválida.");
        });

        test('deve retornar mensagem de operação cancelada pelo usuário', () => {
            expect(messages.error.operationCanceled).toBe("Operação cancelada pelo usuário.");
        });

        test('deve retornar mensagem de recurso não encontrado', () => {
            const fieldName = 'Recurso';
            expect(messages.error.resourceNotFound(fieldName)).toBe(`${fieldName} não encontrado(a).`);
        });

        test('deve retornar mensagem de página não disponível', () => {
            const page = 'Página';
            expect(messages.error.pageIsNotAvailable(page)).toBe(`A página ${page} não está disponível.`);
        });

        test('deve retornar mensagem de página sem dados', () => {
            const page = 'Página';
            expect(messages.error.pageNotContainsData(page)).toBe(`A página ${page} não contém dados.`);
        });

        test('deve retornar mensagem de entrada duplicada', () => {
            const fieldName = 'Campo';
            expect(messages.error.duplicateEntry(fieldName)).toBe(`Já existe um registro com o dado informado no(s) campo(s) ${fieldName}.`);
        });

        test('deve retornar mensagem de recurso em uso', () => {
            const fieldName = 'Recurso';
            expect(messages.error.resourceInUse(fieldName)).toBe(`Recurso em uso em ${fieldName}.`);
        });
    });

    describe('Validation Messages', () => {
        test('deve retornar mensagem de campo obrigatório', () => {
            const fieldName = 'Campo';
            expect(messages.validation.generic.fieldIsRequired(fieldName)).toBe(`O campo ${fieldName} é obrigatório.`);
        });

        test('deve retornar mensagem de campo repetido', () => {
            const fieldName = 'Campo';
            expect(messages.validation.generic.fieldIsRepeated(fieldName)).toBe(`O campo ${fieldName} informado já está cadastrado.`);
        });

        test('deve retornar mensagem de formato de entrada inválido', () => {
            const fieldName = 'Campo';
            expect(messages.validation.generic.invalidInputFormat(fieldName)).toBe(`Formato de entrada inválido para o campo ${fieldName}.`);
        });

        test('deve retornar mensagem de valor inválido', () => {
            const fieldName = 'Campo';
            expect(messages.validation.generic.invalid(fieldName)).toBe(`Valor informado em ${fieldName} é inválido.`);
        });

        test('deve retornar mensagem de valor não encontrado', () => {
            const fieldName = 'Campo';
            expect(messages.validation.generic.notFound(fieldName)).toBe(`Valor informado para o campo ${fieldName} não foi encontrado.`);
        });

        test('deve retornar mensagem de valor deve ser um dos especificados', () => {
            const fieldName = 'Campo';
            const values = ['Valor1', 'Valor2'];
            expect(messages.validation.generic.mustBeOneOf(fieldName, values)).toBe(`O campo ${fieldName} deve ser um dos seguintes valores: ${values.join(", ")}.`);
        });

        test('deve retornar mensagem de recurso criado com sucesso', () => {
            const fieldName = 'Recurso';
            expect(messages.validation.generic.resourceCreated(fieldName)).toBe(`${fieldName} criado(a) com sucesso.`);
        });

        test('deve retornar mensagem de recurso atualizado com sucesso', () => {
            const fieldName = 'Recurso';
            expect(messages.validation.generic.resourceUpdated(fieldName)).toBe(`${fieldName} atualizado(a) com sucesso.`);
        });

        test('deve retornar mensagem de recurso excluído com sucesso', () => {
            const fieldName = 'Recurso';
            expect(messages.validation.generic.resourceDeleted(fieldName)).toBe(`${fieldName} excluído(a) com sucesso.`);
        });

        test('deve retornar mensagem de recurso já existente', () => {
            const fieldName = 'Recurso';
            expect(messages.validation.generic.resourceAlreadyExists(fieldName)).toBe(`${fieldName} já existe.`);
        });

        test('deve retornar mensagem de recurso com referência', () => {
            const resource = 'Recurso';
            const reference = 'Referência';
            expect(messages.validation.reference.resourceWithReference(resource, reference)).toBe(`${resource} com referência em ${reference}. Exclusão impedida.`);
        });

        test('deve retornar mensagem de CPF inválido', () => {
            expect(messages.validation.custom.invalidCPF.message).toBe("CPF inválido. Verifique o formato e tente novamente.");
        });

        test('deve retornar mensagem de CNPJ inválido', () => {
            expect(messages.validation.custom.invalidCNPJ.message).toBe("CNPJ inválido. Verifique o formato e tente novamente.");
        });

        test('deve retornar mensagem de CEP inválido', () => {
            expect(messages.validation.custom.invalidCEP.message).toBe("CEP inválido. Verifique o formato e tente novamente.");
        });

        test('deve retornar mensagem de número de telefone inválido', () => {
            expect(messages.validation.custom.invalidPhoneNumber.message).toBe("Número de telefone inválido. Verifique o formato e tente novamente.");
        });

        test('deve retornar mensagem de email inválido', () => {
            expect(messages.validation.custom.invalidMail.message).toBe("Email no formato inválido.");
        });

        test('deve retornar mensagem de ano inválido', () => {
            expect(messages.validation.custom.invalidYear.message).toBe("Ano inválido. Verifique o formato e tente novamente.");
        });

        test('deve retornar mensagem de data inválida', () => {
            expect(messages.validation.custom.invalidDate.message).toBe("Data inválida. Verifique o formato e tente novamente.");
        });

        test('deve retornar mensagem de quilometragem inicial inválida', () => {
            expect(messages.validation.custom.invalidKilometerInitial.message).toBe("Quilometragem inicial inválida.");
        });

        test('deve retornar mensagem de quilometragem inválida', () => {
            expect(messages.validation.custom.invalidKilometer.message).toBe("Quilometragem inválida.");
        });

        test('deve retornar mensagem de data de início inválida (passada)', () => {
            expect(messages.validation.custom.invalidDatePast.message).toBe("Data do início deve ser uma data atual ou futura.");
        });

        test('deve retornar mensagem de data de conclusão inválida (futura)', () => {
            expect(messages.validation.custom.invalidDateFuture.message).toBe("A data de conclusão deve ser maior do que a data de início!");
        });

        test('deve retornar mensagem de data de início inválida (atual ou passada)', () => {
            expect(messages.validation.custom.invalidDateCurrent.message).toBe("Data do início deve ser uma data atual ou passada.");
        });

        test('deve retornar mensagem de vigência com período maior que 12 meses', () => {
            expect(messages.validation.custom.invalidDateMonths.message).toBe("A data final da vigência não pode ser um período maior que 12 meses após a data de início da vigência.");
        });

        test('deve retornar mensagem de data de nascimento inválida', () => {
            expect(messages.validation.custom.invalidDataNascimento.message).toBe("Data de nascimento deve ser uma data passada e maior que 18 anos.");
        });

        test('deve retornar mensagem de data de admissão inválida', () => {
            expect(messages.validation.custom.invalidDataAdmissao.message).toBe("Data de admissão deve ser uma data atual ou passada.");
        });

        test('deve retornar mensagem de ano/semestre inválido', () => {
            expect(messages.validation.custom.invalidYearSemester.message).toBe("Ano/semestre. Verifique o formato e tente novamente.");
        });

        test('deve retornar mensagem de data de início do semestre inválida', () => {
            expect(messages.validation.custom.invalidYearStartSemester.message).toBe("Data do início do semestre deve ser menor que a data fim de semestre.");
        });
    });

    describe('Authentication Messages', () => {
        test('deve retornar mensagem de falha na autenticação', () => {
            expect(messages.auth.authenticationFailed).toBe("Falha na autenticação. Credenciais inválidas.");
        });

        test('deve retornar mensagem de usuário não encontrado', () => {
            const userId = '123';
            expect(messages.auth.userNotFound(userId)).toBe(`Usuário com ID ${userId} não encontrado.`);
        });

        test('deve retornar mensagem de permissão insuficiente', () => {
            expect(messages.auth.invalidPermission).toBe("Permissão insuficiente para executar a operação.");
        });

        test('deve retornar mensagem de entrada duplicada', () => {
            const fieldName = 'Campo';
            expect(messages.auth.duplicateEntry(fieldName)).toBe(`Já existe um registro com o mesmo ${fieldName}.`);
        });

        test('deve retornar mensagem de conta bloqueada', () => {
            expect(messages.auth.accountLocked).toBe("Conta bloqueada. Entre em contato com o suporte.");
        });

        test('deve retornar mensagem de token inválido', () => {
            expect(messages.auth.invalidToken).toBe("Token inválido. Faça login novamente.");
        });

        test('deve retornar mensagem de tempo de espera excedido', () => {
            expect(messages.auth.timeoutError).toBe("Tempo de espera excedido. Tente novamente mais tarde.");
        });

        test('deve retornar mensagem de erro de conexão com o banco de dados', () => {
            expect(messages.auth.databaseConnectionError).toBe("Erro de conexão com o banco de dados. Tente novamente mais tarde.");
        });

        test('deve retornar mensagem de email já existente', () => {
            const email = 'email@example.com';
            expect(messages.auth.emailAlreadyExists(email)).toBe(`O endereço de email ${email} já está em uso.`);
        });

        test('deve retornar mensagem de credenciais inválidas', () => {
            expect(messages.auth.invalidCredentials).toBe("Credenciais inválidas. Verifique seu usuário e senha.");
        });
    });
});

===== ./tests/unit/utils/helpers/StatusService.test.js =====


===== # =====


===== separador =====


===== legível =====

import assert from 'assert';
import StatusService from '../../../../../src/utils/helpers/StatusService.js';
import HttpStatusCodes from '../../../../../src/utils/helpers/HttpStatusCodes.js';
import messages from '../../../../../src/utils/helpers/messages.js';

// src/tests/unit/utils/helpers/StatusService.test.js

describe('StatusService', () => {
    describe('getHttpCodeMessage', () => {
        it('deve retornar a mensagem correta para um código de status HTTP conhecido', () => {
            const code = 200;
            const expectedMessage = 'OK';
            HttpStatusCodes[code] = { code, message: expectedMessage };

            const result = StatusService.getHttpCodeMessage(code);
            assert.strictEqual(result, expectedMessage);
        });

        it('deve retornar "Status desconhecido." para um código de status HTTP desconhecido', () => {
            const code = 999;
            const result = StatusService.getHttpCodeMessage(code);
            assert.strictEqual(result, 'Status desconhecido.');
        });
    });

    describe('getErrorMessage', () => {
        it('deve retornar a mensagem de erro correta para um tipo de erro conhecido', () => {
            const type = 'REQUIRED_FIELD';
            const expectedMessage = 'This field is required.';
            messages.error[type] = expectedMessage;

            const result = StatusService.getErrorMessage(type);
            assert.strictEqual(result, expectedMessage);
        });

        it('deve retornar a mensagem de erro correta para um tipo de erro conhecido com um campo', () => {
            const type = 'INVALID_FIELD';
            const field = 'email';
            const expectedMessage = `The field ${field} is invalid.`;
            messages.error[type] = (field) => `The field ${field} is invalid.`;

            const result = StatusService.getErrorMessage(type, field);
            assert.strictEqual(result, expectedMessage);
        });

        it('deve retornar "Tipo de erro desconhecido." para um tipo de erro desconhecido', () => {
            const type = 'UNKNOWN_ERROR';
            const result = StatusService.getErrorMessage(type);
            assert.strictEqual(result, 'Tipo de erro desconhecido.');
        });
    });
});

===== ./tests/unit/utils/logger.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/utils/logger.test.js

// Mockando 'winston-daily-rotate-file' antes de qualquer importação que possa depender dele
jest.mock('winston-daily-rotate-file', () => {
    const TransportStream = require('winston-transport'); // Importa TransportStream

    return {
        __esModule: true, // Indica que é um módulo ES6
        default: class MockDailyRotateFile extends TransportStream { // Extende TransportStream
            constructor(options) {
                super(options);
                this.options = options;
            }

            log(info, callback) {
                // Simula a função de log
                callback();
            }
        },
    };
});

const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');
const { transports } = require('winston');

// Importando dotenv para carregar variáveis de ambiente
dotenv.config();

describe('Utilitário de Logger', () => {
    const originalEnv = { ...process.env };
    const logDirectory = path.resolve(process.cwd(), 'logs');

    let getTotalLogSize;
    let ensureLogSizeLimit;
    let logIntervalId;
    let maxLogSize;
    let logger;

    // Mocking winston transports to prevent actual logging
    beforeAll(() => {
        jest.spyOn(transports, 'Console').mockImplementation(() => ({
            log: jest.fn(),
            on: jest.fn(),
            emit: jest.fn(),
        }));

        // Mockando 'console.error' para suprimir mensagens de erro do Winston
        jest.spyOn(console, 'error').mockImplementation(() => { });
    });

    afterAll(() => {
        jest.restoreAllMocks();
    });

    // Configurando timers falsos para lidar com setInterval
    beforeEach(() => {
        jest.useFakeTimers();

        // Limpar qualquer estado global antes de cada teste
        delete global.loggerListenersSet;

        jest.resetModules();

        // Mockando métodos do fs
        jest.spyOn(fs, 'existsSync');
        jest.spyOn(fs, 'readdirSync');
        jest.spyOn(fs, 'statSync');
        jest.spyOn(fs, 'unlinkSync');
        jest.spyOn(fs, 'mkdirSync');

        // Configurando variáveis de ambiente antes de importar o módulo
        process.env.NODE_ENV = 'test';
        process.env.LOG_ENABLED = 'true';

        // Mockando process.exit antes de importar o módulo
        jest.spyOn(process, 'exit').mockImplementation(() => { });

        // Reimportando o módulo para garantir que as alterações de ambiente sejam refletidas
        const loggerImport = require('../../../utils/logger.js');
        getTotalLogSize = loggerImport.getTotalLogSize;
        ensureLogSizeLimit = loggerImport.ensureLogSizeLimit;
        logIntervalId = loggerImport.logIntervalId;
        maxLogSize = loggerImport.maxLogSize;
        logger = loggerImport.default;
    });

    // Restaurando mocks após cada teste
    afterEach(() => {
        process.env = { ...originalEnv };
        jest.restoreAllMocks();
        jest.clearAllTimers();
        delete global.loggerListenersSet;
    });

    describe('getTotalLogSize', () => {
        it('deve retornar 0 se o diretório de logs não existir', () => {
            fs.existsSync.mockReturnValue(false);

            const totalSize = getTotalLogSize(logDirectory);
            expect(totalSize).toBe(0);
        });

        it('deve retornar 0 se o diretório de logs existir mas estiver vazio', () => {
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync.mockReturnValue([]);

            const totalSize = getTotalLogSize(logDirectory);
            expect(totalSize).toBe(0);
        });

        it('deve calcular o tamanho total dos arquivos de log', () => {
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync.mockReturnValue(['file1.log', 'file2.log']);
            fs.statSync.mockImplementation((filePath) => {
                if (filePath.endsWith('file1.log')) return { size: 100 };
                if (filePath.endsWith('file2.log')) return { size: 200 };
                return { size: 0 };
            });

            const totalSize = getTotalLogSize(logDirectory);
            expect(totalSize).toBe(300);
        });

        it('deve lançar erro se fs.statSync falhar', () => {
            fs.existsSync.mockReturnValue(true);
            fs.readdirSync.mockReturnValue(['file1.log']);
            fs.statSync.mockImplementation(() => { throw new Error('Erro no statSync'); });

            expect(() => getTotalLogSize(logDirectory)).toThrow('Erro no statSync');
        });
    });

    describe('ensureLogSizeLimit', () => {
        it('deve remover os arquivos mais antigos até que o limite de tamanho seja respeitado', () => {
            fs.readdirSync.mockReturnValue(['file1.log', 'file2.log']);
            fs.statSync.mockImplementation((filePath) => {
                if (filePath.endsWith('file1.log')) return { size: 100, mtime: new Date(2021, 1, 1) };
                if (filePath.endsWith('file2.log')) return { size: 200, mtime: new Date(2021, 1, 2) };
                return { size: 0, mtime: new Date() };
            });
            fs.unlinkSync.mockImplementation(() => { /* sem operação */ });

            // Total size = 100 + 200 = 300
            // maxSize = 150
            // Deve remover 'file1.log' (100), total = 200 ainda > 150, então remover 'file2.log'
            ensureLogSizeLimit(logDirectory, 150);

            expect(fs.unlinkSync).toHaveBeenCalledTimes(2);
            expect(fs.unlinkSync).toHaveBeenCalledWith(path.join(logDirectory, 'file1.log'));
            expect(fs.unlinkSync).toHaveBeenCalledWith(path.join(logDirectory, 'file2.log'));
        });

        it('deve remover apenas os arquivos necessários para respeitar o limite de tamanho', () => {
            fs.readdirSync.mockReturnValue(['file1.log', 'file2.log', 'file3.log']);
            fs.statSync.mockImplementation((filePath) => {
                if (filePath.endsWith('file1.log')) return { size: 50, mtime: new Date(2021, 1, 1) };
                if (filePath.endsWith('file2.log')) return { size: 50, mtime: new Date(2021, 1, 2) };
                if (filePath.endsWith('file3.log')) return { size: 100, mtime: new Date(2021, 1, 3) };
                return { size: 0, mtime: new Date() };
            });
            fs.unlinkSync.mockImplementation(() => { /* sem operação */ });

            // Total size = 50 + 50 + 100 = 200
            // maxSize = 150
            // Deve remover 'file1.log' (50), total = 150
            ensureLogSizeLimit(logDirectory, 150);

            expect(fs.unlinkSync).toHaveBeenCalledTimes(1);
            expect(fs.unlinkSync).toHaveBeenCalledWith(path.join(logDirectory, 'file1.log'));
        });

        it('não deve remover arquivos se o totalSize estiver dentro do limite', () => {
            fs.readdirSync.mockReturnValue(['file1.log', 'file2.log']);
            fs.statSync.mockImplementation((filePath) => {
                if (filePath.endsWith('file1.log')) return { size: 100, mtime: new Date() };
                if (filePath.endsWith('file2.log')) return { size: 100, mtime: new Date() };
                return { size: 0, mtime: new Date() };
            });
            fs.unlinkSync.mockImplementation(() => { /* sem operação */ });

            ensureLogSizeLimit(logDirectory, 300);

            expect(fs.unlinkSync).not.toHaveBeenCalled();
        });

        it('deve lançar erro se fs.readdirSync falhar', () => {
            fs.readdirSync.mockImplementation(() => { throw new Error('Erro no readdirSync'); });

            expect(() => ensureLogSizeLimit(logDirectory, 150)).toThrow('Erro no readdirSync');
        });

        it('deve lançar erro se fs.statSync falhar', () => {
            fs.readdirSync.mockReturnValue(['file1.log']);
            fs.statSync.mockImplementation(() => { throw new Error('Erro no statSync'); });

            expect(() => ensureLogSizeLimit(logDirectory, 150)).toThrow('Erro no statSync');
        });
    });

    describe('Configuração do Logger', () => {
        it('deve criar logger com os transports corretos', () => {
            const loggerTransports = logger.transports.map(transport => transport.constructor.name);
            expect(loggerTransports).toEqual(expect.arrayContaining(['Console', 'MockDailyRotateFile']));
        });

        it('deve criar o diretório de logs se ele não existir', () => {
            fs.existsSync.mockReturnValue(false);
            fs.mkdirSync.mockImplementation(() => { /* sem operação */ });

            // Reimportando logger para executar a lógica de criação do diretório
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            process.env.LOG_ENABLED = 'true';
            const loggerImport = require('../../../utils/logger.js');
            logger = loggerImport.default;

            expect(fs.mkdirSync).toHaveBeenCalledWith(logDirectory, { recursive: true });
        });

        it('não deve criar o diretório de logs se já existir', () => {
            fs.existsSync.mockReturnValue(true);
            fs.mkdirSync.mockImplementation(() => { /* sem operação */ });

            // Reimportando logger para executar a lógica de criação do diretório
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            process.env.LOG_ENABLED = 'true';
            const loggerImport = require('../../../utils/logger.js');
            logger = loggerImport.default;

            expect(fs.mkdirSync).not.toHaveBeenCalled();
        });

        it('não deve adicionar transports se logEnabled for false', () => {
            process.env.LOG_ENABLED = 'false';
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            const loggerImport = require('../../../utils/logger.js');
            logger = loggerImport.default;

            expect(logger.transports.length).toBe(0);
        });

        it('deve adicionar transports quando logEnabled for true', () => {
            process.env.LOG_ENABLED = 'true';
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            const loggerImport = require('../../../utils/logger.js');
            logger = loggerImport.default;

            const loggerTransports = logger.transports.map(transport => transport.constructor.name);
            expect(loggerTransports).toEqual(expect.arrayContaining(['Console', 'MockDailyRotateFile']));
        });

        it('deve usar o valor padrão de logEnabled quando LOG_ENABLED não está definida', () => {
            delete process.env.LOG_ENABLED;
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            const loggerImport = require('../../../utils/logger.js');
            logger = loggerImport.default;

            const logEnabled = logger.transports.length > 0;
            expect(logEnabled).toBe(true); // O valor padrão é 'true'
        });
    });

    describe('Configuração do Tamanho Máximo de Log', () => {
        it('deve usar o valor padrão de logMaxSizeGB quando LOG_MAX_SIZE_GB não está definida', () => {
            delete process.env.LOG_MAX_SIZE_GB;
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            process.env.LOG_ENABLED = 'true';
            const loggerImport = require('../../../utils/logger.js');
            logIntervalId = loggerImport.logIntervalId;
            maxLogSize = loggerImport.maxLogSize;
            logger = loggerImport.default;

            expect(maxLogSize).toBe(50 * 1024 * 1024 * 1024); // 50 GB em bytes
        });

        it('deve usar o valor definido de logMaxSizeGB quando LOG_MAX_SIZE_GB está definida', () => {
            process.env.LOG_MAX_SIZE_GB = '10';
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            process.env.LOG_ENABLED = 'true';
            const loggerImport = require('../../../utils/logger.js');
            logIntervalId = loggerImport.logIntervalId;
            maxLogSize = loggerImport.maxLogSize;
            logger = loggerImport.default;

            expect(maxLogSize).toBe(10 * 1024 * 1024 * 1024); // 10 GB em bytes
        });

        it('deve lançar erro quando LOG_MAX_SIZE_GB é inválida', () => {
            process.env.LOG_MAX_SIZE_GB = 'invalid';
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            process.env.LOG_ENABLED = 'true';

            expect(() => {
                require('../../../utils/logger.js');
            }).toThrow('LOG_MAX_SIZE_GB deve ser um número positivo');
        });

        it('deve lançar erro quando LOG_MAX_SIZE_GB é negativa', () => {
            process.env.LOG_MAX_SIZE_GB = '-5';
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            process.env.LOG_ENABLED = 'true';

            expect(() => {
                require('../../../utils/logger.js');
            }).toThrow('LOG_MAX_SIZE_GB deve ser um número positivo');
        });
    });

    describe('Configuração do Nível de Log', () => {
        beforeEach(() => {
            delete process.env.LOG_LEVEL;
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            process.env.LOG_ENABLED = 'true';
        });

        it('deve usar o nível de log padrão quando LOG_LEVEL não está definido', () => {
            const loggerImport = require('../../../utils/logger.js');
            logger = loggerImport.default;

            expect(logger.level).toBe('info');
        });

        it('deve usar o nível de log definido em LOG_LEVEL', () => {
            process.env.LOG_LEVEL = 'debug';
            const loggerImport = require('../../../utils/logger.js');
            logger = loggerImport.default;

            expect(logger.level).toBe('debug');
        });
    });

    describe('Limpeza do Intervalo de Logs', () => {
        it('não deve chamar clearInterval se logIntervalId não estiver definido', () => {
            process.env.LOG_ENABLED = 'false';
            jest.resetModules();
            process.env.NODE_ENV = 'test'; // Garantir que handlers não sejam registrados
            const loggerImport = require('../../../utils/logger.js');
            logIntervalId = loggerImport.logIntervalId;

            expect(logIntervalId).toBeUndefined();

            jest.spyOn(global, 'clearInterval');

            if (logIntervalId) {
                clearInterval(logIntervalId);
            } else {
                expect(clearInterval).not.toHaveBeenCalled();
            }
        });

        it('deve limpar o intervalo de logs quando o logger está habilitado em ambiente não-test', () => {
            process.env.LOG_ENABLED = 'true';
            process.env.NODE_ENV = 'production'; // Garantir que o intervalo seja criado
            jest.resetModules();
            const loggerImport = require('../../../utils/logger.js');
            logIntervalId = loggerImport.logIntervalId;

            expect(logIntervalId).toBeDefined();

            jest.spyOn(global, 'clearInterval');

            if (logIntervalId) {
                clearInterval(logIntervalId);
            }

            expect(clearInterval).toHaveBeenCalledWith(logIntervalId);
        });
    });

    describe('Handlers de Exceções', () => {
        let errorSpy;
        let exitSpy;
        let uncaughtExceptionHandler;
        let unhandledRejectionHandler;

        beforeEach(() => {
            // Configurar o ambiente para permitir handlers de exceções
            process.env.LOG_ENABLED = 'true';
            process.env.NODE_ENV = 'production';

            // Mockar process.on para capturar as funções handlers
            const handlers = {};
            jest.spyOn(process, 'on').mockImplementation((event, handler) => {
                handlers[event] = handler;
            });

            // Reimportar o módulo após ajustar o ambiente e mockar process.on
            jest.resetModules();
            const loggerImport = require('../../../utils/logger.js');
            getTotalLogSize = loggerImport.getTotalLogSize;
            ensureLogSizeLimit = loggerImport.ensureLogSizeLimit;
            logIntervalId = loggerImport.logIntervalId;
            maxLogSize = loggerImport.maxLogSize;
            logger = loggerImport.default;

            // Recuperar os handlers capturados
            uncaughtExceptionHandler = handlers['uncaughtException'];
            unhandledRejectionHandler = handlers['unhandledRejection'];

            // Espionar logger.error e process.exit
            errorSpy = jest.spyOn(logger, 'error').mockImplementation(() => { });
            exitSpy = jest.spyOn(process, 'exit').mockImplementation(() => { });
        });

        afterEach(() => {
            errorSpy.mockRestore();
            exitSpy.mockRestore();
            delete global.loggerListenersSet;
        });

        it('deve logar e encerrar o processo em caso de uncaughtException', () => {
            const testError = new Error('Teste de uncaughtException');

            // Garantir que o handler está definido
            expect(uncaughtExceptionHandler).toBeDefined();

            // Chamar o handler
            uncaughtExceptionHandler(testError);

            expect(errorSpy).toHaveBeenCalledWith('Uncaught Exception:', testError);
            expect(exitSpy).toHaveBeenCalledWith(1);
        });

        it('deve logar em caso de unhandledRejection', () => {
            const reason = 'Razão da rejeição';
            const promise = Promise.reject(reason);

            // Captura a rejeição para evitar warnings
            promise.catch(() => { });

            // Garantir que o handler está definido
            expect(unhandledRejectionHandler).toBeDefined();

            // Chamar o handler
            unhandledRejectionHandler(reason, promise);

            expect(errorSpy).toHaveBeenCalledWith('Unhandled Rejection at:', promise, 'reason:', reason);
        });
    });
});

===== ./tests/unit/utils/validators/schemas/zod/PermissaoValidation.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/utils/validators/schemas/zod/PermissaoValidation.test.js

import { PermissaoSchema, PermissoesArraySchema } from '../../../../../../utils/validators/schemas/zod/PermissaoValidation.js';
import { ZodError } from 'zod';

describe('PermissaoSchema', () => {
    it('deve validar um objeto de permissão válido', () => {
        const validPermission = {
            rota: 'someRoute',
            dominio: 'someDomain',
            ativo: true,
            buscar: true,
            enviar: false,
            substituir: true,
            modificar: false,
            excluir: true,
        };
        expect(() => PermissaoSchema.parse(validPermission)).not.toThrow();
    });

    it('deve validar um objeto de permissão sem domínio', () => {
        const validPermission = {
            rota: 'someRoute',
            // dominio é opcional agora
            ativo: true,
            buscar: true,
            enviar: false,
            substituir: true,
            modificar: false,
            excluir: true,
        };
        expect(() => PermissaoSchema.parse(validPermission)).not.toThrow();
    });

    it('deve invalidar um objeto de permissão inválido', () => {
        const invalidPermission = {
            rota: 'someRoute',
            dominio: 'someDomain',
            ativo: 'true', // deveria ser booleano
        };
        expect(() => PermissaoSchema.parse(invalidPermission)).toThrow(ZodError);
    });

    it('deve invalidar um objeto de permissão sem rota', () => {
        const invalidPermission = {
            dominio: 'someDomain',
            ativo: true,
            buscar: true,
        };
        expect(() => PermissaoSchema.parse(invalidPermission)).toThrow(ZodError);
    });
});

describe('PermissoesArraySchema', () => {
    it('deve validar um array de permissões únicas', () => {
        const validPermissionsArray = [
            { rota: 'route1', dominio: 'domain1', ativo: true },
            { rota: 'route2', dominio: 'domain2', buscar: true },
        ];
        expect(() => PermissoesArraySchema.parse(validPermissionsArray)).not.toThrow();
    });

    it('deve invalidar um array com permissões duplicadas', () => {
        const invalidPermissionsArray = [
            { rota: 'route1', dominio: 'domain1', ativo: true },
            { rota: 'route1', dominio: 'domain1', buscar: true },
        ];
        expect(() => PermissoesArraySchema.parse(invalidPermissionsArray)).toThrow('Permissões duplicadas: rota + domínio devem ser únicos dentro do array.');
    });

    it('deve validar um array com domínios diferentes para a mesma rota', () => {
        const validPermissionsArray = [
            { rota: 'route1', dominio: 'domain1', ativo: true },
            { rota: 'route1', dominio: 'domain2', buscar: true },
        ];
        expect(() => PermissoesArraySchema.parse(validPermissionsArray)).not.toThrow();
    });

    it('deve validar um array com domínio indefinido', () => {
        const validPermissionsArray = [
            { rota: 'route1', ativo: true },
            { rota: 'route2', buscar: true },
        ];
        expect(() => PermissoesArraySchema.parse(validPermissionsArray)).not.toThrow();
    });

    it('deve invalidar um array com domínios indefinidos duplicados', () => {
        const invalidPermissionsArray = [
            { rota: 'route1', ativo: true },
            { rota: 'route1', buscar: true },
        ];
        expect(() => PermissoesArraySchema.parse(invalidPermissionsArray)).toThrow('Permissões duplicadas: rota + domínio devem ser únicos dentro do array.');
    });

    // **Testes Adicionais para Cobertura Completa**

    it('deve invalidar um array com uma permissão sem rota', () => {
        const invalidPermissionsArray = [
            { dominio: 'domain1', ativo: true },
            { rota: 'route2', dominio: 'domain2', buscar: true },
        ];
        expect(() => PermissoesArraySchema.parse(invalidPermissionsArray)).toThrow(ZodError);
    });

    it('deve invalidar um array com uma permissão sem rota e domínio', () => {
        const invalidPermissionsArray = [
            { ativo: true },
            { rota: 'route2', dominio: 'domain2', buscar: true },
        ];
        expect(() => PermissoesArraySchema.parse(invalidPermissionsArray)).toThrow(ZodError);
    });

    it('deve invalidar um array com tipos incorretos', () => {
        const invalidPermissionsArray = [
            { rota: 'route1', dominio: 'domain1', ativo: 'yes' }, // ativo deveria ser booleano
            { rota: 'route2', dominio: 'domain2', buscar: 'true' }, // buscar deveria ser booleano
        ];
        expect(() => PermissoesArraySchema.parse(invalidPermissionsArray)).toThrow(ZodError);
    });

    it('deve validar um array vazio', () => {
        const validPermissionsArray = [];
        expect(() => PermissoesArraySchema.parse(validPermissionsArray)).not.toThrow();
    });
});

===== ./tests/unit/utils/validators/schemas/zod/querys/GrupoQuerySchema.test.js =====


===== # =====


===== separador =====


===== legível =====

// src/tests/unit/utils/validators/schemas/zod/querys/GrupoQuerySchema.test.js
import { strict as assert } from 'assert';
import { GrupoIdSchema, GrupoQuerySchema } from '../../../../../../../utils/validators/schemas/zod/querys/GrupoQuerySchema.js';
import mongoose from 'mongoose';

describe('Validações de Schemas Zod', () => {

    describe('GrupoIdSchema', () => {
        it('deve validar um ObjectId correto', () => {
            const validId = new mongoose.Types.ObjectId().toString();
            assert.doesNotThrow(() => GrupoIdSchema.parse(validId));
        });

        it('deve invalidar um ObjectId incorreto', () => {
            const invalidId = '12345';
            assert.throws(
                () => GrupoIdSchema.parse(invalidId),
                /ID inválido/
            );
        });
    });

    describe('GrupoQuerySchema', () => {
        // Definição de um objeto de query válido base para reutilização
        const baseValidQuery = {
            nome: 'Grupo 1',
            descricao: 'Descrição do grupo',
            ativo: 'true',
            unidade: 'Unidade 1',
            page: '2',
            limite: '20'
        };

        it('deve validar um objeto de query correto', () => {
            assert.doesNotThrow(() => GrupoQuerySchema.parse(baseValidQuery));
        });

        it('deve invalidar um valor incorreto para ativo', () => {
            const invalidQuery = { ...baseValidQuery, ativo: 'yes' };
            assert.throws(
                () => GrupoQuerySchema.parse(invalidQuery),
                /Ativo deve ser 'true' ou 'false'/
            );
        });

        it('deve invalidar um page não inteiro', () => {
            const invalidQuery = { ...baseValidQuery, page: 'abc' };
            assert.throws(
                () => GrupoQuerySchema.parse(invalidQuery),
                /Page deve ser um número inteiro maior que 0/
            );
        });

        it('deve invalidar um page menor que 1', () => {
            const invalidQuery = { ...baseValidQuery, page: '0' };
            assert.throws(
                () => GrupoQuerySchema.parse(invalidQuery),
                /Page deve ser um número inteiro maior que 0/
            );
        });

        it('deve invalidar um limite não inteiro', () => {
            const invalidQuery = { ...baseValidQuery, limite: 'abc' };
            assert.throws(
                () => GrupoQuerySchema.parse(invalidQuery),
                /Limite deve ser um número inteiro entre 1 e 100/
            );
        });

        it('deve invalidar um limite menor que 1', () => {
            const invalidQuery = { ...baseValidQuery, limite: '0' };
            assert.throws(
                () => GrupoQuerySchema.parse(invalidQuery),
                /Limite deve ser um número inteiro entre 1 e 100/
            );
        });

        it('deve invalidar um limite maior que 100', () => {
            const invalidQuery = { ...baseValidQuery, limite: '101' };
            assert.throws(
                () => GrupoQuerySchema.parse(invalidQuery),
                /Limite deve ser um número inteiro entre 1 e 100/
            );
        });

        it('deve validar um objeto de query com campos opcionais ausentes', () => {
            const validQuery = {};
            assert.doesNotThrow(() => GrupoQuerySchema.parse(validQuery));
        });

        it('deve validar um objeto de query com campos opcionais presentes', () => {
            const validQuery = {
                nome: 'Grupo 1',
                descricao: 'Descrição do grupo',
                ativo: 'false',
                unidade: 'Unidade 1'
                // 'page' e 'limite' estão ausentes, o que é válido se são opcionais
            };
            assert.doesNotThrow(() => GrupoQuerySchema.parse(validQuery));
        });
    });
});

===== ./tests/unit/utils/validators/schemas/zod/querys/RotaQuerySchema.test.js =====


===== # =====


===== separador =====


===== legível =====

import { RotaIdSchema, RotaQuerySchema } from "../../../../../../../utils/validators/schemas/zod/querys/RotaQuerySchema.js";
import mongoose from "mongoose";

describe("RotaIdSchema", () => {
    it("should validate a valid ObjectId", () => {
        const validId = new mongoose.Types.ObjectId().toString();
        expect(() => RotaIdSchema.parse(validId)).not.toThrow();
    });

    it("should throw error for an invalid ObjectId", () => {
        const invalidId = "invalid-id";
        expect(() => RotaIdSchema.parse(invalidId)).toThrow("ID inválido");
    });
});

describe("RotaQuerySchema", () => {
    it("should transform and validate a complete valid query", () => {
        const input = {
            rota: "  minha-rota  ",
            dominio: "meudominio.com",
            ativo: "true",
            page: "3",
            limite: "25",
        };

        const result = RotaQuerySchema.parse(input);
        expect(result.rota).toBe("minha-rota");
        expect(result.dominio).toBe("meudominio.com");
        expect(result.ativo).toBe("true");
        expect(result.page).toBe(3);
        expect(result.limite).toBe(25);
    });

    it("should apply default values for page and limite if not provided", () => {
        const input = {
            rota: "rotaExemplo",
            dominio: "dominioExemplo.com",
            ativo: "false",
        };

        const result = RotaQuerySchema.parse(input);
        expect(result.page).toBe(1);
        expect(result.limite).toBe(10);
    });

    it("should fail if 'rota' is an empty string after trim", () => {
        const input = {
            rota: "   ",
            dominio: "dominio.com",
        };

        expect(() => RotaQuerySchema.parse(input)).toThrow("Rota não pode ser vazia");
    });

    it("should fail if 'dominio' is an empty string after trim", () => {
        const input = {
            rota: "rotaValida",
            dominio: "    ",
        };

        expect(() => RotaQuerySchema.parse(input)).toThrow("Domínio não pode ser vazio");
    });

    it("should fail if 'ativo' has a value other than 'true' or 'false'", () => {
        const input = {
            rota: "rotaValida",
            dominio: "dominio.com",
            ativo: "maybe",
        };

        expect(() => RotaQuerySchema.parse(input)).toThrow("Ativo deve ser 'true' ou 'false'");
    });

    it("should fail if 'page' is not a positive integer", () => {
        const input = {
            rota: "rotaValida",
            dominio: "dominio.com",
            page: "0",
        };

        expect(() => RotaQuerySchema.parse(input)).toThrow("Page deve ser um número inteiro maior que 0");
    });

    it("should fail if 'limite' is not between 1 and 100", () => {
        const input = {
            rota: "rotaValida",
            dominio: "dominio.com",
            limite: "150",
        };

        expect(() => RotaQuerySchema.parse(input)).toThrow("Limite deve ser um número inteiro entre 1 e 100");
    });
});
===== ./tests/unit/utils/validators/schemas/zod/querys/UnidadeQuerySchema.test.js =====


===== # =====


===== separador =====


===== legível =====

import mongoose from 'mongoose';
import { UnidadeIdSchema, UnidadeQuerySchema } from '../../../../../../../utils/validators/schemas/zod/querys/UnidadeQuerySchema.js';

describe("UnidadeIdSchema", () => {
    it("should validate a valid ObjectId", () => {
        const validId = new mongoose.Types.ObjectId().toString();
        const result = UnidadeIdSchema.safeParse(validId);
        expect(result.success).toBe(true);
    });

    it("should fail with an invalid ObjectId", () => {
        const invalidId = "12345";
        const result = UnidadeIdSchema.safeParse(invalidId);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.errors[0].message).toBe("ID inválido");
        }
    });
});

describe("UnidadeQuerySchema", () => {
    it("should apply default values for page and limite when not provided", () => {
        const input = {};
        const result = UnidadeQuerySchema.safeParse(input);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data.page).toBe(1);
            expect(result.data.limite).toBe(10);
        }
    });

    it("should trim the 'nome' and 'locallidade' fields", () => {
        const input = {
            nome: "  Teste Nome  ",
            locallidade: "  Teste Localidade  ",
        };
        const result = UnidadeQuerySchema.safeParse(input);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data.nome).toBe("Teste Nome");
            expect(result.data.locallidade).toBe("Teste Localidade");
        }
    });

    it("should accept valid 'ativo' values", () => {
        const validInputs = [
            { ativo: "true" },
            { ativo: "false" },
            {} // when not provided
        ];
        validInputs.forEach(input => {
            const result = UnidadeQuerySchema.safeParse(input);
            expect(result.success).toBe(true);
        });
    });

    it("should fail if 'ativo' is not 'true' or 'false'", () => {
        const input = { ativo: "yes" };
        const result = UnidadeQuerySchema.safeParse(input);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.errors[0].message).toBe("Ativo deve ser 'true' ou 'false'");
        }
    });

    it("should convert 'page' and 'limite' from string to number", () => {
        const input = { page: "3", limite: "25" };
        const result = UnidadeQuerySchema.safeParse(input);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data.page).toBe(3);
            expect(result.data.limite).toBe(25);
        }
    });

    it("should fail if 'page' is not a positive integer", () => {
        const input = { page: "0" };
        const result = UnidadeQuerySchema.safeParse(input);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.errors[0].message).toBe("Page deve ser um número inteiro maior que 0");
        }
    });

    it("should fail if 'limite' is not between 1 and 100", () => {
        const invalidInputs = [
            { limite: "0" },
            { limite: "101" }
        ];
        invalidInputs.forEach(input => {
            const result = UnidadeQuerySchema.safeParse(input);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.errors[0].message).toBe("Limite deve ser um número inteiro entre 1 e 100");
            }
        });
    });

    it("should fail if 'nome' is provided as an empty string (after trim)", () => {
        const input = { nome: "   " };
        const result = UnidadeQuerySchema.safeParse(input);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.errors[0].message).toBe("Nome não pode ser vazio");
        }
    });

    it("should fail if 'locallidade' is provided as an empty string (after trim)", () => {
        const input = { locallidade: "   " };
        const result = UnidadeQuerySchema.safeParse(input);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.errors[0].message).toBe("Localidade não pode ser vazio");
        }
    });
});
===== ./tests/unit/utils/validators/schemas/zod/querys/UsuarioQuerySchema.test.js =====


===== # =====


===== separador =====


===== legível =====

import { UsuarioIdSchema, UsuarioQuerySchema } from '../../../../../../../utils/validators/schemas/zod/querys/UsuarioQuerySchema';
import mongoose from 'mongoose';

describe('UsuarioIdSchema', () => {
    it('should validate a correct ObjectId', () => {
        const validId = new mongoose.Types.ObjectId().toString();
        expect(() => UsuarioIdSchema.parse(validId)).not.toThrow();
    });

    it('should invalidate an incorrect ObjectId', () => {
        const invalidId = '12345';
        expect(() => UsuarioIdSchema.parse(invalidId)).toThrow("ID inválido");
    });
});

describe('UsuarioQuerySchema', () => {
    // Objeto base válido para evitar duplicação
    const baseValidQuery = {
        nome: 'John Doe',
        email: 'john.doe@example.com',
        ativo: 'true',
        grupo: 'admin',
        unidade: 'unit1',
        page: '2',
        limite: '20'
    };

    it('should validate a correct query object', () => {
        expect(() => UsuarioQuerySchema.parse(baseValidQuery)).not.toThrow();
    });

    it('should invalidate an empty nome', () => {
        const query = { ...baseValidQuery, nome: '' };
        expect(() => UsuarioQuerySchema.parse(query)).toThrow("Nome não pode ser vazio");
    });

    it('should invalidate an incorrect email format', () => {
        const query = { ...baseValidQuery, email: 'invalid-email' };
        expect(() => UsuarioQuerySchema.parse(query)).toThrow("Formato de email inválido");
    });

    it('should invalidate an incorrect ativo value', () => {
        const query = { ...baseValidQuery, ativo: 'yes' };
        expect(() => UsuarioQuerySchema.parse(query)).toThrow("Ativo deve ser 'true' ou 'false'");
    });

    it('should invalidate a non-integer page value', () => {
        const query = { ...baseValidQuery, page: 'abc' };
        expect(() => UsuarioQuerySchema.parse(query)).toThrow("Page deve ser um número inteiro maior que 0");
    });

    it('should invalidate a page value less than 1', () => {
        const query = { ...baseValidQuery, page: '0' };
        expect(() => UsuarioQuerySchema.parse(query)).toThrow("Page deve ser um número inteiro maior que 0");
    });

    it('should invalidate a limite value greater than 100', () => {
        const query = { ...baseValidQuery, limite: '101' };
        expect(() => UsuarioQuerySchema.parse(query)).toThrow("Limite deve ser um número inteiro entre 1 e 100");
    });

    it('should invalidate a limite value less than 1', () => {
        const query = { ...baseValidQuery, limite: '0' };
        expect(() => UsuarioQuerySchema.parse(query)).toThrow("Limite deve ser um número inteiro entre 1 e 100");
    });
});

===== ./tests/unit/utils/validators/schemas/zod/UnidadeSchema.test.js =====


===== # =====


===== separador =====


===== legível =====

import { UnidadeSchema, UnidadeUpdateSchema } from '../../../../../../utils/validators/schemas/zod/UnidadeSchema.js';

describe('UnidadeSchema', () => {
    it('parses valid data correctly', () => {
        const validData = { nome: 'Unidade 1', localidade: 'Localidade 1', ativo: false };
        const result = UnidadeSchema.parse(validData);
        expect(result).toEqual(validData);
    });

    it('applies default value for "ativo" when not provided', () => {
        const validData = { nome: 'Unidade 1', localidade: 'Localidade 1' };
        const result = UnidadeSchema.parse(validData);
        expect(result.ativo).toBe(true);
    });

    it('throws an error when "nome" is missing', () => {
        const invalidData = { localidade: 'Localidade 1', ativo: true };
        expect(() => UnidadeSchema.parse(invalidData)).toThrowError(/O campo nome é obrigatório/);
    });

    it('throws an error when "localidade" is missing', () => {
        const invalidData = { nome: 'Unidade 1', ativo: true };
        expect(() => UnidadeSchema.parse(invalidData)).toThrowError(/O campo localidade é obrigatório/);
    });

    it('throws an error when "nome" is an empty string', () => {
        const invalidData = { nome: '', localidade: 'Localidade 1', ativo: true };
        expect(() => UnidadeSchema.parse(invalidData)).toThrowError(/Este campo é obrigatório/);
    });

    it('throws an error when "localidade" is an empty string', () => {
        const invalidData = { nome: 'Unidade 1', localidade: '', ativo: true };
        expect(() => UnidadeSchema.parse(invalidData)).toThrowError(/Este campo é obrigatório/);
    });
});

describe('UnidadeUpdateSchema', () => {
    it('parses partial data correctly', () => {
        const partialData = { nome: 'Unidade Atualizada' };
        const result = UnidadeUpdateSchema.parse(partialData);
        expect(result.nome).toBe('Unidade Atualizada');
        // When not provided, "localidade" is undefined and "ativo" should default to true
        expect(result.localidade).toBeUndefined();
        expect(result.ativo).toBe(true);
    });

    it('applies defaults when no data is provided', () => {
        const result = UnidadeUpdateSchema.parse({});
        // Nome and localidade remain undefined because they are partial,
        // but "ativo" should default to true from the base schema.
        expect(result.nome).toBeUndefined();
        expect(result.localidade).toBeUndefined();
        expect(result.ativo).toBe(true);
    });
});
===== ./utils/AuthHelper.js =====


===== # =====


===== separador =====


===== legível =====

import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';

class AuthHelper {
    static generateToken(userId) {
        return jwt.sign({ id: userId }, process.env.JWT_SECRET, { expiresIn: '1h' });
    }

    static decodeToken(token) {
        try {
            return jwt.decode(token);
        } catch (error) {
            return null;
        }
    }

    static async hashPassword(password) {
        return await bcrypt.hash(password, 10);
    }
}

export default AuthHelper;

===== ./utils/DateHelper.js =====


===== # =====


===== separador =====


===== legível =====

class DateHelper {
    static formatDate(date) {
        return new Date(date).toLocaleDateString('en-US');
    }
}

export default DateHelper;

===== ./utils/errors/AuthenticationError.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/errors/AuthenticationError.js
class AuthenticationError extends Error {
    constructor(message) {
      super(message);
      this.name = 'AuthenticationError';
      this.statusCode = 498;
      this.isOperational = true;
    }
  }
  
  export default AuthenticationError;
  
===== ./utils/errors/TokenExpiredError.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/errors/TokenExpiredError.js
class TokenExpiredError extends Error {
  constructor(message) {
    super(message);
    this.name = 'TokenExpiredError';
    this.statusCode = 498;
    this.isOperational = true;
  }
}

export default TokenExpiredError;

===== ./utils/errors/TokenInvalidError.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/errors/TokenInvalidError.js
import CustomError from '../helpers/CustomError.js';
import messages from '../helpers/messages.js';

class TokenInvalidError extends CustomError {
  constructor(message) {
    super({
      statusCode: 401,
      errorType: 'invalidToken',
      field: 'Token',
      details: [],
      customMessage: messages.error.resourceNotFound('Token')
    });
  }
}

export default TokenInvalidError;

===== ./utils/getFirstLine.js =====


===== # =====


===== separador =====


===== legível =====

import fs from "fs";
import readline from "readline";

/**
 * 
 * Pega a primeira linha de texto de um arquivo. 
 * Código pego {@link https://stackoverflow.com/questions/28747719/what-is-the-most-efficient-way-to-read-only-the-first-line-of-a-file-in-node-js#answer-60193465 daqui}.
 */
export default async function getFirstLine(pathToFile) {
  const readable = fs.createReadStream(pathToFile);
  const reader = readline.createInterface({ input: readable });
  const line = await new Promise((resolve) => {
    reader.on('line', (line) => {
      reader.close();
      resolve(line);
    });
  });
  readable.close();
  return line;
}
===== ./utils/handleQuery.js =====


===== # =====


===== separador =====


===== legível =====

import { endOfDay, startOfDay, addDays } from "date-fns";

/**
 * @func handleQuery
 * Função para tratar a query, criando os filtros, ordenação e pagina
 * Valor padrão da pagina é 1 quando não informada na query
 * @param {object} query
 * @param {object} defaultSort - Ordenação padrão caso o usuario não informe na query
 * @returns {object} a query tratada com os filtros, ordenação e pagina
 */
export default function (query, defaultSort) {
  const filtros = {};
  let pagina = 1;
  let ordenar = defaultSort;

  for(const [key, value] of Object.entries(query)) {
    if(key === "pagina") {
      pagina = parseInt(value);
      continue;
    }
    if(key === "ordenar") {
      const sort = value.split("-");
      ordenar = { [sort[0]]: sort[1] };
      continue;
    }
    //Campo do usuario
    if(key === "ativo") {
      filtros[key] = value === "1";
      continue;
    }
    //Campo do usuario e do projeto
    if (key === "turnos") {
      const turnos = value.split(",");
      for (const turno of turnos) {
        filtros[`turnos.${turno}`] = true;
      }
      continue;
    }
    // Campo do projeto
    if (key === "estudantes") {
      const estudantes = value.split(",");
      filtros[key] = { $elemMatch: { $in: estudantes } };
      continue;
    }

    // Depois verificar se essa é uma boa maneira de filtrar datas ou é melhor nem ter.
    // Inicio e termino é campo do projeto e do estagio, e o liberado e do refeicaoTurma
    if (key === "data_inicio" || key === "data_termino" || key === "data_liberado") {
      const datas = value.split(",");
      filtros[key] = {
        // Depois vê se é possível refatorar isso e deixar melhor, mexer com datas é uma #####
        $gte: startOfDay(addDays(datas[0], 1)),
        $lte: endOfDay(addDays(datas[1], 1)),
      };
      continue;
    }

    // // Campos do refeicao
    // if(key === "dataInicio" || key === "dataTermino"){
    //   const data = value;
    //   filtros[key] = {
    //     $gte: startOfDay(addDays(data, 1)),
    //     $lte: endOfDay(addDays(data, 1)),
    //   }
    //   continue;
    // }

    //Campo do estudante e da turma
    if (key === "turma" || key === "curso") {
      filtros[key] = value;
      continue;
    }
    //O resto é tratado com filtro
    if(value) {
      filtros[key] = { $regex: new RegExp(value, "i") };
    }
  }

  return { filtros, pagina, ordenar };
}

===== ./utils/helpers/CommonResponse.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/helpers/CommonResponse.js

import StatusService from './StatusService.js';

class CommonResponse {
    constructor(message, data = null, errors = []) {
        this.message = message;
        this.data = data;
        this.errors = errors;
    }

    toJSON() {
        return {
            message: this.message,
            data: this.data,
            errors: this.errors
        };
    }

    static success(res, data, code = 200, message = null) {
        const statusMessage = message || StatusService.getHttpCodeMessage(code);
        const response = new CommonResponse(statusMessage, data, []);
        return res.status(code).json(response);
    }

    static error(res, code, errorType, field = null, errors = [], customMessage = null) {
        const errorMessage = customMessage || StatusService.getErrorMessage(errorType, field);
        const response = new CommonResponse(errorMessage, null, errors);
        return res.status(code).json(response);
    }

    static created(res, data, message = null) {
        return this.success(res, data, 201, message);
    }

    static serverError(res, message = null) {
        const errorMessage = message || StatusService.getErrorMessage('serverError');
        const response = new CommonResponse(errorMessage, null, []);
        return res.status(500).json(response);
    }

    /**
     * Retorna o schema para o Swagger baseado na estrutura do CommonResponse.
     *
     * @param {string|null} schemaRef - Referência para o schema do "data", se houver.
     * @param {string} messageExample - Exemplo de mensagem para o Swagger.
     * @returns {object} Schema JSON da resposta.
     */
    static getSwaggerSchema(schemaRef = null, messageExample = "Operação realizada com sucesso") {
        return {
            type: "object",
            properties: {
                data: schemaRef
                    ? { $ref: schemaRef }
                    : { type: "array", items: {}, example: [] },
                message: { type: "string", example: messageExample },
                errors: { type: "array", example: [] }
            }
        };
    }
}

export default CommonResponse;

===== ./utils/helpers/CustomError.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/helpers/CustomError.js

/**
 * Classe CustomError para manipulação de erros customizados.
 * Permite definir propriedades adicionais que auxiliam no tratamento
 * de erros específicos, como por exemplo o erro de token expirado.
 *
 * @param {string} message - Mensagem principal do erro.
 * @param {Object} options - Parâmetros adicionais do erro.
 * @param {number} options.statusCode - Código de status HTTP.
 * @param {string} options.errorType - Tipo do erro para mapeamento (ex: 'tokenExpired').
 * @param {string|null} [options.field=null] - Campo relacionado ao erro, se aplicável.
 * @param {array} [options.details=[]] - Detalhes adicionais sobre o erro.
 * @param {string|null} [options.customMessage=null] - Mensagem de erro personalizada.
 *
 * @example
 * new CustomError('Session expired', {
 *   statusCode: 401,
 *   errorType: 'tokenExpired',
 *   customMessage: 'Seu token expirou. Faça login novamente.'
 * });
 */
class CustomError extends Error {
    constructor({ statusCode, errorType, field = null, details = [], customMessage = null } = {}) {
      // Usa a mensagem passada ou, se ausente, usa a customMessage ou uma mensagem padrão
      super(customMessage || 'An error occurred');
      this.name = 'CustomError';
      this.statusCode = statusCode;
      this.errorType = errorType;
      this.field = field;
      this.details = details;
      this.customMessage = customMessage;
      // Marca o erro como operacional para diferenciá-lo de erros internos inesperados
      this.isOperational = true;
      Error.captureStackTrace(this, this.constructor);
    }
  }
  
  export default CustomError;
  
===== ./utils/helpers/errorHandler.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/helpers/errorHandler.js

import { ZodError } from 'zod';
import logger from '../logger.js';
import CommonResponse from './CommonResponse.js';
import StatusService from './StatusService.js';
import { v4 as uuidv4 } from 'uuid';
import mongoose from 'mongoose';
import AuthenticationError from '../errors/AuthenticationError.js';
import TokenExpiredError from '../errors/TokenExpiredError.js';
import CustomError from './CustomError.js';

/**
 * Middleware para tratamento centralizado de erros.
 * Identifica o tipo de erro e envia uma resposta padronizada ao cliente.
 *
 * @param {Error} err - Erro lançado durante a execução.
 * @param {object} req - Objeto de requisição do Express.
 * @param {object} res - Objeto de resposta do Express.
 * @param {function} next - Função para repassar o controle para o próximo middleware.
 */
const errorHandler = (err, req, res, next) => {
  // Verifica se o ambiente é de produção para ajustar a mensagem de erro
  const isProduction = process.env.NODE_ENV === 'production';
  // Gera um ID único para identificar o erro (útil para logs)
  const errorId = uuidv4();
  const requestId = req.requestId || 'N/A';

  // Tratamento para erros de validação do Zod
  if (err instanceof ZodError) {
    logger.warn('Erro de validação', { errors: err.errors, path: req.path, requestId });
    return CommonResponse.error(
      res,
      400,
      'validationError',
      null,
      err.errors.map(e => ({ path: e.path.join('.'), message: e.message })),
      `Erro de validação. ${err.errors.length} campo(s) inválido(s).`
    );
  }

  // Tratamento para erro de chave duplicada no MongoDB (código 11000)
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue || {})[0];
    const value = err.keyValue ? err.keyValue[field] : 'duplicado';
    logger.warn('Erro de chave duplicada', { field, value, path: req.path, requestId });
    return CommonResponse.error(
      res,
      409,
      'duplicateEntry',
      field,
      [{ path: field, message: `O valor "${value}" já está em uso.` }],
      `Entrada duplicada no campo "${field}".`
    );
  }

  // Tratamento para erros de validação do Mongoose
  if (err instanceof mongoose.Error.ValidationError) {
    const detalhes = Object.values(err.errors).map(e => ({ path: e.path, message: e.message }));
    logger.warn('Erro de validação do Mongoose', { details: detalhes, path: req.path, requestId });
    return CommonResponse.error(res, 400, 'validationError', null, detalhes);
  }

  // Tratamento para erros de autenticação customizados (AuthenticationError e TokenExpiredError)
  if (err instanceof AuthenticationError || err instanceof TokenExpiredError) {
    logger.warn('Erro de autenticação', { message: err.message, path: req.path, requestId });
    return CommonResponse.error(
      res,
      err.statusCode,
      'authenticationError',
      null,
      [{ message: err.message }],
      err.message
    );
  }

  // Tratamento específico para CustomError com errorType 'tokenExpired'
  if (err instanceof CustomError && err.errorType === 'tokenExpired') {
    logger.warn('Erro de token expirado', { message: err.message, path: req.path, requestId });
    return CommonResponse.error(
      res,
      err.statusCode || 401,
      'tokenExpired',
      null,
      [{ message: err.customMessage || 'Token expirado.' }],
      err.customMessage || 'Token expirado. Por favor, faça login novamente.'
    );
  }

  // Tratamento para erros operacionais (erros esperados na aplicação)
  if (err.isOperational) {
    logger.warn('Erro operacional', { message: err.message, path: req.path, requestId });
    return CommonResponse.error(
      res,
      err.statusCode,
      err.errorType || 'operationalError',
      err.field || null,
      err.details || [],
      err.customMessage || 'Erro operacional.'
    );
  }

  // Tratamento para erros internos (não operacionais)
  logger.error(`Erro interno [ID: ${errorId}]`, { message: err.message, stack: err.stack, requestId });
  const detalhes = isProduction
    ? [{ message: `Erro interno do servidor. Referência: ${errorId}` }]
    : [{ message: err.message, stack: err.stack }];

  return CommonResponse.error(res, 500, 'serverError', null, detalhes);
};

export default errorHandler;

===== ./utils/helpers/HttpStatusCodes.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/helpers/HttpStatusCodes.js

class HttpStatusCodes {
    static OK = { code: 200, message: 'Requisição bem-sucedida' };
    static CREATED = { code: 201, message: 'Recurso criado com sucesso' };
    static ACCEPTED = { code: 202, message: 'Requisição aceita para processamento' };
    static NO_CONTENT = { code: 204, message: 'Sem conteúdo para retornar' };
    static RESET_CONTENT = { code: 205, message: 'Mais dados necessários para processamento' };
    static PARTIAL_CONTENT = { code: 206, message: 'Conteúdo parcial retornado' };
    static MULTI_STATUS = { code: 207, message: 'Múltiplos recursos associados à resposta' };
    static ALREADY_REPORTED = { code: 208, message: 'Conteúdo já relatado' };

    static MULTIPLE_CHOICES = { code: 300, message: 'Múltiplas respostas disponíveis, cliente deve escolher uma' };
    static MOVED_PERMANENTLY = { code: 301, message: 'Recurso movido permanentemente para um novo endereço' };
    static FOUND = { code: 302, message: 'Recurso encontrado, mas movido temporariamente para um novo endereço' };
    static SEE_OTHER = { code: 303, message: 'Veja outra referência para o recurso' };
    static NOT_MODIFIED = { code: 304, message: 'Cliente possui a versão mais recente do recurso' };
    static USE_PROXY = { code: 305, message: 'Recurso disponível apenas através de um proxy' };
    static TEMPORARY_REDIRECT = { code: 307, message: 'Recurso temporariamente movido para um novo endereço' };
    static PERMANENT_REDIRECT = { code: 308, message: 'Recurso movido permanentemente para um novo endereço' };

    static BAD_REQUEST = { code: 400, message: 'Requisição com sintaxe incorreta' };
    static UNAUTHORIZED = { code: 401, message: 'Não autorizado' };
    static FORBIDDEN = { code: 403, message: 'Proibido' };
    static NOT_FOUND = { code: 404, message: 'Recurso não encontrado' };
    static METHOD_NOT_ALLOWED = { code: 405, message: 'Método HTTP não permitido para o recurso solicitado' };
    static REQUEST_TIMEOUT = { code: 408, message: 'Tempo de requisição esgotado' };
    static CONFLICT = { code: 409, message: 'Conflito com o estado atual do servidor' };
    static GONE = { code: 410, message: 'Recurso não está mais disponível' };
    static PAYLOAD_TOO_LARGE = { code: 413, message: 'O corpo da requisição é muito grande' };
    static IM_A_TEAPOT = { code: 418, message: 'Eu sou um bule de chá' };
    static UNPROCESSABLE_ENTITY = { code: 422, message: 'Falha na validação' };
    static LOCKED = { code: 423, message: 'Recurso bloqueado' };
    static REQUEST_HEADER_FIELDS_TOO_LARGE = { code: 431, message: 'Cabeçalhos da requisição são muito grandes' };
    static UNAVAILABLE_FOR_LEGAL_REASONS = { code: 451, message: 'Acesso negado por motivos legais' };
    static INVALID_TOKEN = { code: 498, message: 'O token JWT está expirado!' };

    static INTERNAL_SERVER_ERROR = { code: 500, message: 'Erro interno do servidor' };
    static NOT_IMPLEMENTED = { code: 501, message: 'Funcionalidade não suportada' };
    static BAD_GATEWAY = { code: 502, message: 'Resposta inválida recebida do servidor upstream' };
    static SERVICE_UNAVAILABLE = { code: 503, message: 'Serviço temporariamente indisponível' };
}

export default HttpStatusCodes;

===== ./utils/helpers/index.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/helpers/index.js

export { default as CommonResponse } from './CommonResponse.js';
export { default as CustomError } from './CustomError.js';
export { default as HttpStatusCodes } from './HttpStatusCodes.js';
export { default as errorHandler } from './errorHandler.js';
export { default as messages } from './messages.js';
export { default as StatusService } from './StatusService.js';
export { default as asyncWrapper } from '../../middlewares/asyncWrapper.js';

// Adicione outros exports conforme necessário

/* Formas de importar
   import { CommonResponse, CustomError, HttpStatusCodes, errorHandler, messages, StatusService, asyncWrapper } from '../utils/helpers/index.js';
   import * as Helpers from '../utils/helpers/index.js';
   import { CommonResponse as CR } from '../utils/helpers/index.js';
*/

===== ./utils/helpers/messages.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/helpers/messages.js

const messages = {
    // Mensagens Informativas
    info: {
        welcome: "Bem-vindo à nossa aplicação!",
        userLoggedIn: (username) => `Usuário ${username} logado com sucesso.`,
    },

    // Mensagens de Sucesso
    success: {
        default: "Operação concluída com sucesso.",
    },

    // Mensagens de aviso de atorização
    authorized:{
        default: "autorizado",
    },

    // Mensagens de Erro
    error: {
        default: "Ocorreu um erro ao processar a solicitação.",
        serverError: "Erro interno do servidor. Tente novamente mais tarde.",
        validationError: "Erro de validação. Verifique os dados fornecidos e tente novamente.",
        invalidRequest: "Requisição inválida. Verifique os parâmetros fornecidos.",
        unauthorizedAccess: "Acesso não autorizado. Faça login para continuar.",
        invalidURL: "URL inválida. Verifique a URL fornecida.",
        unsupportedOperation: "Operação não suportada neste contexto.",
        dataParsingError: "Erro ao analisar os dados recebidos.",
        externalServiceError: "Erro ao se comunicar com um serviço externo.",
        invalidApiKey: "Chave de API inválida.",
        operationCanceled: "Operação cancelada pelo usuário.",
        internalServerError: (resource) => `Erro interno no servidor ao processar ${resource}.`,
        unauthorized: (resource) => `Erro de autorização: ${resource}.`,
        resourceConflict: (resource,  conflictField) => `Conflito de recurso em ${resource} contém ${conflictField}.`,
        pageIsNotAvailable: (page) => `A página ${page} não está disponível.`,
        pageNotContainsData: (page) => `A página ${page} não contém dados.`,
        duplicateEntry: (fieldName) => `Já existe um registro com o dado informado no(s) campo(s) ${fieldName}.`,
        resourceInUse: (fieldName) => `Recurso em uso em ${fieldName}.`,
        authenticationError: (fieldName) => `Erro de autenticação em ${fieldName}.`,
        permissionError: (fieldName) => `Erro de permissão em ${fieldName}.`,
        resourceNotFound: (fieldName) => `Recurso não encontrado em ${fieldName}.`,
    },

    // Mensagens de Validação
    validation: {
        generic: {
            fieldIsRequired: (fieldName) => `O campo ${fieldName} é obrigatório.`,
            fieldIsRepeated: (fieldName) => `O campo ${fieldName} informado já está cadastrado.`,
            invalidInputFormat: (fieldName) => `Formato de entrada inválido para o campo ${fieldName}.`,
            invalid: (fieldName) => `Valor informado em ${fieldName} é inválido.`,
            notFound: (fieldName) => `Valor informado para o campo ${fieldName} não foi encontrado.`,
            mustBeOneOf: (fieldName, values) => `O campo ${fieldName} deve ser um dos seguintes valores: ${values.join(", ")}.`,
            resourceCreated: (fieldName) => `${fieldName} criado(a) com sucesso.`,
            resourceUpdated: (fieldName) => `${fieldName} atualizado(a) com sucesso.`,
            resourceDeleted: (fieldName) => `${fieldName} excluído(a) com sucesso.`,
            resourceAlreadyExists: (fieldName) => `${fieldName} já existe.`,
        },
        reference: {
            resourceWithReference: (resource, reference) => `${resource} com referência em ${reference}. Exclusão impedida.`,
        },
        custom: {
            invalidCPF: { message: "CPF inválido. Verifique o formato e tente novamente." },
            invalidCNPJ: { message: "CNPJ inválido. Verifique o formato e tente novamente." },
            invalidCEP: { message: "CEP inválido. Verifique o formato e tente novamente." },
            invalidPhoneNumber: { message: "Número de telefone inválido. Verifique o formato e tente novamente." },
            invalidMail: { message: "Email no formato inválido." },
            invalidYear: { message: "Ano inválido. Verifique o formato e tente novamente." },
            invalidDate: { message: "Data inválida. Verifique o formato e tente novamente." },
            invalidKilometerInitial: { message: "Quilometragem inicial inválida." },
            invalidKilometer: { message: "Quilometragem inválida." },
            invalidDatePast: { message: "Data do início deve ser uma data atual ou futura." },
            invalidDateFuture: { message: "A data de conclusão deve ser maior do que a data de início!" },
            invalidDateCurrent: { message: "Data do início deve ser uma data atual ou passada." },
            invalidDateMonths: { message: "A data final da vigência não pode ser um período maior que 12 meses após a data de início da vigência." },
            invalidDataNascimento: { message: "Data de nascimento deve ser uma data passada e maior que 18 anos." },
            invalidDataAdmissao: { message: "Data de admissão deve ser uma data atual ou passada." },
            invalidYearSemester: { message: "Ano/semestre. Verifique o formato e tente novamente." },
            invalidYearStartSemester: { message: "Data do início do semestre deve ser menor que a data fim de semestre." },
        },
    },

    // Mensagens de Autenticação
    auth: {
        authenticationFailed: "Falha na autenticação. Credenciais inválidas.",
        userNotFound: (userId) => `Usuário com ID ${userId} não encontrado.`,
        invalidPermission: "Permissão insuficiente para executar a operação.",
        duplicateEntry: (fieldName) => `Já existe um registro com o mesmo ${fieldName}.`,
        accountLocked: "Conta bloqueada. Entre em contato com o suporte.",
        invalidToken: "Token inválido. Faça login novamente.",
        timeoutError: "Tempo de espera excedido. Tente novamente mais tarde.",
        databaseConnectionError: "Erro de conexão com o banco de dados. Tente novamente mais tarde.",
        emailAlreadyExists: (email) => `O endereço de email ${email} já está em uso.`,
        invalidCredentials: "Credenciais inválidas. Verifique seu usuário e senha.",
    },
};

export default messages;

===== ./utils/helpers/StatusService.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/helpers/StatusService.js

import HttpStatusCodes from './HttpStatusCodes.js';
import messages from './messages.js';

class StatusService {
    /**
     * Retorna a mensagem correspondente ao código HTTP fornecido.
     * @param {number} code - Código de status HTTP.
     * @returns {string} Mensagem correspondente.
     */
    static getHttpCodeMessage(code) {
        const status = Object.values(HttpStatusCodes).find(status => status.code === code);
        return status ? status.message : 'Status desconhecido.';
    }

    /**
     * Retorna a mensagem de erro correspondente ao tipo fornecido.
     * @param {string} type - Tipo de erro.
     * @param {string|null} field - Campo relacionado ao erro, se aplicável.
     * @returns {string} Mensagem de erro correspondente.
     */
    static getErrorMessage(type, field = null) {
        if (messages.error[type]) {
            if (typeof messages.error[type] === 'function') {
                return messages.error[type](field);
            }
            return messages.error[type];
        }
        return "Tipo de erro desconhecido.";
    }
}

export default StatusService;

===== ./utils/logger.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/logger.js

import { createLogger, format, transports } from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';

dotenv.config();

class Logger {
    constructor() {
        // Configurações iniciais
        this.logDirectory = path.resolve(process.cwd(), 'logs');

        // Refatoração da Linha 15
        if (process.env.LOG_MAX_SIZE_GB !== undefined) {
            this.logMaxSizeGB = parseFloat(process.env.LOG_MAX_SIZE_GB);
        } else {
            this.logMaxSizeGB = 50;
        }

        if (isNaN(this.logMaxSizeGB) || this.logMaxSizeGB <= 0) { // Linha 20
            console.log('Linha 20: logMaxSizeGB inválido');
            throw new Error('LOG_MAX_SIZE_GB deve ser um número positivo');
        }

        this.maxLogSize = this.logMaxSizeGB * 1024 * 1024 * 1024;

        // Refatoração da Linha 22
        if (process.env.LOG_ENABLED !== undefined) {
            this.logEnabled = process.env.LOG_ENABLED === 'true';
        } else {
            console.log('Linha 33: logEnabled padrão true');
            this.logEnabled = true; // Linha 33
        }

        // Inicializa o logger
        this.logger = this.createLoggerInstance();

        // Configura os event listeners
        this.setupExceptionHandlers();

        // Inicia o intervalo de verificação de tamanho dos logs
        this.startLogSizeInterval();
    }

    createLoggerInstance() {
        const loggerTransports = [];
        if (this.logEnabled) {
            if (!fs.existsSync(this.logDirectory)) {
                fs.mkdirSync(this.logDirectory, { recursive: true });
            }

            loggerTransports.push(
                new transports.Console({
                    format: format.combine(format.colorize(), format.simple())
                }),
                new DailyRotateFile({
                    filename: path.join(this.logDirectory, 'error-%DATE%.log'),
                    datePattern: 'YYYY-MM-DD',
                    level: 'error',
                    maxFiles: '30d',
                }),
                new DailyRotateFile({
                    filename: path.join(this.logDirectory, 'combined-%DATE%.log'),
                    datePattern: 'YYYY-MM-DD',
                    maxFiles: '30d',
                }),
            );
        }

        return createLogger({
            // Linha 60 permanece a mesma
            level: process.env.LOG_LEVEL || 'info',
            format: format.combine(
                format.timestamp(),
                format.errors({ stack: true }),
                format.splat(),
                format.json()
            ),
            defaultMeta: { service: 'usuario-service' },
            transports: loggerTransports,
        });
    }

    getTotalLogSize(directory) {
        if (!fs.existsSync(directory)) return 0;
        return fs.readdirSync(directory).reduce((totalSize, file) => {
            const filePath = path.join(directory, file);
            return totalSize + fs.statSync(filePath).size;
        }, 0);
    }

    ensureLogSizeLimit(directory, maxSizeInBytes) {
        let totalSize = this.getTotalLogSize(directory);

        if (totalSize > maxSizeInBytes) {
            const files = fs.readdirSync(directory)
                .map((file) => ({
                    file,
                    time: fs.statSync(path.join(directory, file)).mtime.getTime(),
                }))
                .sort((a, b) => a.time - b.time);

            for (const { file } of files) {
                if (totalSize <= maxSizeInBytes) break;

                const filePath = path.join(directory, file);
                const stats = fs.statSync(filePath);
                fs.unlinkSync(filePath);
                totalSize -= stats.size;
            }
        }
    }

    setupExceptionHandlers() {
        if (this.logEnabled && !global.loggerListenersSet && process.env.NODE_ENV !== 'test') {
            process.on('uncaughtException', (err) => {
                this.logger.error('Uncaught Exception:', err);
                process.exit(1);
            });

            process.on('unhandledRejection', (reason, promise) => {
                this.logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
            });

            global.loggerListenersSet = true;
        }
    }

    startLogSizeInterval() {
        if (this.logEnabled && process.env.NODE_ENV !== 'test') {
            this.logIntervalId = setInterval(() => this.ensureLogSizeLimit(this.logDirectory, this.maxLogSize), 60 * 1000);
        }
    }
}

const loggerInstance = new Logger();

export default loggerInstance.logger;
export const getTotalLogSize = loggerInstance.getTotalLogSize.bind(loggerInstance);
export const ensureLogSizeLimit = loggerInstance.ensureLogSizeLimit.bind(loggerInstance);
export const logIntervalId = loggerInstance.logIntervalId;
export const maxLogSize = loggerInstance.maxLogSize;

===== ./utils/logs/.02764ca081836497da9e259f46a6485e12440d70-audit.json =====


===== # =====


===== separador =====


===== legível =====

{
    "keep": {
        "days": true,
        "amount": 30
    },
    "auditLog": "/home/gilberto/aula/repositorios/@@repositorios_oficial-verificado/4-event-grid/user-service-nodejs/src/utils/logs/.02764ca081836497da9e259f46a6485e12440d70-audit.json",
    "files": [
        {
            "date": 1729800795008,
            "name": "/home/gilberto/aula/repositorios/@@repositorios_oficial-verificado/4-event-grid/user-service-nodejs/src/utils/logs/error-2024-10-24.log",
            "hash": "baaf43ea40651d0868b0ab35ecee2a23ec2dfc3097707c34221c342551d9d180"
        },
        {
            "date": 1729887717791,
            "name": "/home/gilberto/aula/repositorios/@@repositorios_oficial-verificado/4-event-grid/user-service-nodejs/src/utils/logs/error-2024-10-25.log",
            "hash": "12d1516591fe25822ad5bd7f479f26c427d04920828f7be8cef19f58d03151c9"
        },
        {
            "date": 1730139182869,
            "name": "/home/gilberto/aula/repositorios/@@repositorios_oficial-verificado/4-event-grid/user-service-nodejs/src/utils/logs/error-2024-10-28.log",
            "hash": "86f285addad02b2d0b9b010580b734827019904ad0edb4f9230fc5209c3b98ce"
        }
    ],
    "hashType": "sha256"
}
===== ./utils/logs/.bced1be757c51aba403666c9195bc2aa4cfbbb5a-audit.json =====


===== # =====


===== separador =====


===== legível =====

{
    "keep": {
        "days": true,
        "amount": 30
    },
    "auditLog": "/home/gilberto/aula/repositorios/@@repositorios_oficial-verificado/4-event-grid/user-service-nodejs/src/utils/logs/.bced1be757c51aba403666c9195bc2aa4cfbbb5a-audit.json",
    "files": [
        {
            "date": 1729800795011,
            "name": "/home/gilberto/aula/repositorios/@@repositorios_oficial-verificado/4-event-grid/user-service-nodejs/src/utils/logs/combined-2024-10-24.log",
            "hash": "0beb5ac1874de9d43fea6824c66d1d6a1b10a08d59f53b1258e899ec3076f430"
        },
        {
            "date": 1729887717794,
            "name": "/home/gilberto/aula/repositorios/@@repositorios_oficial-verificado/4-event-grid/user-service-nodejs/src/utils/logs/combined-2024-10-25.log",
            "hash": "4967a4d0d51edd05b0124f5ecbfca9841ac186c642a5aa21d39dcca4404dd8a9"
        },
        {
            "date": 1730139182873,
            "name": "/home/gilberto/aula/repositorios/@@repositorios_oficial-verificado/4-event-grid/user-service-nodejs/src/utils/logs/combined-2024-10-28.log",
            "hash": "c58d188f8418e06f4a48eea33ebb3367d618c17ff79f1dcf29c8e88794c13303"
        }
    ],
    "hashType": "sha256"
}
===== ./utils/SendMail.js =====


===== # =====


===== separador =====


===== legível =====

import nodemailer from 'nodemailer';
import dotenv from 'dotenv';
import crypto from 'crypto';

dotenv.config();

class SendMail {
  static async enviaEmail(infoemail) {
    // Verifica se o serviço de email está desativado
    if (process.env.DISABLED_EMAIL) {
      console.log('Serviço de Email desativado');
      return; // Adiciona o return para interromper a execução
    }


    try {
      // Configuração do transportador
      let transporter = nodemailer.createTransport({
        host: process.env.EMAIL_HOST,
        port: process.env.EMAIL_PORT,
        secure: false, // true para 465, false para outras portas
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASS,
        },
      });

      // Gerar hash para o ID do email
      const hashId = () => crypto.randomBytes(6).toString('hex');

      // Envia o email
      let info = await transporter.sendMail({
        from: process.env.EMAIL_USER,
        to: infoemail.to,
        subject: `${infoemail.subject} Email: #${hashId()}`,
        text: infoemail.text,
        html: infoemail.html,
      });

      console.log('Email enviado: %s', info.messageId);
    } catch (err) {
      console.error('Erro ao enviar email:', err);
      return { error: true, code: 500, message: 'Erro interno do Servidor' };
    }
  }

  static async enviaEmailError(err, pathname, date, req) {
    const infoEmail = {
      to: process.env.ADMIN_EMAIL,
      subject: `Erro interno do servidor na classe: ${pathname}`,
      text: `Erro Detectado \n\nErro interno do Servidor\n\nAtenciosamente,\nEquipe de suporte\n\nErro: ${err.message}\n\nArquivo: ${pathname}\n\nData e Hora: ${date}`,
      html: `<p>Olá,</p><p>Erro interno do Servidor</p><p>Atenciosamente,</p><p>Equipe de suporte</p><p>Erro: ${err.message}</p><p>Arquivo: ${pathname}</p><p>Data e Hora: ${date}</p><p>Requisição: ${req.method}</p><p>URL: ${req.protocol}://${req.get('host')}${req.originalUrl}</p>`,
    };

    await this.enviaEmail(infoEmail);
  }

  static async enviaEmailErrorDbConect(err, pathname, date) {
    const infoEmail = {
      to: process.env.ADMIN_EMAIL,
      subject: `Erro interno do servidor na classe: ${pathname}`,
      text: `Erro Detectado \n\nErro interno do Servidor\n\nAtenciosamente,\nEquipe de suporte\n\nErro: ${err.message}\n\nArquivo: ${pathname}\n\nData e Hora: ${date}`,
      html: `<p>Olá,</p><p>Erro interno do Servidor</p><p>Atenciosamente,</p><p>Equipe de suporte</p><p>Erro: ${err.message}</p><p>Arquivo: ${pathname}</p><p>Data e Hora: ${date}</p>`,
    };

    await this.enviaEmail(infoEmail);
  }
}

export default SendMail;

===== ./utils/swagger_utils/removeFields.js =====


===== # =====


===== separador =====


===== legível =====

// /src/utils/swagger_utils/removeFields.js

// Função recursiva para remover propriedades indesejadas
export default function removeFieldsRecursively(obj, fieldsToRemove) {
    if (Array.isArray(obj)) {
        obj.forEach(item => removeFieldsRecursively(item, fieldsToRemove));
    } else if (obj && typeof obj === 'object') {
        Object.keys(obj).forEach(key => {
            if (fieldsToRemove.includes(key)) {
                delete obj[key];
            } else {
                removeFieldsRecursively(obj[key], fieldsToRemove);
            }
        });
    }
}
===== ./utils/TokenUtil.js =====


===== # =====


===== separador =====


===== legível =====

// /src/utils/TokenUtil.js
import jwt from 'jsonwebtoken';

class TokenUtil {
  generateAccessToken(id) {
    return jwt.sign({ id }, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_ACCESS_TOKEN_EXPIRATION
    });
  }

  generateRefreshToken(id) {
    return jwt.sign({ id }, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_REFRESH_TOKEN_EXPIRATION
    });
  }
}

export default new TokenUtil();

===== ./utils/Validator.js =====


===== # =====


===== separador =====


===== legível =====

import i18n from '../config/i18nConfig.js';

class Validator {
    constructor(locale = 'pt') {
        i18n.setLocale(locale);
        this._erro = null;
    }

    get erro() {
        return this._erro;
    }

    // Método privado que retorna a instância atual para permitir encadeamento
    _validar(condicao, mensagemKey, placeholders = {}) {
        if (this._erro === null && condicao()) {
            let mensagem = i18n.__(`validation.${mensagemKey}`, placeholders);
            this._erro = mensagem;
        }
        return this;
    }

    validarCampoObrigatorio(valor, campoNome) {
        return this._validar(
            () => valor === null || valor === undefined || valor.toString().trim() === '',
            'required',
            { campoNome }
        );
    }

    validarComprimento(valor, min, max, campoNome) {
        return this
            ._validar(
                () => valor === null || valor === undefined || valor.toString().trim() === '',
                'notEmpty',
                { campoNome }
            )
            ._validar(
                () => valor !== null && valor.length < min,
                'minLength',
                { campoNome, min }
            )
            ._validar(
                () => max !== null && valor !== null && valor.length > max,
                'maxLength',
                { campoNome, max }
            );
    }

    validarNomeProprio(nome, campoNome) {
        const nomeProprioRegex = /^[A-Za-zÀ-ú\s.]+$/;
        return this
            ._validar(
                () => nome === null || nome === undefined || nome.trim() === '',
                'required',
                { campoNome }
            )
            ._validar(
                () => nome !== null && !nomeProprioRegex.test(nome),
                'invalidName',
                { campoNome }
            );
    }

    validarTextoSemCaracteresEspeciais(texto, campoNome) {
        const textoRegex = /^[\p{L}0-9\s.\-]+$/u;
        return this
            ._validar(
                () => texto === null || texto === undefined || texto.trim() === '',
                'notEmpty',
                { campoNome }
            )
            ._validar(
                () => texto !== null && !textoRegex.test(texto),
                'invalidSpecialChars',
                { campoNome }
            );
    }

    validarAlfanumerico(valor, campoNome) {
        const alfanumericoRegex = /^[A-Za-z0-9]+$/;
        return this
            ._validar(
                () => valor === null || valor === undefined || valor.toString().trim() === '',
                'required',
                { campoNome }
            )
            ._validar(
                () => valor !== null && !alfanumericoRegex.test(valor),
                'alphanumeric',
                { campoNome }
            );
    }

    validarCPF(cpf, campoNome) {
        const cpfRegex = /^[0-9]{3}\.[0-9]{3}\.[0-9]{3}-[0-9]{2}$/;
        return this
            ._validar(
                () => cpf === null || cpf === undefined || cpf.trim() === '',
                'required',
                { campoNome }
            )
            ._validar(
                () => cpf !== null && !cpfRegex.test(cpf),
                'invalidCPF',
                { campoNome }
            )
            ._validar(
                () => cpf !== null && !this._validarCPFLogic(cpf),
                'invalidCPF',
                { campoNome }
            );
    }

    // Lógica de validação de CPF
    _validarCPFLogic(cpf) {
        const numeros = cpf.replace(/\D/g, '');
        if (numeros.length !== 11 || /^(\d)\1+$/.test(numeros)) return false;

        let soma = 0;
        for (let i = 0; i < 9; i++) {
            soma += parseInt(numeros.charAt(i)) * (10 - i);
        }
        let resultado = soma % 11 < 2 ? 0 : 11 - (soma % 11);
        if (resultado !== parseInt(numeros.charAt(9))) return false;

        soma = 0;
        for (let i = 0; i < 10; i++) {
            soma += parseInt(numeros.charAt(i)) * (11 - i);
        }
        resultado = soma % 11 < 2 ? 0 : 11 - (soma % 11);
        if (resultado !== parseInt(numeros.charAt(10))) return false;

        return true;
    }

    // Continue adaptando os outros métodos seguindo o mesmo padrão...

    // Exemplo para validarCNPJ
    validarCNPJ(cnpj, campoNome) {
        const cnpjRegex = /^[0-9]{2}\.[0-9]{3}\.[0-9]{3}\/[0-9]{4}-[0-9]{2}$/;
        return this
            ._validar(
                () => cnpj === null || cnpj === undefined || cnpj.trim() === '',
                'required',
                { campoNome }
            )
            ._validar(
                () => cnpj !== null && !cnpjRegex.test(cnpj),
                'invalidCNPJ',
                { campoNome }
            )
            ._validar(
                () => cnpj !== null && !this._validarCNPJLogic(cnpj),
                'invalidCNPJ',
                { campoNome }
            );
    }

    // Lógica de validação de CNPJ
    _validarCNPJLogic(cnpj) {
        const numeros = cnpj.replace(/\D/g, '');
        if (numeros.length !== 14) return false;

        if (/^(\d)\1+$/.test(numeros)) return false;

        let tamanho = 12;
        let numerosCnpj = numeros.substring(0, tamanho);
        const digitos = numeros.substring(tamanho);
        let soma = 0;
        const pos = tamanho - 7;
        for (let i = tamanho; i >= 1; i--) {
            soma += numerosCnpj.charAt(tamanho - i) * pos--;
            if (pos < 2) pos = 9;
        }
        let resultado = soma % 11 < 2 ? 0 : 11 - (soma % 11);
        if (resultado !== parseInt(digitos.charAt(0))) return false;

        tamanho = 13;
        numerosCnpj = numeros.substring(0, tamanho);
        soma = 0;
        let pos2 = tamanho - 7;
        for (let i = tamanho; i >= 1; i--) {
            soma += numerosCnpj.charAt(tamanho - i) * pos2--;
            if (pos2 < 2) pos2 = 9;
        }
        resultado = soma % 11 < 2 ? 0 : 11 - (soma % 11);
        if (resultado !== parseInt(digitos.charAt(1))) return false;

        return true;
    }

    // Continue adaptando os demais métodos seguindo o mesmo padrão...

    // Método para validar e retornar a primeira mensagem de erro encontrada
    validar() {
        return this._erro;
    }
}

export default Validator;

===== ./utils/validators/schemas/zod/BaseRotaSchema.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/BaseRotaSchema.js
import { z } from 'zod';
import ObjectID from './ObjectIdSchema.js';

export const BaseRotaSchema = z.object({
    _id: ObjectID.optional(),
    rota: z.string().min(1,'O campo rota é obrigatório.'),
    dominio: z.string().min(1,'O campo domínio é obrigatório.'),
});

===== ./utils/validators/schemas/zod/CursoSchema.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/CursoSchema.js

import { z } from 'zod';
import objectIdSchema from './ObjectIdSchema.js';

const CursoSchema = z.object({
  nome: z.string().min(1, 'Campo nome é obrigatório.'),
  codigo: z.string().min(1, 'Campo codigo é obrigatório.'),
  contra_turnos: z.object({
    segunda: z.boolean().default(false),
    terca: z.boolean().default(false),
    quarta: z.boolean().default(false),
    quinta: z.boolean().default(false),
    sexta: z.boolean().default(false),
    sabado: z.boolean().default(false),
    domingo: z.boolean().default(false),
  }).default({
    segunda: false,
    terca: false,
    quarta: false,
    quinta: false,
    sexta: false,
    sabado: false,
    domingo: false,
  }),
});

const CursoUpdateSchema = CursoSchema.partial();

export { CursoSchema, CursoUpdateSchema };

===== ./utils/validators/schemas/zod/EstudanteSchema.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/EstudanteSchema.js

import { z } from 'zod';
import objectIdSchema from './ObjectIdSchema.js';

const EstudanteSchema = z.object({
  _id: z.string().min(1, 'O Campo ID é obrigatório.'),
  matricula: z.string().min(1, 'Campo matrícula é obrigatório.'),
  nome: z.string().min(1, 'Campo nome é obrigatório.'),
  turma: objectIdSchema,
  ativo: z.boolean().default(true)
});

const EstudanteUpdateSchema = EstudanteSchema.partial();

export { EstudanteSchema, EstudanteUpdateSchema };

===== ./utils/validators/schemas/zod/GrupoSchema.js =====


===== # =====


===== separador =====


===== legível =====

//src/utils/validators/schemas/zod/grupoSchema.js

import { z } from 'zod';
import objectIdSchema from './ObjectIdSchema.js';
import { RotaSchema } from './RotaSchema.js';

const GrupoSchema = z.object({
    nome: z.string().min(1, 'O campo nome é obrigatório.'),
    descricao: z.string().min(1, 'O campo descrição é obrigatório.'),
    ativo: z.boolean().default(true),
    permissoes: z.array(RotaSchema).default([]),
    unidades: z.array(objectIdSchema).default([]),
});

const GrupoUpdateSchema = GrupoSchema.partial();

export { GrupoSchema, GrupoUpdateSchema };

===== ./utils/validators/schemas/zod/LoginSchema.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/LoginSchema.js

import { z } from 'zod';

/** Definição da expressão regular para a senha
 * Padrão: 1 letra maiúscula, 1 letra minúscula, 1 número
 * Tamanho mínimo: 8 caracteres
 **/
const senhaRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z\d@$!%*?&]{8,}$/;

const LoginSchema = z.object({
    email: z.string().email('Formato de email inválido.').min(1, 'Campo email é obrigatório.'),
    senha: z
        .string()
        .min(8, 'A senha deve ter pelo menos 8 caracteres.')
        .refine((senha) => {
            if (!senha) return true; // Senha é opcional
            return senhaRegex.test(senha);
        }, {
            message: 'A senha deve conter pelo menos 1 letra maiúscula, 1 letra minúscula, 1 número e no mínimo 8 caracteres.',
        }),
});

export { LoginSchema };

===== ./utils/validators/schemas/zod/ObjectIdSchema.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/objectIdSchema.js

import { z } from 'zod';

// Expressão regular para validar ObjectId do MongoDB (24 caracteres hexadecimais)
const objectIdSchema = z.string().regex(/^[0-9a-fA-F]{24}$/, "Invalid MongoDB ObjectId");

export default objectIdSchema;

===== ./utils/validators/schemas/zod/PermissaoValidation.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/PermissaoValidation.js
import { z } from 'zod';
import { BaseRotaSchema } from './BaseRotaSchema.js';

// Schema para validação de permissões
const PermissaoSchema = BaseRotaSchema.omit({ dominio: true }).extend({
    dominio: z.string().min(1, 'O campo domínio é obrigatório.').optional(),
    ativo: z.boolean().optional(),
    buscar: z.boolean().optional(),
    enviar: z.boolean().optional(),
    substituir: z.boolean().optional(),
    modificar: z.boolean().optional(),
    excluir: z.boolean().optional(),
});

// Verifica se as permissões são únicas dentro do array
const PermissoesArraySchema = z.array(PermissaoSchema).refine((permissoes) => {
    const combinacoes = permissoes.map(p => `${p.rota}_${p.dominio || 'undefined'}`);
    const setCombinacoes = new Set(combinacoes);
    return combinacoes.length === setCombinacoes.size;
}, {
    message: 'Permissões duplicadas: rota + domínio devem ser únicos dentro do array.',
    path: ['permissoes'],
});

export { PermissaoSchema, PermissoesArraySchema };

===== ./utils/validators/schemas/zod/querys/CursoQuerySchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";
import mongoose from 'mongoose';

export const CursoIdSchema = z.string().refine((id) => mongoose.Types.ObjectId.isValid(id), {
    message: "ID inválido",
});

export const CursoQuerySchema = z.object({
    nome: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Nome não pode ser vazio",
        })
        .transform((val) => val?.trim()),
    codigo: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Código não pode ser vazio",
        })
        .transform((val) => val?.trim()),
    page: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 1))
        .refine((val) => Number.isInteger(val) && val > 0, {
            message: "Page deve ser um número inteiro maior que 0",
        }),
    limite: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 10))
        .refine((val) => Number.isInteger(val) && val > 0 && val <= 100, {
            message: "Limite deve ser um número inteiro entre 1 e 100",
        }),
});

===== ./utils/validators/schemas/zod/querys/EstudanteQuerySchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";
import mongoose from 'mongoose';

export const EstudanteIdSchema = z.string().refine(
    (id) => mongoose.Types.ObjectId.isValid(id),
    { message: "ID inválido" }
);

export const EstudanteQuerySchema = z.object({
    nome: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Nome não pode ser vazio",
        })
        .transform((val) => val?.trim()),
    matricula: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Matrícula não pode ser vazia",
        })
        .transform((val) => val?.trim()),
    turma: z.string().optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Turma não pode ser vazia",
        })
        .transform((val) => val?.trim()),
    page: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 1))
        .refine((val) => Number.isInteger(val) && val > 0, {
            message: "Page deve ser um número inteiro maior que 0",
        }),
    limite: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 10))
        .refine((val) => Number.isInteger(val) && val > 0 && val <= 100, {
            message: "Limite deve ser um número inteiro entre 1 e 100",
        }),
});

===== ./utils/validators/schemas/zod/querys/GrupoQuerySchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";
import mongoose from 'mongoose';

export const GrupoIdSchema = z.string().refine((id) => mongoose.Types.ObjectId.isValid(id), {
    message: "ID inválido",
});

export const GrupoQuerySchema = z.object({
    nome: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Nome não pode ser vazio",
        })
        .transform((val) => val?.trim()),
    descricao: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Descrição não pode ser vazio",
        })
        .transform((val) => val?.trim()),
    ativo: z
        .string()
        .optional()
        .refine((value) => !value || value === "true" || value === "false", {
            message: "Ativo deve ser 'true' ou 'false'",
        }),
    unidade: z.string().optional().transform((val) => val?.trim()),
    page: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 1))
        .refine((val) => Number.isInteger(val) && val > 0, {
            message: "Page deve ser um número inteiro maior que 0",
        }),
    limite: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 10))
        .refine((val) => Number.isInteger(val) && val > 0 && val <= 100, {
            message: "Limite deve ser um número inteiro entre 1 e 100",
        }),
});

===== ./utils/validators/schemas/zod/querys/RequestAuthorizationSchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";

/** Body esperado para a requisição de autorização
  {
    "accesstoken": "string",
    "refreshtoken": "string", //opcional
    "domain": "string",
    "path": "string",
    "metodo": "string",
    "query": "string",
    "params": {},
    "body": {}
  }
*/

const RequestAuthorizationSchema = z.object({
    accesstoken: z.string()
        .min(1, "Accesstoken não pode ser vazio")
        .refine(val => val.trim().toLowerCase() !== "null", {
            message: "Accesstoken inválido"
        })
        .transform((val) => val.trim()),

    // refreshtoken: z.string()
    //     .optional()
    //     .refine((val) => !val || val.trim().length > 0, {
    //         message: "Refreshtoken não pode ser vazio",
    //     })
    //     .transform((val) => val?.trim()),

    // domain: z.string()
    //     .min(1, "Domain não pode ser vazio")
    //     .transform((val) => val.trim()),

    // path: z.string()
    //     .min(1, "Path não pode ser vazio")
    //     .transform((val) => val.trim()),

    // metodo: z.string()
    //     .min(1, "Metodo não pode ser vazio")
    //     .transform((val) => val.trim()),

    // query: z.string()
    //     .optional()
    //     .refine((val) => !val || val.trim().length > 0, {
    //         message: "Query não pode ser vazio",
    //     })
    //     .transform((val) => val?.trim()),

    // params: z.record(z.any())
    //     .optional()
    //     .refine((val) => !val || Object.keys(val).length > 0, {
    //         message: "Params não pode ser vazio",
    //     }),

    // body: z.record(z.any())
    //     .optional()
    //     .refine((val) => !val || Object.keys(val).length > 0, {
    //         message: "Body não pode ser vazio",
    //     }),
}).passthrough();

const RequestAuthorizationUpdateSchema = RequestAuthorizationSchema.partial();

export { RequestAuthorizationSchema, RequestAuthorizationUpdateSchema };
===== ./utils/validators/schemas/zod/querys/RotaQuerySchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";
import mongoose from 'mongoose';

export const RotaIdSchema = z.string().refine((id) => mongoose.Types.ObjectId.isValid(id), {
    message: "ID inválido",
});

export const RotaQuerySchema = z.object({
    rota: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Rota não pode ser vazia",
        })
        .transform((val) => val?.trim()),
    dominio: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Domínio não pode ser vazio",
        }),
    ativo: z
        .string()
        .optional()
        .refine((value) => !value || value === "true" || value === "false", {
            message: "Ativo deve ser 'true' ou 'false'",
        }),
    page: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 1))
        .refine((val) => Number.isInteger(val) && val > 0, {
            message: "Page deve ser um número inteiro maior que 0",
        }),
    limite: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 10))
        .refine((val) => Number.isInteger(val) && val > 0 && val <= 100, {
            message: "Limite deve ser um número inteiro entre 1 e 100",
        }),
});

===== ./utils/validators/schemas/zod/querys/TurmaQuerySchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";
import mongoose from "mongoose";

export const TurmaIdSchema = z.string().refine((id) => mongoose.Types.ObjectId.isValid(id), { message: "ID inválido", })
  .transform((id) => new mongoose.Types.ObjectId(id));


export const TurmaQuerySchema = z.object({
  codigo_suap: z
    .string()
    .optional()
    .refine((val) => !val || val.trim().length > 0, {
      message: "Código SUAP não pode ser vazio",
    })
    .transform((val) => val?.trim()),
  descricao: z
    .string()
    .optional()
    .refine((val) => !val || val.trim().length > 0, {
      message: "Descrição não pode ser vazia",
    })
    .transform((val) => val?.trim()),
  curso: z.string().optional().transform((val) => val?.trim()),
  page: z
    .string()
    .optional()
    .transform((val) => (val ? parseInt(val, 10) : 1))
    .refine((val) => Number.isInteger(val) && val > 0, {
      message: "Page deve ser um número inteiro maior que 0",
    }),
  limite: z
    .string()
    .optional()
    .transform((val) => (val ? parseInt(val, 10) : 10))
    .refine((val) => Number.isInteger(val) && val > 0 && val <= 100, {
      message: "Limite deve ser um número inteiro entre 1 e 100",
    }),
});

===== ./utils/validators/schemas/zod/querys/UnidadeQuerySchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";
import mongoose from 'mongoose';

export const UnidadeIdSchema = z.string().refine((id) => mongoose.Types.ObjectId.isValid(id), {
    message: "ID inválido",
});

export const UnidadeQuerySchema = z.object({
    nome: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Nome não pode ser vazio",
        })
        .transform((val) => val?.trim()),
    locallidade: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Localidade não pode ser vazio",
        })
        .transform((val) => val?.trim()),
    ativo: z
        .string()
        .optional()
        .refine((value) => !value || value === "true" || value === "false", {
            message: "Ativo deve ser 'true' ou 'false'",
        }),
    page: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 1))
        .refine((val) => Number.isInteger(val) && val > 0, {
            message: "Page deve ser um número inteiro maior que 0",
        }),
    limite: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 10))
        .refine((val) => Number.isInteger(val) && val > 0 && val <= 100, {
            message: "Limite deve ser um número inteiro entre 1 e 100",
        }),
});

===== ./utils/validators/schemas/zod/querys/UsuarioQuerySchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";
import mongoose from 'mongoose';

export const UsuarioIdSchema = z.string().refine((id) => mongoose.Types.ObjectId.isValid(id), {
    message: "ID inválido",
});

export const UsuarioQuerySchema = z.object({
    nome: z
        .string()
        .optional()
        .refine((val) => !val || val.trim().length > 0, {
            message: "Nome não pode ser vazio",
        })
        .transform((val) => val?.trim()),
    email: z
        .union([z.string().email("Formato de email inválido"), z.undefined()])
        .optional(),
    ativo: z
        .string()
        .optional()
        .refine((value) => !value || value === "true" || value === "false", {
            message: "Ativo deve ser 'true' ou 'false'",
        }),
    grupo: z.string().optional().transform((val) => val?.trim()),
    unidade: z.string().optional().transform((val) => val?.trim()),
    page: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 1))
        .refine((val) => Number.isInteger(val) && val > 0, {
            message: "Page deve ser um número inteiro maior que 0",
        }),
    limite: z
        .string()
        .optional()
        .transform((val) => (val ? parseInt(val, 10) : 10))
        .refine((val) => Number.isInteger(val) && val > 0 && val <= 100, {
            message: "Limite deve ser um número inteiro entre 1 e 100",
        }),
});

===== ./utils/validators/schemas/zod/RotaSchema.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/RotaSchema.js
import { z } from 'zod';
import { BaseRotaSchema } from './BaseRotaSchema.js';

const RotaSchema = BaseRotaSchema.extend({
    ativo: z.boolean().default(true),
    buscar: z.boolean().default(false),
    enviar: z.boolean().default(false),
    substituir: z.boolean().default(false),
    modificar: z.boolean().default(false),
    excluir: z.boolean().default(false),
});

const RotaUpdateSchema = RotaSchema.partial();

export { RotaSchema, RotaUpdateSchema };

===== ./utils/validators/schemas/zod/TurmaSchema.js =====


===== # =====


===== separador =====


===== legível =====

import { z } from "zod";
import mongoose from "mongoose";

export const TurmaSchema = z.object({
  codigo_suap: z
    .string()
    .refine((val) => val.trim().length > 0, {
      message: "Código SUAP é obrigatório",
    })
    .transform((val) => val.trim()),
  descricao: z
    .string()
    .refine((val) => val.trim().length > 0, {
      message: "Descrição é obrigatória",
    })
    .transform((val) => val.trim()),
  curso: z
    .string()
    .refine((val) => mongoose.Types.ObjectId.isValid(val), {
      message: "ID de curso inválido",
    })
    .transform((val) => val.trim()),
});

export const TurmaUpdateSchema = TurmaSchema.partial();

export const TurmaIdSchema = z
  .string()
  .refine((id) => mongoose.Types.ObjectId.isValid(id), {
    message: "ID inválido",
  })
  .transform((id) => new mongoose.Types.ObjectId(id));

===== ./utils/validators/schemas/zod/UnidadeSchema.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/UnidadeSchema.js

import { z } from 'zod';
// Optionally, consider removing or mocking the repository import during tests.
// import UnidadeRepository from '../../../../repositories/UnidadeRepository.js';

const UnidadeSchema = z.object({
    nome: z.string({
        required_error: 'O campo nome é obrigatório.',
    }).min(1, "Este campo é obrigatório"),
    localidade: z.string({
        required_error: 'O campo localidade é obrigatório.',
    }).min(1, "Este campo é obrigatório"),
    ativo: z.boolean().default(true),
}).passthrough();

// Reapply the default for "ativo" when using partial
const UnidadeUpdateSchema = UnidadeSchema.partial().extend({
    ativo: z.boolean().default(true),
});

export { UnidadeSchema, UnidadeUpdateSchema };

===== ./utils/validators/schemas/zod/UsuarioSchema.js =====


===== # =====


===== separador =====


===== legível =====

// src/utils/validators/schemas/zod/UsuarioSchema.js

import { z } from 'zod';
import objectIdSchema from './ObjectIdSchema.js';
import { RotaSchema } from './RotaSchema.js';

/** Definição da expressão regular para a senha
 * Padrão: 1 letra maiúscula, 1 letra minúscula, 1 número e 1 caractere especial
 * Tamanho mínimo: 8 caracteres
 **/
const senhaRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

// Validação de array de ObjectId sem duplicações
const distinctObjectIdArray = z
  .array(objectIdSchema)
  .refine(
    (arr) => new Set(arr.map((id) => id.toString())).size === arr.length,
    { message: 'Não pode conter ids repetidos.' }
  );

const UsuarioSchema = z.object({
  nome: z.string().min(1, 'Campo nome é obrigatório.'),
  email: z
    .string()
    .email('Formato de email inválido.')
    .min(1, 'Campo email é obrigatório.'),
  senha: z
    .string()
    .min(8, 'A senha deve ter pelo menos 8 caracteres.')
    .optional()
    .refine(
      (senha) => {
        // Senha é opcional
        if (!senha) return true;
        return senhaRegex.test(senha);
      },
      {
        message:
          'A senha deve conter pelo menos 1 letra maiúscula, 1 letra minúscula, 1 número e 1 caractere especial.',
      }
    ),
  link_foto: z.string().optional(),
  ativo: z.boolean().default(false),

  // Arrays sem ids repetidos:
  grupos: distinctObjectIdArray.default([]),
  unidades: distinctObjectIdArray.default([]),

  // Permissões permanece como estava
  permissoes: z.array(RotaSchema).default([]),
});

const UsuarioUpdateSchema = UsuarioSchema.partial();

export { UsuarioSchema, UsuarioUpdateSchema };
